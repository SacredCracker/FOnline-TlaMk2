//  Debug functions


#include "_macros.fos"
#include "_maps.fos"
#include "_colors.fos"
#include "_offplayer.fos"
#include "fractions.h"
#include "_cityrole.fos"

// import void SetTracker(Critter& cr, int trackId) from "main";
import void      SetTracker( Critter& cr, int trackId ) from "globalmap_group";
import Fraction@ GetFraction( uint id ) from "Mk2";
import Fraction@ GetFraction( string& name ) from "Mk2";
import void      DrapRatingsAll() from "Mk2";
import bool      Merc2Player( Critter& player, Critter& merc, uint16 type )  from "merc";
import string@[] GetFractionList() from "Mk2";
import void      InitRandomisationItem( Item& item, bool isCrafted, Critter& cr, string sufix ) from "Mk2";
import void      SayToAllPlayers( uint16 textMsg, uint strNum, string@ lexems ) from "Mk2";
import void      r_HalfOn( Critter& master, Critter@npc ) from "energy_barier";
import uint[]@    GetPlayersByFraction( uint orgId ) from "Mk2";

import void AffectPoison( Critter& cr, int value ) from "Mk2";
import void DropPoison( Critter& cr ) from "Mk2";
import void SetStorm( Location& loc, int time ) from "Mk2";
import void addBlueprint( Critter@ cr, uint16 pid, uint16 count ) from "fix_boy";
import void ActivateMobScript( Map& map ) from "Mk2";
import void SetFire( Map& map, uint16 hx, uint16 hy, uint16 radius, uint16 damage, Critter@ cr ) from "Mk2";
import void SetInFire( Critter& cr, uint damage, Critter@ attacker ) from "Mk2";

void MakeBackup( Critter& cr, int, int, int )
{
    cr.ShowScreen( SCREEN_SAY, 0, "SaveBackup" );
    cr.Say( SAY_SAY_TITLE, "Введите имя файла:" );
}

void SaveBackup( Critter& cr, uint, string& filename )
{
    Map@ map = cr.GetMap();

    uint[] itemData;

    Item@[] items;

    for( uint n = ITEM_TYPE_ARMOR; n < ITEM_TYPE_CONTAINER; n++ )
    {
        map.GetItemsByType( n, items );
    }
    itemData.resize( items.length() * 4 + 1 );
    itemData[ 0 ] = items.length();
    for( uint n = 0; n < items.length(); n++ )
    {
        itemData[ n * 4 + 1 ] = items[ n ].HexX;
        itemData[ n * 4 + 2 ] = items[ n ].HexY;
        itemData[ n * 4 + 3 ] = items[ n ].GetProtoId();
        itemData[ n * 4 + 4 ] = items[ n ].GetCount();
    }
    items.resize( 0 );
    map.GetItemsByType( ITEM_TYPE_CONTAINER, items );
    itemData.insertLast( items.length() );
    for( uint n = 0; n < items.length(); n++ )
    {
        itemData.insertLast( items[ n ].HexX );
        itemData.insertLast( items[ n ].HexY );
        itemData.insertLast( items[ n ].GetProtoId() );
        Item@[] contItems;
        items[ n ].GetItems( 0, contItems );
        itemData.insertLast( contItems.length() );
        for( uint i = 0; i < contItems.length(); i++ )
        {
            itemData.insertLast( contItems[ i ].GetProtoId() );
            itemData.insertLast( contItems[ i ].GetCount() );
        }
    }

    file f;
    filename += ".bin";
    if( f.open( filename, "w" ) == 0 )
    {
        for( uint n = 0; n < itemData.length(); n++ )
            f.writeUint32( itemData[ n ] );
        f.close();
        cr.Say( SAY_NETMSG, "Данные карты успешно сохранены в " + filename );
    }
}


void RestoreMap( Critter& cr, int, int, int )
{
    cr.ShowScreen( SCREEN_SAY, 0, "LoadBackup" );
    cr.Say( SAY_SAY_TITLE, "Введите имя файла:" );
}

void LoadBackup( Critter& cr, uint, string& filename )
{
    filename += ".bin";
    file f;
    if( f.open( filename, "r" ) != 0 )
    {
        cr.Say( SAY_NETMSG, "Файл " + filename + " не найден!" );
        return;
    }
    Map@ map = cr.GetMap();
    Item@[] mapItems;
    for( uint n = ITEM_TYPE_ARMOR; n <= ITEM_TYPE_CONTAINER; n++ )
    {
        map.GetItemsByType( n, mapItems );
    }
    DeleteItems( mapItems );
    uint count = f.readUint32();
    for( uint n = 0; n < count; n++ )
    {
        uint  hx = f.readUint32(), hy = f.readUint32(), pid = f.readUint32(), c = f.readUint32();
        Item@ it = map.AddItem( hx, hy, pid, c );
        if( valid( it ) )
            it.Update();
        else
            Log( "Unable to place item on map! pid: " + pid + ", HexX: " + hx + ", HexY: " + hy + ", count: " + c );
    }
    count = f.readUint32();
    for( uint n = 0; n < count; n++ )
    {
        uint  hx = f.readUint32(), hy = f.readUint32(), pid = f.readUint32(), c = 1;
        Item@ cont = map.AddItem( hx, hy, pid, c );
        if( valid( cont ) )
        {
            uint iCount = f.readUint32();
            for( uint i = 0; i < iCount; i++ )
            {
                pid = f.readUint32();
                c = f.readUint32();
                Item@ it = cont.AddItem( pid, c, 0 );
                if( @it == null )
                    Log( "Unable to place item in container! Pid: " + pid + ", count: " + count );
            }
        }
        else
        {
            Log( "Unable to place container on map! HexX: " + hx + ", HexY: " + hy + ", Pid: " + pid );
            return;
        }
        cont.Update();
    }
    cr.Say( SAY_NETMSG, "Map restored!" );
    f.close();
}

void infire( Critter& player, int id, int damage, int )
{
    Critter@ cr = GetCritter( ( id == 0 ? player.Id : id ) );
    if( valid( cr ) )
        SetInFire( cr, damage, null );
}

void fire( Critter& cr, int damage, int radius, int )
{
    SetFire( cr.GetMap(), cr.HexX, cr.HexY, radius, damage, cr );
}

void ListParam( Critter& player, int id, int, int )
{
    Critter@ cr = GetCritter( id );
    if( @cr == null )
        @cr = player;
    for( uint n = 0; n < 1000; n++ )
    {
        cr.Say( SAY_NETMSG, n + ". " + cr.Param[ n ] );
    }
}

void SetCritterName( Critter& cr, int id, int, int )
{
    cr.StatBase[ ST_VAR0 ] = id;
    cr.ShowScreen( SCREEN_SAY, 0, "SetCrName" );
    cr.Say( SAY_SAY_TITLE, "Введите новое имя криттера:" );
}

void SetCrName( Critter& cr, uint, string& name )
{
    Critter@ crit = GetCritter( cr.Stat[ ST_VAR0 ] );
    if( @crit == null )
        @crit = cr;
    crit.SetCustomName( name );
    crit.RefreshVisible();
}

void FindByParam( Critter& cr, int index, int val, int )
{
    Critter@[] crits;
    GetAllPlayers( crits );
    uint count = 0;
    for( uint n = 0; n < crits.length(); n++ )
    {
        if( valid( crits[ n ] ) && crits[ n ].Param[ index ] == val )
        {
            count++;
            cr.Say( SAY_NETMSG, count + ". " + GetPlayerName( crits[ n ].Id ) + ". Id: " + crits[ n ].Id );
        }
    }
}

void FindDialog( Critter& cr, int dialogId, int, int )
{
    Critter@[] crits;
    GetAllNpc( 0, crits );
    uint count = 0;
    for( uint n = 0; n < crits.length(); n++ )
    {
        if( crits[ n ].Stat[ ST_DIALOG_ID ] == dialogId )
        {
            cr.Say( SAY_NETMSG, ( ++count ) + ". " + crits[ n ].Name + ". ID: " + crits[ n ].Id );
        }
    }
}

void FindBP( Critter& cr, int pid, int count, int )
{
    Item@[] items;
    GetAllItems( PID_BLUEPRINT, items );
    Critter@ owner;
    Map@     map;
    uint     num = 0;
    uint16   x = 0, y = 0;
    for( uint n = 0; n < items.length(); n++ )
    {
        if( items[ n ].Val1 != pid || ( count != 0 && count != items[ n ].Val2 ) )
            continue;
        num++;
        if( items[ n ].Accessory == ACCESSORY_CRITTER )
        {
            @owner = GetCritter( items[ n ].CritId );
            if( valid( owner ) )
                cr.Say( SAY_NETMSG, num + ". В инвентаре у " + owner.Name + ". Id: " + owner.Id );
            else
            {
                string@ name = GetPlayerName( items[ n ].CritId );
                if( valid( name ) )
                    cr.Say( SAY_NETMSG, num + ". В инвентаре у " + name + "(оффлайн)" );
                else
                    cr.Say( SAY_NETMSG, num + ". Х3!" );
            }
            continue;
        }
        @map = items[ n ].GetMapPosition( x, y );
        if( valid( map ) )
            cr.Say( SAY_NETMSG, num + ". На карте с ID " + map.Id + ". Гекс: " + x + ", " + y );
    }
}

void FindKeys( Critter& cr, int paramId, int, int )
{
    uint id = paramId;
    Item@[] items;
    for( uint16 n = PID_KEY; n <= PID_JAIL_KEY; n++ )
    {
        GetAllItems( n, items );
    }
    Critter@ owner;
    Map@     map;
    uint     count = 0;
    uint16   x = 0, y = 0;
    for( uint m = 0; m < items.length(); m++ )
    {
        if( items[ m ].LockerId != id )
            continue;
        count++;
        if( items[ m ].Accessory == ACCESSORY_CRITTER )
        {
            @owner = GetCritter( items[ m ].CritId );
            if( valid( owner ) )
                cr.Say( SAY_NETMSG, count + ". В инвентаре у " + owner.Name + ". Id: " + owner.Id );
            else
            {
                string@ name = GetPlayerName( items[ m ].CritId );
                if( valid( name ) )
                    cr.Say( SAY_NETMSG, count + ". В инвентаре у " + name + "(оффлайн)" );
                else
                    cr.Say( SAY_NETMSG, count + ". Х3!" );
            }
            continue;
        }
        @map = items[ m ].GetMapPosition( x, y );
        if( valid( map ) )
            cr.Say( SAY_NETMSG, count + ". На карте с ID " + map.Id + ". Гекс: " + x + ", " + y );
    }
}

void AddLevel( Critter& cr, int id, int levelCount, int nextPerk )
{
    Critter@ player = GetCritter( id == 0 ? cr.Id : id );
    if( player is null || player.IsNpc() )
    {
        cr.Say( SAY_NETMSG, "Player not found!" );
        return;
    }
    if( levelCount > 0 )
    {
        int level = player.Stat[ ST_LEVEL ] + levelCount - 1;
        player.StatBase[ ST_EXPERIENCE ] = NUMERICAL_NUMBER( level ) * 1000;
        return;
    }
    if( nextPerk == 1 )
    {
        int divider = 3;
        if( player.Param[ TRAIT_SKILLED ] != 0 )
            divider++;
        int level = player.Stat[ ST_LEVEL ] + divider - player.Stat[ ST_LEVEL ] % divider - 1;
        player.StatBase[ ST_EXPERIENCE ] = NUMERICAL_NUMBER( level ) * 1000;
    }
}

void FindEntires( Critter& cr, int id, int, int )
{
    Map@ map = cr.GetMap();
    if( @map == null )
        return;

    uint count = map.CountEntire( id );

    cr.Say( SAY_NETMSG, "Найдено " + count + " энтайров" );

    for( uint n = 0; n < count; n++ )
    {
        uint16 hx = 0, hy = 0;
        map.GetEntireCoords( id, n, hx, hy );
        cr.Say( SAY_NETMSG, "X=" + hx + ", Y=" + hy );
        map.SetText( hx, hy, COLOR_RED, "HERE!" );
    }
}

void FixBP( Critter& cr, int, int, int )
{
    Item@[] bp;
    uint count = 0;
    GetAllItems( PID_BLUEPRINT, bp );
    for( uint n = 0; n < bp.length(); n++ )
    {
        if( bp[ n ].Val2 == 0 )
        {
            bp[ n ].Val2 = 1;
            count++;
        }
    }
    cr.Say( SAY_NETMSG, "Исправлено " + count + " рецептов." );
}

void CopyLocation( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    if( @map == null )
    {
        cr.Say( SAY_NETMSG, "WHAT LOCATION?" );
        return;
    }
    Location@ oldLoc = map.GetLocation();
    uint      locId = CreateLocation( oldLoc.GetProtoId(), oldLoc.WorldX, oldLoc.WorldY, null );
    Location@ loc = GetLocation( locId );
    if( @loc == null )
    {
        cr.Say( SAY_NETMSG, "Oops! Failed!" );
        return;
    }
    for( uint n = 0; n < oldLoc.GetMapCount(); n++ )
    {
        Map@ oldMap = oldLoc.GetMapByIndex( n );
        Map@ newMap = loc.GetMapByIndex( n );
        if( valid( oldMap ) && valid( newMap ) )
        {
            for( uint n = 0; n < 100; n++ )
            {
                newMap.SetData( n, oldMap.GetData( n ) );
            }
        }
    }
    Map@ newMap = loc.GetMap( map.GetProtoId() );
    cr.TransitToMap( newMap.Id, cr.HexX, cr.HexY, cr.Dir );
    DeleteLocation( oldLoc.Id );
    cr.Say( SAY_NETMSG, "Done! I hope..." );
}

void MapData( Critter& cr, int index, int val, int set )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        if( set == 1 )
        {
            map.SetData( index, val );
            cr.Say( SAY_NETMSG, "Val " + index + " is set to " + val );
        }
        else
            cr.Say( SAY_NETMSG, "Val #" + index + " = " + map.GetData( index ) );
    }
    else
        cr.Say( SAY_NETMSG, "You're supposed to be on map" );
}

void ItemsStat( Critter& cr, int, int, int )
{
    dictionary ItemsPreprocessor;
    ItemPreprocessorInit( ItemsPreprocessor );

    if( @cr.GetMap() == null )
    {
        cr.Say( SAY_NETMSG, "Map not found!" );
        return;
    }
    Location@ loc = cr.GetMap().GetLocation();

    uint[][] ItemCount( 4, array< uint >( 5060, 0 ) );
    Map@[] maps;
    for( uint n = 0; n < loc.GetMaps( maps ); n++ )
    {
        Item@[] items;
        for( int t = ITEM_TYPE_ARMOR; t <= ITEM_TYPE_KEY; t++ )
            maps[ n ].GetItemsByType( t, items );

        for( uint i = 0; i < items.length(); i++ )
            ItemCount[ 0 ][ items[ i ].GetProtoId() ] += items[ i ].GetCount();

        items.resize( 0 );
        maps[ n ].GetItemsByType( ITEM_TYPE_CONTAINER, items );

        for( uint i = 0; i < items.length(); i++ )
        {
            Item@[] content;
            for( uint ii = 0; ii < items[ i ].GetItems( 0, content ); ii++ )
                ItemCount[ 1 ][ content[ ii ].GetProtoId() ] += content[ ii ].GetCount();
        }

        Critter@[] critters;

        maps[ n ].GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );

        for( uint c = 0; c < critters.length(); c++ )
        {
            Item@[] content;
            critters[ c ].GetItems( -1, content );
            for( uint i = 0; i < content.length(); i++ )
            {
                ItemCount[ ( critters[ c ].IsDead() ? 2 : 3 ) ][ content[ i ].GetProtoId() ] += content[ i ].GetCount();
            }
        }
    }

    file f;

    if( f.open( "items(" + loc.Id + ").txt", "w" ) >= 0 )
    {
        f.writeString( "Всего на земле:\n" );
        for( uint16 n = 1; n < 5060; n++ )
        {
            if( ItemCount[ 0 ][ n ] == 0 )
                continue;
            string@ name = "" + n;
            if( ItemsPreprocessor.exists( name ) )
                ItemsPreprocessor.get( name, name );
            for( uint t = name.length(); t <= 40; t++ )
                name += " ";
            f.writeString( name + ItemCount[ 0 ][ n ] + "\n" );
        }
        f.writeString( "\nВсего в контейнерах:\n" );
        for( uint16 n = 1; n < 5060; n++ )
        {
            if( ItemCount[ 1 ][ n ] == 0 )
                continue;
            string@ name = "" + n;
            if( ItemsPreprocessor.exists( name ) )
                ItemsPreprocessor.get( name, name );
            for( uint t = name.length(); t <= 40; t++ )
                name += " ";
            f.writeString( name + ItemCount[ 1 ][ n ] + "\n" );
        }
        f.writeString( "\nВсего в трупах:\n" );
        for( uint16 n = 1; n < 5060; n++ )
        {
            if( ItemCount[ 2 ][ n ] == 0 )
                continue;
            string@ name = "" + n;
            if( ItemsPreprocessor.exists( name ) )
                ItemsPreprocessor.get( name, name );
            for( uint t = name.length(); t <= 40; t++ )
                name += " ";
            f.writeString( name + ItemCount[ 2 ][ n ] + "\n" );
        }
        f.writeString( "\nВсего у НПЦ:\n" );
        for( uint16 n = 1; n < 5060; n++ )
        {
            if( ItemCount[ 3 ][ n ] == 0 )
                continue;
            string@ name = "" + n;
            if( ItemsPreprocessor.exists( name ) )
                ItemsPreprocessor.get( name, name );
            for( uint t = name.length(); t <= 40; t++ )
                name += " ";
            f.writeString( name + ItemCount[ 3 ][ n ] + "\n" );
        }
        f.close();
        cr.Say( SAY_NETMSG, "Статистика записана в файл items(" + loc.Id + ").txt" );
    }
    else
        cr.Say( SAY_NETMSG, "Unable to create file!" );

}

void AddBlueprint( Critter& cr, int pid, int count, int number )
{
    for( int n = 0; n < number; n++ )
        addBlueprint( cr, pid, count );
}

void ItemPreprocessorInit( dictionary& ItemsPreprocessor )
{
    file f;
    if( f.open( ".\\data\\ItemNames.lst", "r" ) >= 0 )
    {
        string allStr;
        f.readString( f.getSize(), allStr );
        f.close();
        string@[] strings = splitEx( allStr, "\n" );
        for( uint n = 0; n < strings.length(); n++ )
        {
            if( substring( strings[ n ], 0, 1 ) == "#" )
                continue;
            string@[] pair = splitEx( strings[ n ], " " );
            if( pair.length() != 2 )
                continue;
            ItemsPreprocessor.set( pair[ 0 ], pair[ 1 ] );
        }
    }
    else
        Log( "Unable to open ItemNames.lst. Loading Farm Locations fail." );
}

void SetLockerCondition( Critter& cr, int id, int lockerCondition, int )
{
    Item@ door = GetItem( id );
    if( @door == null )
        return;
    door.LockerCondition = lockerCondition;
    cr.Say( SAY_NETMSG, "Locker set." );
}

void SetTime( Critter& cr, int time, int, int )
{
    cr.GetMap().SetTime( time );
}

void StartStorm( Critter& cr, int time, int, int )
{
    SetStorm( cr.GetMap().GetLocation(), time );
}

void SetCritterScript( Critter& cr, int id, int, int )
{
    Critter@ npc = GetCritter( id );
    if( @npc == null )
        return;
    cr.StatBase[ ST_VAR0 ] = id;
    cr.ShowScreen( SCREEN_SAY, 0, "SetCrScript" );
    cr.Say( SAY_SAY_TITLE, "Введите имя скрипта:" );
}

void SetCrScript( Critter& cr, uint, string& script )
{
    Critter@ npc = GetCritter( cr.Param[ ST_VAR0 ] );
    if( npc is null || npc.IsPlayer() )
        return;
    npc.SetScript( script );
    Log( "Script set: " + script );
}

void SetLightColor( Critter& cr, int id, int color, int )
{
    Item@ item = GetItem( id );
    if( valid( item ) )
    {
        item.LightColor = color;
        item.Update();
    }
    else
        cr.Say( SAY_NETMSG, "Item not found!" );
}

void SetLight( Critter& cr, int id, int distance, int intensity )
{
    Item@ item = GetItem( id );
    if( valid( item ) )
    {
        item.LightColor = 0xFFFFFF;
        item.LightIntensity = intensity;
        item.LightDistance = distance;
        SETFLAG( item.Flags, ITEM_LIGHT );
        item.Update();
    }
    else
        cr.Say( SAY_NETMSG, "Item not found!" );
}

void SetLockerId( Critter& cr, int id, int keyId, int )
{
    Item@ locker = GetItem( id );
    if( @locker == null )
    {
        cr.Say( SAY_NETMSG, "Item not found!" );
        return;
    }
    locker.LockerId = keyId;
}

void SetLocker( Critter& cr, int id, int flags, int complexity )
{
    Item@ locker = GetItem( id );
    if( @locker == null )
    {
        cr.Say( SAY_NETMSG, "Item not found!" );
        return;
    }
    locker.LockerCondition = flags;
    locker.LockerComplexity = complexity;
    Log( "Noopen=" + LOCKER_NOOPEN );
}



void acab( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    if( @map == null )
        return;
    Critter@[] npcs;
    map.GetCritters( 0, FIND_ONLY_NPC | FIND_ALL, npcs );
    uint count = 0;
    for( uint n = 0; n < npcs.length(); n++ )
    {
        if( npcs[ n ].CityRole_IsGuard )
        {
            DeleteNpc( npcs[ n ] );
            count++;
        }
    }
    cr.Say( SAY_NETMSG, "Deleted " + count + " bastards!" );
}

void SetLocColor( Critter& cr, int r, int g, int b )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        map.GetLocation().Color = COLOR_RGB( r, g, b ) | 0x7F << 24;
    }
}

void Marko( Critter& cr, int pid, int, int )
{
    Map@ map = cr.GetMap();
    if( @map == null )
        return;
    Item@[] items;
    map.GetItems( pid, items );
    for( uint n = 0; n < items.length(); n++ )
    {
        map.SetText( items[ n ].HexX, items[ n ].HexY, COLOR_WHITE, "POLO!:" + items[ n ].Id );
        cr.Say( SAY_NETMSG, ( n + 1 ) + ") " + items[ n ].Id );
    }
}

void RememberThis( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    if( @map == null )
    {
        cr.Say( SAY_NETMSG, "You must be on map in order to run this function" );
        return;
    }
    cr.SetKnownLoc( true, map.GetLocation().Id );
}

void OwnThisBase( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    if( @map == null )
    {
        cr.Say( SAY_NETMSG, "You're supposed to be on map!" );
        return;
    }
    Location@ loc = map.GetLocation();
    cr.SetKnownLoc( true, loc.Id );
    loc.GetMapByIndex( 0 ).SetData( 0, cr.Id );
    loc.Visible = false;
    loc.Color = COLOR_SAND;
}

void GetName( Critter& cr, int id, int, int )
{
    cr.Say( SAY_NETMSG, "Player Name is :" + GetPlayerName( id ) );
}

void KillNpc( Critter& cr, int id, int, int )
{
    Map@ map = cr.GetMap();
    if( @map == null )
        return;
    Critter@[] npcs;
    map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_NPC, npcs );
    for( uint n = 0; n < npcs.length(); n++ )
    {
        npcs[ n ].ToDead( ANIM2_DEAD_PULSE_DUST, null );
    }
}

void ToContainer( Critter& cr, int id, int, int )
{
    Item@ cont = GetItem( id );
    if( @cont == null )
    {
        cr.Say( SAY_NETMSG, "Container " + id + " not found!" );
        return;
    }
    Map@ map = cr.GetMap();
    if( @map == null )
    {
        cr.Say( SAY_NETMSG, "You're supposed to be on map!" );
        return;
    }
    Item@[] items;
    for( uint n = ITEM_TYPE_ARMOR; n <= ITEM_TYPE_MISC; n++ )
    {
        map.GetItemsByType( n, items );
    }
    MoveItems( items, cont, 0 );
}

void testSwap( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cr1 = GetCritter( uint( p0 ) );
    Critter@ cr2 = GetCritter( uint( p1 ) );
    SwapCritters( cr1, cr2, true, true );
}

void AddWarehouse( Critter& cr,  int id, int mapPid, int )
{
    Critter@[] crits;
    crits.insertLast( @cr );
    Critter@ player = GetCritter( id );
    if( !valid( player ) )
    {
        cr.Say( SAY_NETMSG, "Warehouse host not found!" );
        return;
    }
    crits.insertLast( @player );
    uint      locId = CreateLocation( mapPid, cr.WorldX, cr.WorldY, crits );
    Location@ loc = GetLocation( locId );
    if( !valid( loc ) )
    {
        cr.Say( SAY_NETMSG, "Failed to create location!" );
        return;
    }
    Map@ map = loc.GetMapByIndex( 0 );
    map.SetData( 0, id );
    loc.Visible = false;
    loc.Color = COLOR_SAND;
    cr.Say( SAY_NETMSG, "Warehouse successfully created" );
}

void AddPoison( Critter& cr,  int id, int lvl, int )
{
    AffectPoison( cr, lvl );
}

void DropPoison( Critter& cr,  int id, int lvl, int )
{
    DropPoison( cr );
}

void DropFactionQuest( Critter& cr,  int quest, int id, int )
{
    Critter @leader = GetCritter( id );
    if( !valid( leader ) )
    {
        cr.Say( SAY_NETMSG, "Critter not found!" );
        return;
    }
    Fraction@ fr = GetFraction( leader.Param[ ST_FACTION ] );
    if( !valid( fr ) )
    {
        cr.Say( SAY_NETMSG, "Fraction not found!" );
        return;
    }

    uint locPid = 0,
         questId = 0,
         questVar = 0;

    switch( quest )

    {
    case 0:
        locPid = LOCATION_Salvatore_Supply;
        questId = FR_SALVATORE_SUPPLY;
        questVar = LVAR_q_salvatore_supply;
        break;
    case 1:
        locPid = LOCATION_Golgotha;
        questId = FR_WRIGHT_SUPPLY;
        questVar = LVAR_q_wright_supply;
        break;
    case 2:
        locPid = LOCATION_Stables;
        questId = FR_KILL_MIRON;
        questVar = LVAR_q_kill_miron;
        break;
    case 3:
        locPid = 231;
        questId = FR_QUEST_MUTANTS;
        questVar = LVAR_q_nov_mutants;
        break;
    default:
        cr.Say( SAY_NETMSG, "Invalid quest id. Valid values id 0-3" );
        return;
    }

    for( uint n = 0; n < fr.KnownLocs.length();)
    {
        Location@ loc = GetLocation( fr.KnownLocs[ n ] );
        if( !valid( loc ) )
        {
            cr.Say( SAY_NETMSG, "Invalid loc found in faction KnownLocs. Deleting..." );
            fr.DeleteLocation( fr.KnownLocs[ n ] );
            continue;
        }
        if( loc.GetProtoId() == locPid )
        {
            cr.Say( SAY_NETMSG, "Found quest location. Deleting.." );
            DeleteLocation( loc.Id );
            fr.DeleteLocation( fr.KnownLocs[ n ] );
            break;
        }
        n++;
    }

    fr.Stats[ questId ] = 0;
    uint[] players = GetPlayersByFraction( fr.Id );
    for( uint n = 0, nMax = players.length(); n < nMax; n++ )
    {
        GameVar@ quest = GetLocalVar( questVar, players[ n ] );
        quest = 0;
    }
    cr.Say( SAY_NETMSG, "Clearing faction quest successfull!" );
}

void DeleteEncounters( Critter& cr, int, int, int )
{
    uint counter = 0;
    for( uint n = 50; n < 198; n++ )
    {
        Location@[] locs;
        GetAllLocations( n, locs );
        for( uint i = 0; i < locs.length; i++ )
        {
            Map@ map;
            if( locs[ i ].GetMapCount() > 1 )
                @map = locs[ i ].GetMapByIndex( 1 );
            if( valid( map ) && map.GetData( 55 ) == 0 )
            {
                counter++;
                DeleteLocation( locs[ i ].Id );
            }
        }
    }
    cr.Say( SAY_NETMSG, "Удалено " + counter + " локаций" );
}

void showcontainer( Critter& cr, int id, int, int )
{
    Item@ it = GetItem( id );
    if( it is null || it.GetType() != ITEM_TYPE_CONTAINER )
    {
        cr.Say( SAY_NETMSG, "Container not found" );
        return;
    }
    Item@[] items;
    it.GetItems( uint( -1 ), items );
    for( uint n = 0, nMax = items.length(); n < nMax; n++ )
        cr.Say( SAY_NETMSG, "Item #" + ( n + 1 ) + ", PID=" + items[ n ].GetProtoId() + ", id=" + items[ n ].Id + "\n" );
}

void itsmine( Critter& cr, int id, int, int )
{
    Item@ it = GetItem( id );
    if( valid( it ) )
    {
        MoveItem( it, it.GetCount(), cr );
    }
}

void itemid( Critter& cr, int pid, int, int )
{
    Map@ map = cr.GetMap();
    if( map is null )
        return;
    Item@[] items;
    map.GetItems( pid, items );
    for( uint n = 0, nMax = items.length(); n < nMax; n++ )
        map.SetText( items[ n ].HexX, items[ n ].HexY, COLOR_WHITE, "" + items[ n ].Id + " (" + items[ n ].GetProtoId() + ")" );
}

void CheckAttackHex( Critter& npc, int iEnd, int angleStart, int add )
{
    float            angle = -360.0f;
    Map@             map = npc.GetMap();
    uint16           baseHx = npc.HexX;
    uint16           baseHy = npc.HexY;

    uint16           bestX = 0, bestY = 0, bestLen = 0;

    uint8            mode = 0;
    const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode );
    if( !valid( weapon ) )
        return;
    int use = _WeaponModeUse( mode );
    int wpnDist = _WeaponMaxDist( weapon, use );

    if( wpnDist > 1 )
        for( uint dir = 0; dir < 6; dir++ )
        {
            for( uint i = 0; i < 36; i++ ) // если мы зажаты, и оружие атакует дальше 1 гекса пробуем отойти на дальность выстрела
            {
                uint16 baseHx = npc.HexX;
                uint16 baseHy = npc.HexY;
                map.MoveHexByDir( baseHx, baseHy, dir, wpnDist );
                uint16 hx = baseHx, hy = baseHy;
                npc.GetMap().GetHexCoord( npc.HexX, npc.HexY, hx, hy, angle, wpnDist );
                uint   idist = npc.GetMap().GetPathLength( npc, hx, hy, 0 );
                if( hx != 0 && hy != 0 && idist > 0 && ( idist < bestLen || bestLen == 0 ) )
                {
                    bestX = hx;
                    bestY = hy;
                    bestLen = idist;

                    map.SetText( bestX, bestY, COLOR_WHITE, "Прострел" );
                }
                angle += 20.0f;
            }
        }
    if( bestLen != 0 )
    {
        map.SetText( bestX, bestY, 0, "Прострел" );
    }
}

void GroupItems( Critter& cr, int pid, int, int )
{
    Map@ map = cr.GetMap();
    Item@[] items;
    map.GetItems( pid, items );
    cr.Say( SAY_NETMSG, "Количество найденных предметов: " + items.length() );
    for( uint n = 0, nMax = items.length(); n < nMax; n++ )
    {
        bool update = false;
        for( uint m = ( n + 1 ); m < nMax;)
        {
            if( items[ n ].GetProtoId() == items[ m ].GetProtoId() )
            {
                update = true;
                items[ n ].SetCount( items[ n ].GetCount() + items[ m ].GetCount() );
                DeleteItem( items[ m ] );
                items.removeAt( m );
                nMax--;
                continue;
            }
            m++;
        }
        if( update )
            items[ n ].Update();
    }
    cr.Say( SAY_NETMSG, "После группировки: " + items.length() );
}

void ToMapId( Critter& cr, int id, int entire, int )
{
    Map@ map = GetMap( id );
    if( !valid( map ) )
    {
        cr.Say( SAY_NETMSG, "Map not found!" );
        return;
    }
    cr.TransitToMap( id, entire );
}

void SetItemFlags( Critter& cr, int pid, int flag, int set )
{
    Item@[] items;
    uint count = GetAllItems( pid, items );
    for( uint n = 0; n < count; n++ )
    {
        if( set == 1 )
            SETFLAG( items[ n ].Flags, flag );
        else
            UNSETFLAG( items[ n ].Flags, flag );
    }
    cr.Say( SAY_NETMSG, "Изменен флаг для " + count + " предметов." );
}

void DeleteItems( Critter& cr, int pid, int, int )
{
    Item@[] items;
    uint count = GetAllItems( pid, items );
    for( uint n = 0; n < count; n++ )
    {
        DeleteItem( items[ n ] );
    }
    cr.Say( SAY_NETMSG, "Удалено " + count + " предметов." );
}

void FindItems( Critter& cr, int pid, int, int )
{
    Item@[] items;
    uint count = GetAllItems( pid, items );
    cr.Say( SAY_NETMSG, "Всего найдено: " + count + " предметов." );
    uint[][] mapCount;
    uint counter = 0;
    for( uint n = 0; n < count; n++ )
    {
        if( items[ n ].Accessory == ACCESSORY_CRITTER )
        {
            Critter@ player = GetCritter( items[ n ].CritId );
            if( valid( player ) )
            {
                cr.Say( SAY_NETMSG, "Предмет " + ( ++counter ) + ": В инвентаре у " + player.Name + " (" + items[ n ].GetCount() + ")" );
            }
            else
            {
                string@ name = GetPlayerName( items[ n ].CritId );
                if( valid( name ) )
                    cr.Say( SAY_NETMSG, "Предмет " + ( ++counter ) + ": В инвентаре у " + name + "(оффлайн) (" + items[ n ].GetCount() + ")" );
                else
                    cr.Say( SAY_NETMSG, "Х3!" );
            }
            continue;
        }
        uint16 hexX = 0,
               hexY = 0;
        Map@   map = items[ n ].GetMapPosition( hexX, hexY );
        if( valid( map ) )
        {
            int index = -1;
            for( uint i = 0; i < mapCount.length(); i++ )
                if( mapCount[ i ][ 0 ] == map.Id )
                {
                    index = i;
                    break;
                }
            if( index == -1 )
            {
                uint[] data = { map.Id, items[ n ].GetCount() };
                mapCount.insertLast( data );
            }
            else
                mapCount[ index ][ 1 ] += items[ n ].GetCount();
        }
    }
    for( uint m = 0; m < mapCount.length(); m++ )
    {
        cr.Say( SAY_NETMSG, "Предмет " + ( ++counter ) + ": на карте с ID " + mapCount[ m ][ 0 ] + " (" + mapCount[ m ][ 1 ] + " шт.)" );
    }
}

void DrapOrgRatings( Critter& cr, int, int, int )
{
    DrapRatingsAll();
}

void TestArray( Critter& cr, int, int, int )
{
    Critter@[] arr;
    arr.resize( 10 );
    for( uint n = 0; n < arr.length(); n++ )
        cr.Say( SAY_NETMSG, valid( arr[ n ] ) ? "Handle " + n + " is valid! \n" : "Handle " + n + " is NULL!" );
}

void toKO( Critter& cr, int id, int lostAp, int )
{
    if( id == 0 )
        cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), lostAp, cr.HexX, cr.HexY );
    else
    {
        Critter@ c = GetCritter( id );
        c.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), lostAp, c.HexX, c.HexY );
    }
}

void SetOrgStat( Critter& cr, int id, int val, int )
{
    Fraction@ fr = GetFraction( cr.Param[ ST_FACTION ] );
    if( valid( fr ) )
    {
        fr.Stats[ id ] = val;
    }
    else
        cr.Say( SAY_NETMSG, "Faction not found!" );
}

void SetLocFac( Critter& cr, int id, int, int )
{
    Location@ loc = cr.GetMap().GetLocation();
    loc.FractionId = id;
}

void GetLocFac( Critter& cr, int id, int, int )
{
    Location@ loc = cr.GetMap().GetLocation();
    cr.Say( SAY_NETMSG, "Location faction id=" + loc.FractionId );
}

void GetOrgStats( Critter& cr, int, int, int )
{
    Fraction@ fr = GetFraction( cr.Param[ ST_FACTION ] );
    if( !valid( fraction ) )
    {
        cr.Say( SAY_NETMSG, "ФРАКЦИЯ НЕ НАЙДЕНА!" );
        return;
    }
    for( uint n = 0; n < fr.Stats.length(); n++ )
    {
        cr.Say( SAY_NETMSG, "Stat " + n + "=" + fr.Stats[ n ] );
    }
}

void ShutFields( Critter& cr, int, int, int )
{
    r_HalfOn( cr, null );
}

void ShowCritterScripts( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] crits;
        map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, crits );
        if( crits.length() == 0 )
            cr.Say( SAY_NETMSG, "Critters not found!" );
        for( uint n = 0; n < crits.length(); n++ )
        {
            uint id = crits[ n ].GetScriptId();
            if( id > 0 )
                map.SetText( crits[ n ].HexX, crits[ n ].HexY, COLOR_WHITE, GetScriptName( id ) + " [" + id + "]" );
        }
    }
}

// ~run debug ShowCityParams 0 0 0
void ShowCityParams( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] crits;
        map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, crits );
        if( crits.length() == 0 )
            cr.Say( SAY_NETMSG, "Critters not found!" );
        for( uint n = 0; n < crits.length(); n++ )
        {
            // uint id=crits[n].GetScriptId();
            string txt = "IsPatrol " + crits[ n ].CityRole_IsPatrol;
            txt += " IsGuard " + crits[ n ].CityRole_IsGuard;
            txt += " IsProtected " + crits[ n ].CityRole_IsProtected;
            txt += " IsNotHelper " + crits[ n ].CityRole_IsNotHelper;
            map.SetText( crits[ n ].HexX, crits[ n ].HexY, COLOR_WHITE, txt );
            // if(id>0) map.SetText(crits[n].HexX, crits[n].HexY, COLOR_WHITE, GetScriptName(id)+" ["+id+"]");
        }
    }
}

void ShowItemScripts( Critter& cr, int itemType, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Item@[] items;
        map.GetItemsByType( itemType, items );
        for( uint n = 0; n < items.length(); n++ )
        {
            uint id = items[ n ].GetScriptId();
            if( id > 0 )
                map.SetText( items[ n ].HexX, items[ n ].HexY, COLOR_WHITE, GetScriptName( id ) + " [" + id + "]" );
        }
    }
}

void SetBonus( Critter& cr, int id, int, int )
{
    Item@[] weapon;
    cr.GetItems( SLOT_HAND1, weapon );
    if( weapon.length > 0 && valid( weapon[ 0 ] ) )
    {
        weapon[ 0 ].WeaponBonus_AP = weapon[ 0 ].WeaponBonus_AP + 1;
        weapon[ 0 ].Update();
    }
}

void GetOffParam( Critter& cr, int id, int param, int )
{
    OffClient@ cl = GetOffClient( id );
    if( param >= 0 && param <= 999 )
        cr.Say( SAY_NETMSG, "Param#" + param + "=" + cl.GetParam( param ) );
}

void GetOffData( Critter& cr, int id, int, int )
{
    OffClient@ cl = GetOffClient( id );
    cr.Say( SAY_NETMSG, "Map ID is:" + cl.GetMapId() );
    for( uint n = 200; n < 218; n++ )
    {
        cr.Say( SAY_NETMSG, "Param#" + n + "=" + cl.GetParam( n ) );
    }

}

void IfKnownLoc( Critter& cr, int id, int locId, int )
{
    OffClient@ cl = GetOffClient( uint( id ) );
    cr.Say( SAY_NETMSG, "IsKnownLoc=" + cl.IsKnownLoc( locId ) );
}

void SetOffKnownLoc( Critter& cr, int id, int locid, int )
{
    OffClient@ cl = GetOffClient( uint( id ) );
    if( !valid( cl ) )
        cr.Say( SAY_NETMSG, "Клиент не найден" );
    else
        cl.SetKnownLoc( uint( locid ) );
}

void UnsetOffKnownLoc( Critter& cr, int id, int locid, int )
{
    OffClient@ cl = GetOffClient( uint( id ) );
    if( !valid( cl ) )
        cr.Say( SAY_NETMSG, "Клиент не найден" );
    else
        cl.UnsetKnownLoc( uint( locid ) );
}

void OffToGlobal( Critter& cr, int id, int locid, int )
{
    OffClient@ cl = GetOffClient( uint( id ) );
    if( !valid( cl ) )
        cr.Say( SAY_NETMSG, "Клиент не найден" );
    else
        cl.ToGlobal();
}

void OffTransit( Critter& cr, int id, int hexX, int hexY )
{
    OffClient@ cl = GetOffClient( uint( id ) );
    if( !valid( cl ) )
        cr.Say( SAY_NETMSG, "Клиент не найден" );
    else
        cl.TransitToMap( cr.GetMap(), hexX, hexY );
}

// ~run debug cave_mobs 0 0 0
void cave_mobs( Critter& cr, int, int, int )
{
    cr.SetScript( "cave_mobs@_CaveNpcInit" );
}



// ~run debug locName 0 0 0
void locName( Critter& cr, int, int, int )
{
    string@ lexems = "$pid @msg gm " + ( cr.GetMap().GetLocation().GetProtoId() * 1000 + 100000 ) + "@";
    SayToAllPlayers( TEXTMSG_TEXT, 100101, @lexems );

    lexems = "$pid" + "*basename" + cr.GetMap().GetLocation().GetProtoId() + "*";
    SayToAllPlayers( TEXTMSG_TEXT, 100101, @lexems );

}
// ~run debug getPlasmaDtInArmor 0 0 0
void getPlasmaDtInArmor( Critter& cr, int, int, int )
{
    Item@ armor = _CritGetItemArmor( cr );
    if( valid( armor ) )
    {
        Log( "ProtoDt=" + armor.Proto.Armor_DTPlasma );
    }
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Trinitro
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define FIND_DIST    ( 16 )

void BreakItem( Critter& cr, int percent, int tobreak, int notresc )
{
    Item@[] items;
    cr.GetItems( SLOT_HAND1, items );
    if( valid( items[ 0 ] ) )
    {
        items[ 0 ].Deterioration = percent;
        if( notresc == 1 )
            SETFLAG( items[ 0 ].BrokenFlags, BI_NOTRESC );
        else if( notresc == 2 )
            SETFLAG( items[ 0 ].BrokenFlags, BI_ETERNAL );
        if( tobreak > 0 )
            SETFLAG( items[ 0 ].BrokenFlags, BI_BROKEN );
        items[ 0 ].Update();
    }
}

void GetGroup( Critter& cr, int param0, int param1, int param2 )
{
    Critter@[] crits;
    cr.GetFollowGroup( FIND_ALL, crits );
    for( uint n = 0, nMax = crits.length(); n < nMax; n++ )
    {
        cr.Say( SAY_NETMSG, "Член #" + ( n + 1 ) + ": " + crits[ n ].Id );
    }
}

void GetGrid( Critter& cr, int param0, int param1, int param2 )
{
    uint16 x = 0;
    uint16 y = 0;
    uint16 MapPid = 0;
    uint   EntireId = 0;
    cr.GetMap().GetExitGrid( cr, x, y, MapPid, EntireId );
    cr.Say( SAY_NETMSG, "X=" + x + "\n Y=" + y + "\n MapPid=" + MapPid + "\n EntireId=" + EntireId );
    cr.GetMap().SetText( x, y, COLOR_RED, "ТУТ!" );
}

void GetGridGlobal( Critter& cr, int param0, int param1, int param2 )
{
    uint16 x = 0;
    uint16 y = 0;
    cr.GetMap().GetExitGlobalGrid( cr, x, y );
    cr.Say( SAY_NETMSG, "X=" + x + "\n Y=" + y );
    cr.GetMap().SetText( x, y, COLOR_RED, "ТУТ!" );
}

void AddMerc( Critter& cr, int param0, int param1, int param2 )
{
    uint16 XSpawn = cr.HexX + 2;
    uint16 YSpawn = cr.HexY + 2;
    Map @ map = cr.GetMap();
    if( !valid( map ) )
        return;
    Critter@ npc;
    @npc = map.AddNpc( param2, XSpawn, YSpawn, 5, null, null, null );
    npc.MercBase[ MERC_MASTER_DIST ] = 6;
    Merc2Player( cr, npc, 4 );   // Охранник по умолчанию. Защищает хозяина
}

void DeleteFile( Critter& cr, int param0, int param1, int param2 )
{
    cr.ShowScreen( SCREEN_SAY, 0, "delete_file" );
    cr.Say( SAY_SAY_TITLE, "Введите имя файла" );
}


void Track( Critter& player,  int id, int param1, int param2 )
{
    SetTracker( player, id );
}

void BSW( Critter& player,  int param0, int param1, int param2 )
{
    uint8 x = 0;
    uint8 y = 0;
    while( x != 28 )
    {
        while( y != 30 )
        {
            player.SetFog( x, y, FOG_NONE );
            y++;
        }
        y = 0;
        x++;
    }
}

void ViewPlanes( Critter& player, int param0, int param1, int param2 )
{
    if( param0 == 0 )
        param0 = 20;

    Map@ map = player.GetMap();
    if( not valid( map ) )
        return;

    Critter@[] critters;
    uint count = 0;
    if( param1 == 0 )
        count = map.GetCrittersHex( player.HexX, player.HexY, param0, FIND_ALL | FIND_ONLY_NPC, critters );
    else
    {
        Critter@ cr = GetCritter( param1 );
        if( not valid( cr ) )
            return;
        critters.resize( 1 );
        count = 1;
        @critters[ 0 ] = cr;
    }

    for( uint i = 0; i < count; i++ )
    {
        NpcPlane@[] p;
        uint pcount = critters[ i ].GetPlanes( p );
        for( uint j = 0; j < pcount; j++ )
        {
            uint[] param = { critters[ i ].Id, p[ j ].Type, p[ j ].Priority };
            switch( p[ j ].Type )
            {
            case AI_PLANE_MISC:
                param.resize( 5 );
                param[ 3 ] = p[ j ].Misc_WaitSecond;
                param[ 4 ] = p[ j ].Misc_ScriptId;
                break;
            case AI_PLANE_ATTACK:
                param.resize( 5 );
                param[ 3 ] = p[ j ].Attack_TargId;
                param[ 4 ] = p[ j ].Attack_MinHp;
                break;
            case AI_PLANE_WALK:
                param.resize( 8 );
                param[ 3 ] = p[ j ].Walk_HexX;
                param[ 4 ] = p[ j ].Walk_HexY;
                param[ 5 ] = p[ j ].Walk_Dir;
                if( p[ j ].Run )
                    param[ 6 ] = 1;
                else
                    param[ 6 ] = 0;
                param[ 7 ] = p[ j ].Walk_Cut;
                break;
            case AI_PLANE_PICK:
                param.resize( 6 );
                param[ 3 ] = p[ j ].Pick_HexX;
                param[ 4 ] = p[ j ].Pick_HexY;
                param[ 5 ] = p[ j ].Pick_Pid;
                break;
            }
            CreateTimeEvent( __FullSecond + 1 + j, "e_ViewPlanes", param, false );
        }
    }
}

uint e_ViewPlanes( uint[] @ values )
{
    Critter@ crit = GetCritter( values[ 0 ] );
    if( not valid( crit ) )
        return 0;

    string msg = "error";
    switch( values[ 1 ] )
    {
    case AI_PLANE_MISC:
        msg = "<<MISC>> Prior=" + values[ 2 ];
        msg += " WaitMinute=" + values[ 3 ] + " ScriptId=" + values[ 4 ];
        break;
    case AI_PLANE_ATTACK:
        msg = "<<ATTACK>> Prior=" + values[ 2 ];
        msg += " TargId=" + values[ 3 ] + " MinHp=" + values[ 4 ];
        break;
    case AI_PLANE_WALK:
        msg = "<<WALK>> Prior=" + values[ 2 ];
        msg += " HexX=" + values[ 3 ] + " HexY=" + values[ 4 ] + " Dir=" + values[ 5 ];
        msg += " Run=" + values[ 6 ] + " Cut=" + values[ 7 ];
        break;
    case AI_PLANE_PICK:
        msg = "<<PICK>> Prior=" + values[ 2 ];
        msg += " HexX=" + values[ 3 ] + " HexY=" + values[ 4 ] + " Pid=" + values[ 5 ];
        break;
    }

    crit.Say( SAY_NORM, msg );
    return 0;
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// heX
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";

#define def    # ( X, DEF )( X == 0 ? DEF : X )

void lvl( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_LEVEL ] ) );
}

void team( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_TEAM_ID ] ) );
}

void role( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_NPC_ROLE ] ) );
}

void info( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ param0 ] ) );
}

void hp( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_CURRENT_HP ] ) + "/" + "" + ( critters[ i ].Stat[ ST_MAX_LIFE ] ) );
}

// plan count
void planc( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].GetPlanes( null ) ) );
}

// show plans list
void plans( Critter& player, int param0, int param1, int param2 )
{
    NpcPlane@[] planes;
    string str;
    Critter@[] critters;
    uint   count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
    {
        str = "";
        uint count = critters[ i ].GetPlanes( planes );
        for( uint j = 0; j < count; j++ )
        {
            switch( planes[ j ].Type )
            {
            case AI_PLANE_MISC:
                str = str + "M ";
                break;
            case AI_PLANE_ATTACK:
                str = str + "A ";
                break;
            case AI_PLANE_WALK:
                str = str + "W ";
                break;
            case AI_PLANE_PICK:
                str = str + "P ";
                break;
            case AI_PLANE_PATROL:
                str = str + "P ";
                break;
            case AI_PLANE_COURIER:
                str = str + "C ";
                break;
            }
        }
        critters[ i ].Say( SAY_NORM_ON_HEAD, str );
    }
}

// player level info
void lvli( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST * 2, FIND_LIFE | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0; i < count; i++ )
        player.Say( SAY_NETMSG, GetPlayerName( critters[ i ].Id ) + ": " + "" + ( critters[ i ].Stat[ ST_LEVEL ] ) );
}

void dmg( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;
    InjureCritter( target, param1, param2, 0, player.Id );
}

void kill( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
		@target = player;
    target.Say( SAY_NETMSG, "Кара небесная поразила вас!" );
    target.ToDead( def( param1, ANIM2_DEAD_PULSE_DUST ), player );
    target.TimeoutBase[TO_REPLICATION] = param2;
}

void body( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    target.ChangeCrType( param1 );
    target.StatBase[ ST_BASE_CRTYPE ] = param1;
}

void anim( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    target.Animate( param1, param2, null, true, true );
}

void SetAnim( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    target.SetAnims( 0, param1, param2 );      // Animate(param1, param2, null, true, true);
}

void testmap( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] groups;
    groups.insertLast( @player );
    uint      locid = CreateLocation(
        def( param1, 400 ), player.WorldX, player.WorldY, groups );
    Location@ loc = GetLocation( locid );
    // if(not valid(loc)) GetMapByPid(mapProtoId, skipCount);
    if( not valid( loc ) )
    {
        player.Say( SAY_NETMSG, "Location not found" );
        return;
    }
    Map@ map;
    if( param0 != 0 )
        @map = loc.GetMap( param0 );
    else
        @map = loc.GetMapByIndex( 0 );
    if( not valid( map ) )
        return;
    player.TransitToMap( map.Id, 0 );
}

// ~run debug ctm 0 0 0
void ctm( Critter& player, int param0, int param1, int param2 )
{
    Location@ loc = GetLocation( param0 );
    if( not valid( loc ) )
    {
        player.Say( SAY_NETMSG, "Location not found" );
        return;
    }
    Map@ map;
    if( param1 != 0 )
        @map = loc.GetMap( param1 );
    else
        @map = loc.GetMapByIndex( 0 );
    if( not valid( map ) )
        return;
    player.TransitToMap( map.Id, 0 );
}

// ~run debug getMapStat 0 0 0
void getMapStat( Critter& player, int param0, int param1, int param2 )
{
    Location@ loc = GetLocation( param0 );
    if( not valid( loc ) )
    {
        Log( "Location not found" );
        return;
    }

    Map@ map;
    if( param1 != 0 )
        @map = loc.GetMap( param1 );
    else
        @map = loc.GetMapByIndex( 0 );
    if( not valid( map ) )
    {
        Log( "Map not found" );
        return;
    }

    Critter@[] groups;
    uint countCrittersInMap = map.GetCritters( 0, FIND_ALL, groups );
    Log( "Count critters in map = " + countCrittersInMap );
    Item@[] containers;
    uint countContainerInMaps = map.GetItemsByType( ITEM_TYPE_CONTAINER, containers );
    Log( "Count containers in map = " + countContainerInMaps );
    Log( "_______________________________" );
    for( uint i = 0, iMax = containers.length(); i < iMax; i++ )
    {
        Log( "Id_" + i + " = " + containers[ i ].Id );
    }
    Log( "_______________________________" );
}

// ~run debug gitp 0 0 0
void gitp( Critter& player, int param0, int param1, int param2 )
{
    Location@ loc = GetLocation( param0 );
    if( not valid( loc ) )
    {
        Log( "Location not found" );
        return;
    }

    Map@ map;
    if( param1 != 0 )
        @map = loc.GetMap( param1 );
    else
        @map = loc.GetMapByIndex( 0 );
    if( not valid( map ) )
    {
        Log( "Map not found" );
        return;
    }

    Item@ item = map.GetItem( param2 );
    if( not valid( item ) )
    {
        Log( "Item not valid" );
        return;
    }

    MoveItem( item, 1, player );
}


// Come To Daddy
void ctd( Critter& player, int param0, int toDaddy, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;
    if( toDaddy == 0 )
    {
        Map@ map = player.GetMap();
        Map@ tMap = player.GetMap();
        if( not valid( map ) )
            return;
        if( not map.IsHexPassed( player.HexX + 1, player.HexY ) )
            return;
        if( param2 != 0 && valid( tMap ) )
            tMap.RunEffect( PID_EXPLODE_PLASMA, target.HexX, target.HexY, 0, EFFECT_INSTRUCTION_NONE );
        target.TransitToMap( map.Id, player.HexX + 1, player.HexY, 0 );
        if( param2 != 0 )
            map.RunEffect( PID_EXPLODE_PLASMA, player.HexX + 1, player.HexY, 0, EFFECT_INSTRUCTION_NONE );
    }
    else
    {
        Map@ map = target.GetMap();
        Map@ plMap = player.GetMap();
        if( not valid( map ) )
            return;
        if( map.IsHexPassed( target.HexX + 1, target.HexY ) )
        {
            if( param2 != 0 && valid( plMap ) )
                plMap.RunEffect( PID_EXPLODE_PLASMA, player.HexX, player.HexY, 0, EFFECT_INSTRUCTION_NONE );
            player.TransitToMap( map.Id, target.HexX + 1, target.HexY, 0 );
            if( param2 != 0 )
                map.RunEffect( PID_EXPLODE_PLASMA, target.HexX + 1, target.HexY, 0, EFFECT_INSTRUCTION_NONE );
        }
        else if( map.IsHexPassed( target.HexX, target.HexY + 1 ) )
        {
            if( param2 != 0 && valid( plMap ) )
                plMap.RunEffect( PID_EXPLODE_PLASMA, player.HexX, player.HexY, 0, EFFECT_INSTRUCTION_NONE );
            player.TransitToMap( map.Id, target.HexX, target.HexY + 1, 0 );
            if( param2 != 0 )
                map.RunEffect( PID_EXPLODE_PLASMA, target.HexX, target.HexY + 1, 0, EFFECT_INSTRUCTION_NONE );
        }
        else if( map.IsHexPassed( target.HexX + 1, target.HexY + 1 ) )
        {
            if( param2 != 0 && valid( plMap ) )
                plMap.RunEffect( PID_EXPLODE_PLASMA, player.HexX, player.HexY, 0, EFFECT_INSTRUCTION_NONE );
            player.TransitToMap( map.Id, target.HexX + 1, target.HexY + 1, 0 );
            if( param2 != 0 )
                map.RunEffect( PID_EXPLODE_PLASMA, target.HexX + 1, target.HexY + 1, 0, EFFECT_INSTRUCTION_NONE );
        }
    }
}

void god( Critter& player, int, int, int )
{
    for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
        player.StatBase[ i ] = 15;
    for( uint i = ST_NORMAL_ABSORB; i <= ST_EXPLODE_ABSORB; i++ )
        player.StatBase[ i ] = 100;
    for( uint i = ST_NORMAL_RESIST; i <= ST_POISON_RESISTANCE; i++ )
        player.StatBase[ i ] = 100;
    for( uint i = SK_SMALL_GUNS; i <= SK_OUTDOORSMAN; i++ )
        player.SkillBase[ i ] = 300;
    player.StatBase[ ST_MELEE_DAMAGE ] = 999;
    player.StatBase[ ST_CURRENT_HP ] = 9999;
    player.StatBase[ ST_MAX_LIFE ] = 9999;
    player.StatBase[ ST_ACTION_POINTS ] = 9999;
    player.StatBase[ ST_LEVEL ] = 30;
    player.StatBase[ PE_SNAKEATER ] = 1;
}

void mapid( Critter& player, int, int, int )
{
    Map@ map = player.GetMap();
    player.Say( SAY_NETMSG, "" + ( map.GetProtoId() ) );
}

void tele( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    Location @ loc = GetLocationByPid( def( param1, player.GetMap().Id ), 0 );
    if( not valid( loc ) )
    {
        player.Say( SAY_NETMSG, "Location not found" );
        return;
    }
    Map @ map = loc.GetMapByIndex( param2 );
    if( not valid( map ) )
    {
        player.Say( SAY_NETMSG, "Map index not found" );
        @map = loc.GetMapByIndex( 0 );
        if( not valid( map ) )
            return;
    }
    target.TransitToMap( map.Id, 0 );
}

void items( Critter& player, int param0, int param1, int param2 )
{
    Item@[] items;
    uint count = player.GetMap().GetItems( player.HexX, player.HexY, items );
    for( uint i = 0; i < count; i++ )
        player.Say( SAY_NETMSG, "" + items[ i ].GetProtoId() );
}

void id( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Id ) );
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ...
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ~run debug ToMapEntire 42 0 0
void ToMapEntire( Critter& player, int mapPid, int entire, int skip )
{
    Map@ map = ::GetMapByPid( mapPid, skip );
    if( valid( map ) )
    {
        player.TransitToMap( map.Id, entire );
    }
    else
    {
        player.Say( SAY_NETMSG, "Карта с pid=" + mapPid + " не найдена" );
    }
}

// ищет нпц по диалогу на карте указанного прототипа
void NpcByDialog( Critter& player, int mapPid, int dialog, int )
{
    Map@ map = ::GetMapByPid( mapPid, 0 );
    if( valid( map ) )
    {
        Critter @[] npc;

        if( map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, npc ) == 0 )
        {

            player.Say( SAY_NETMSG, "не найдено нпц с таким диалогом" );

        }
        else
        {
            uint idF = 0;
            uint l = 0;
            for( uint i = 0, iMax = npc.length(); i < iMax; i++ )
            {
                if( npc[ i ].Stat[ ST_DIALOG_ID ] == dialog )
                {
                    l++;
                    idF = ( idF == 0 ? npc[ i ].Id : idF );
                }
            }
            player.Say( SAY_NETMSG, "Найдено нпц, в штуках:" + l + " Id первого:" + idF );
        }
    }

}

void SetReputation( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.ReputationBase[ num ] = val;
}

void Siren( Critter& cr, int, int, int )
{
    Map @ map = cr.GetMap();
    if( !valid( map ) )
    {
        cr.Say( SAY_NETMSG, "Невозможно проиграть звук на глобальной карте" );
        return;
    }
    map.PlaySound( "AIRSIREN.OGG" );
}

void Mirelurk( Critter& cr, int, int, int )
{
    cr.GetMap().AddNpc( 487, cr.HexX - 3, cr.HexY - 3, 0, null, null, null );
}

/*
   ~run debug ToMapEntire 137 0 0
   ~run debug Siren 0 0 0
   ~run debug Mirelurk 0 0 0
   ~loadscript debug
   ~run debug SetMode 1 527 1
   ~run test SetStat

 */
void SetMode( Critter& cr, int id, int mode, int value )
{
    Critter @ crit = GetCritter( id );
    crit.ModeBase[ mode ] = value;
}
import void AddWave( int waveNum, int mapId, int type ) from "mob_wave";
import void AddSpawnStep( int waveNum, uint8 radius, uint timeNext, uint x, uint y ) from "mob_wave";
import void AddMob( int waveNum, int pid, int team ) from "mob_wave";
import void AddMoveStep( int waveNum, uint8 radius, uint timeNext, uint x, uint y ) from "mob_wave";
import void AddAttackStep( int waveNum, uint8 radius, uint timeNext, uint timeRepeat, uint x, uint y ) from "mob_wave";
import void AddDeleteStep( int waveNum, uint8 radius, uint timeNext ) from "mob_wave";
import void _StartWave( int waveNum ) from "mob_wave";
import void AddTransitStep( int waveNum, uint8 radius, uint timeNext, uint x, uint y, uint mapId ) from "mob_wave";


void NewWave( Critter& cr, int num, int type, int )
{
    AddWave( num, cr.GetMap().Id, type );
}

void AddStepSpawn( Critter& cr, int num, int radius, int timeNext )
{
    AddSpawnStep( num, radius, timeNext, cr.HexX, cr.HexY );
}

void AddStepMove( Critter& cr, int num, int radius, int timeNext )
{
    AddMoveStep( num, radius, timeNext, cr.HexX, cr.HexY );
}

void AddStepAttack( Critter& cr, int num, int radius, int timeNext )
{
    AddAttackStep( num, radius, timeNext, 10, cr.HexX, cr.HexY );
}

void AddStepDelete( Critter& cr, int num, int radius, int timeNext )
{
    AddDeleteStep( num, radius, timeNext );
}

void AddMob( Critter& cr, int num, int pid, int team )
{
    AddMob( num, pid, team );
}

void AddStepTransit( Critter& cr, int num, int radius, int timeNext )
{
    AddTransitStep( num, radius, timeNext, cr.HexX, cr.HexY, cr.GetMap().Id );
}

void BeginWave( Critter& cr, int num, int, int )
{
    _StartWave( num );
}

/*
   ~run debug NewWave 1 3 0
   ~run debug AddStepSpawn 1 10 10
   ~run debug AddStepMove 1 10 10
   ~run debug AddStepAttack 1 10 10

   ~run debug AddMob 1 111 27~run debug AddStepDelete 1 10 10
   ~run debug BeginWave 1
 */

void NetId( Critter& player, int searchRadius, int, int )
{
    Critter @[] crits;
    player.GetMap().GetCrittersHex( player.HexX, player.HexY, searchRadius, FIND_ALL, crits );
    player.Say( SAY_NETMSG, "my info: HexX=" + player.HexX + "; HexY=" + player.HexY + "; SearchRadius=" + searchRadius );
    for( uint i = 0, iMax = crits.length(); i < iMax; i++ )
    {
        player.Say( SAY_NETMSG, "Critter Pid:" + crits[ i ].GetProtoId() + "; Dialog:" + crits[ i ].Stat[ ST_DIALOG_ID ] + "; Id:" + crits[ i ].Id );
    }
    player.Say( SAY_NETMSG, "Total: " + crits.length() );
}

void AddCritParam( Critter& cr, int id, int param, int val )
{
    Critter@ player = GetCritter( id );
    if( valid( player ) )
    {
        player.ParamBase[ param ] += val;
    }
    else
        cr.Say( SAY_NETMSG, "Player not found!!!" );
}

void SetCritParam( Critter& player, int id, int param, int value )
{
    Critter @ cr = GetCritter( ( id == 0 ? player.Id : id ) );
    if( valid( cr ) )
    {
        cr.ParamBase[ param ] = value;
    }
    else
        cr.Say( SAY_NETMSG, "Player not found!!!" );
}

void GetCritParam( Critter& player, int id, int param, int value )
{
    Critter @ cr = GetCritter( ( id == 0 ? player.Id : id ) );
    if( valid( cr ) )
    {
        player.Say( SAY_NETMSG, "Param #" + param + " val=" + cr.Param[ param ] );
        player.Say( SAY_NETMSG, "Param(base) #" + param + " val=" + cr.ParamBase[ param ] );
    }
    else
        cr.Say( SAY_NETMSG, "Player not found!!!" );
}

void ShowLocation( Critter& player, int, int, int )
{
    Map @ map = player.GetMap();
    if( valid( map ) )
    {
        Location @ loc = map.GetLocation();
        if( valid( loc ) && !loc.Visible )
            loc.Visible = true;
    }
}

void AddMine( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX + 1, cr.HexY + 1, PID_ACTIVE_MINE, 1 );
    item.SetScript( "_MineInit" );
}

void _MineInit( Item& item, bool firstTime )
{
    item.TrapValue = 150;
    SETFLAG( item.Flags, ITEM_TRAP );
    item.SetEvent( ITEM_EVENT_WALK, "explode@_MineWalk" );
    item.Update();
}

import void SkillUp( Critter& player, int skill ) from "stdlib";

void UpSkill( Critter& cr, int crId, int skill, int )
{
    SkillUp( GetCritter( uint( crId ) ), skill );
}

void CancelInvul( Critter& player, int, int, int )
{
    Map@ map = player.GetMap();
    if( valid( map ) )
    {
        Critter@[] critters;
        if( map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters ) > 0 )
        {
            for( uint i = 0, iMax = critters.length(); i < iMax; i++ )
            {
                Critter@ cr = critters[ i ];
                if( valid( cr ) )
                    cr.ModeBase[ MODE_INVULNERABLE ] = 0;
            }
        }
    }
    player.Say( SAY_NETMSG, "Success" );
}

void PatchBAX( Critter& cr, int, int, int )
{
    Map@[] maps;
    Item@[] items;
    GetAllMaps( MAP_bax_underground, maps );
    for( uint i = 0, l = maps.length(); i < l; i++ )
    {
        Map@ map = maps[ i ];
        if( valid( map ) )
            map.GetItems( PID_POWERED_ARMOR, items );
    }
    for( uint i = 0, l = items.length(); i < l; i++ )
    {
        Item@ item = items[ i ];
        if( valid( item ) )
            DeleteItem( item );
    }
}

import void RunGameEvent( uint idx ) from "game_event";
import void RunGameEvent( uint idx, uint time ) from "game_event";
import void StopGameEvent( uint idx ) from "game_event";

void RunGameEvent( Critter& cr, int idx, int, int )
{
    RunGameEvent( idx );
}

void RunGameEventTime( Critter& cr, int idx, int time, int )
{
    RunGameEvent( idx, uint( time ) );
}

void StopGameEvent( Critter& cr, int idx, int, int )
{
    StopGameEvent( idx );
}

void PatchBar( Critter& cr, int, int, int )
{
    Map@ map = GetMapByPid( MAP_newr1, 0 );
    if( valid( map ) )
    {
        int[] params = { ST_DIALOG_ID, 782, ST_TEAM_ID, 2, ST_BAG_ID, 96 };
        map.AddNpc( 499, 56, 29, 1, params, null, null );
    }
}

void ALot( Critter& cr, int crId, int itemId, int price )
{
    cr.RunClientScript( "client_lot_screen@ShowLotScreen", itemId, crId, price, null, null );
}

void ASell( Critter& cr, int, int, int )
{
    int[] itemIds;
    Item@[] items;
    cr.GetItems( -1, items );
    for( uint i = 0, l = items.length(); i < l; i++ )
    {
        if( items[ i ].GetProtoId() != PID_BOTTLE_CAPS && items[ i ].GetProtoId() != 41 )
        {
            itemIds.insertLast( items[ i ].Id );
            itemIds.insertLast( items[ i ].GetProtoId() );
            itemIds.insertLast( items[ i ].GetCount() );
        }

    }
    if( itemIds.length() > 0 )
        cr.RunClientScript( "client_auction_sell_screen@ShowSellScreen", 0, 0, 0, null, itemIds );
    else
        cr.RunClientScript( "client_auction_sell_screen@ShowSellScreen", 0, 0, 0, null, null );
    cr.Say( SAY_NETMSG, "done" + itemIds.length() );
}

void GetParam( Critter& cr, int val0, int, int )
{
    Log( "Param=" + cr.Param[ val0 ] );
}


// ~run debug damd 5000000 6000000 0
void damd( Critter& player, int param0, int param1, int param2 )
{
    for( int i = param0; i < param1; i++ )
        if( not valid( GetCritter( i ) ) )
            EraseAnyData( "mob_in_enc" + i );
}

void dtl( Critter& cr, int param0, int param1, int param2 )
{
    DelThisLoc( cr, param0, param1, param2 );
}

// ~run debug DelThisLoc 2 0 0
void DelThisLoc( Critter& cr, int param0, int param1, int param2 )
{
    Map@ map = cr.GetMap();
    if( not valid( map ) )
    {
        Log( "Карта не найдена" );
        return;
    }
    Location@ loc = map.GetLocation();
    if( not valid( loc ) )
    {
        Log( "Локация не найдена" );
        return;
    }

    loc.AutoGarbage = true;
    Log( "Установлено автоудаление для локации Id=" + loc.Id );

    if( param0 > 0 )
    {
        Item@[] items;
        for( uint i = ITEM_TYPE_ARMOR; i < ITEM_TYPE_KEY + 1; i++ )
            map.GetItemsByType( i, items );
        for( uint i = 0, iMax = items.length(); i < iMax; i++ )
            if( FLAG( items[ i ].Flags, ITEM_GECK ) )
            {
                UNSETFLAG( items[ i ].Flags, ITEM_GECK );
                Log( "Убран флаг ГЕКК для предмета PID=" + loc.Id );
            }
    }

    if( param0 > 1 )
    {
        Critter@[] critters;
        if( map.GetCritters( 0, FIND_ALL, critters ) > 0 )
            for( uint i = 0, iMax = critters.length(); i < iMax; i++ )
                if( critters[ i ].ModeBase[ MODE_GECK ] != 0 )
                {
                    critters[ i ].ModeBase[ MODE_GECK ] == 0;
                    Log( "Убран модификатор ГЕКК для криттера с Id=" + critters[ i ].Id );
                }
    }

    if( param0 > 2 )
        DeleteLocation( loc.Id );
}

void SetAutoGarbage( Critter& cr, int param0, int param1, int param2 )
{
    Location@ loc;
    if( param0 == 0 )
    {
        Map@ map = cr.GetMap();
        if( not valid( map ) )
        {
            Log( "Карта не найдена" );
            return;
        }
        @loc = map.GetLocation();
    }
    else
        @loc = GetLocation( param0 );

    if( not valid( loc ) )
    {
        Log( "Локация не найдена" );
        return;
    }

    loc.AutoGarbage = ( param1 == 1 ? true : false );

    if( param1 == 1 )
        Log( "Установлено автоудаление для локации Id=" + loc.Id );
    else
        Log( "Отменено автоудаление для локации Id=" + loc.Id );
}

// Статистика по перкам на сервере
// ~run debug perkStat 1 0 0
void perkStat( Critter& cr, int param0, int param1, int param2 )
{
    Log( "=====================================" );
    uint[] perkGlobalStat;
    GetAnyData( "perk_global_stat", perkGlobalStat );

    uint16 index = 0;
    if( param0 == 0 )
    {
        for( uint i = 0, iMax = perkGlobalStat.length() / 2; i < iMax; i++ )
        {
            Log( "| Перк " + perkGlobalStat[ index ] + ": " + perkGlobalStat[ index + 1 ] + " |" );
            index += 2;
        }
        return;
    }

    uint bufer = 0;
    uint[] perkConsts;
    uint[] perkCounts;

    perkConsts.resize( perkGlobalStat.length() / 2 );
    perkCounts.resize( perkGlobalStat.length() / 2 );

    for( uint i = 0, iMax = perkConsts.length(); i < iMax; i++ )
    {
        perkConsts[ i ] = perkGlobalStat[ i * 2 ];
        perkCounts[ i ] = perkGlobalStat[ ( i * 2 ) + 1 ];
    }

    for( uint j = 0; j < 2; j++ )
        for( uint i = 1, iMax = perkCounts.length(); i < iMax; i++ )
        {
            bufer = perkCounts[ i ];
            if( bufer > perkCounts[ i - 1 ] )
            {
                perkCounts[ i ] = perkCounts[ i - 1 ];
                perkCounts[ i - 1 ] = bufer;

                bufer = perkConsts[ i ];
                perkConsts[ i ] = perkConsts[ i - 1 ];
                perkConsts[ i - 1 ] = bufer;
                i = 1;
            }
        }

    for( uint i = 0, iMax = perkCounts.length(); i < iMax; i++ )
    {
        Log( "| Перк " + perkConsts[ i ] + ": " + perkCounts[ i ] + " |" );
    }
    Log( "=====================================" );
}

// Увидеть/развидеть все склады
void saw( Critter& cr, int unsee, int, int )
{
    Location@[] locs;
    for( uint n = LOCATION_hiding_pleace_1; n < LOCATION_hiding_pleace22; n++ )
    {
        GetAllLocations( n, locs );
        for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
            if( unsee == 0 && !cr.IsKnownLoc( true, locs[ j ].Id ) )
                cr.SetKnownLoc( true, locs[ j ].Id );
            else
                cr.UnsetKnownLoc( true, locs[ j ].Id );
    }
}

// Удалить из памяти все локации
void ual( Critter& cr, int, int, int )
{
    Location@[] locs;
    for( uint i = LOCATION_Den; i < LOCATION_NewbieLocation + 1; i++ )
    {
        GetAllLocations( i, locs );
        for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
            if( cr.IsKnownLoc( true, locs[ j ].Id ) )
                cr.UnsetKnownLoc( true, locs[ j ].Id );
    }
}

// Увидеть все локации на сервере
// ~run debug sal 0 0 0
void sal( Critter& cr, int, int, int )
{
    Location@[] locs;
    for( uint i = LOCATION_Den; i < LOCATION_NewbieLocation + 1; i++ )
    {
        GetAllLocations( i, locs );
        for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
            if( !cr.IsKnownLoc( true, locs[ j ].Id ) )
                cr.SetKnownLoc( true, locs[ j ].Id );
    }
}

void salCity( Critter& cr, int, int, int )
{
    Location@[] locs;
    for( uint i = LOCATION_Den; i < LOCATION_GeckCity + 1; i++ )
    {
        GetAllLocations( i, locs );
        for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
            if( !cr.IsKnownLoc( true, locs[ j ].Id ) )
                cr.SetKnownLoc( true, locs[ j ].Id );
    }
}

void salEnc( Critter& cr, int, int, int )
{
    Location@[] locs;
    for( uint i = LOCATION_DesertEncounter1; i < LOCATION_OceanTrader + 1; i++ )
    {
        GetAllLocations( i, locs );
        for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
            if( !cr.IsKnownLoc( true, locs[ j ].Id ) )
                cr.SetKnownLoc( true, locs[ j ].Id );
    }
}

void salThisEnc( Critter& cr, int locPid, int, int )
{
    Location@[] locs;
    GetAllLocations( locPid, locs );
    for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
        if( !cr.IsKnownLoc( true, locs[ j ].Id ) )
            cr.SetKnownLoc( true, locs[ j ].Id );
}

#define IS_CLERABLE_ENC        ( 56 )                           //
#define IS_HIDING_PLACE_ENC    ( 57 )                           //
void delMercLoc( Critter& cr, int, int, int )
{
    Location@[] locs;
    for( uint i = LOCATION_Den; i < LOCATION_OceanTrader + 1; i++ )
    {
        GetAllLocations( i, locs );
        for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
        {
            bool isDel = false;
            for( uint m = 0, mMax = locs[ j ].GetMapCount(); m < mMax; m++ )
            {
                if( locs[ j ].GetMapByIndex( m ).GetData( IS_CLERABLE_ENC ) != 0 || locs[ j ].GetMapByIndex( m ).GetData( IS_HIDING_PLACE_ENC ) != 0 )
                {
                    isDel = false;
                    break;
                }
                if( locs[ j ].GetMapByIndex( m ).GetCritters( 0, FIND_ONLY_PLAYERS, null ) > 0 )
                {
                    isDel = false;
                    break;
                }

                Critter@[] group;
                if( locs[ j ].GetMapByIndex( m ).GetCritters( 0, FIND_ONLY_NPC, group ) > 0 )
                    for( uint k = 0, kMax = group.length(); k < kMax; k++ )
                    {
                        Critter@ cr = group[ k ];
                        if( cr.Merc[ MERC_IS_SLAVE ] > 0 )
                            isDel = true;
                    }
            }

            if( isDel )
                DeleteLocation( locs[ j ].Id );
        }
    }
}

#define IS_CLERABLE_ENC        ( 56 )                           //
void delMercLoc2( Critter& cr, int locPid, int, int )
{
    Location@[] locs;
    GetAllLocations( locPid, locs );
    for( uint j = 0, jMax = locs.length(); j < jMax; j++ )
    {
        bool isDel = false;
        for( uint m = 0, mMax = locs[ j ].GetMapCount(); m < mMax; m++ )
        {
            if( locs[ j ].GetMapByIndex( m ).GetData( IS_CLERABLE_ENC ) != 0 || locs[ j ].GetMapByIndex( m ).GetData( IS_HIDING_PLACE_ENC ) != 0 )
            {
                isDel = false;
                break;
            }
            if( locs[ j ].GetMapByIndex( m ).GetCritters( 0, FIND_ONLY_PLAYERS, null ) > 0 )
            {
                isDel = false;
                break;
            }

            Critter@[] group;
            if( locs[ j ].GetMapByIndex( m ).GetCritters( 0, FIND_ONLY_NPC, group ) > 0 )
                for( uint k = 0, kMax = group.length(); k < kMax; k++ )
                {
                    Critter@ cr = group[ k ];
                    if( cr.Merc[ MERC_IS_SLAVE ] > 0 )
                        isDel = true;
                }
        }

        if( isDel )
            DeleteLocation( locs[ j ].Id );
    }
}

// Создать предмет и применить на него рандомизацию
// ~run debug rpi 0 0 0
void rpi( Critter& cr, int val0, int val1, int val2 )
{
    Item@ item = cr.AddItem( val0, 1 );
    InitRandomisationItem( item, true, cr, "" );
}

void ChengeLocalVar( Critter& cr, int id, int number, int value )
{
    Critter@ player = GetCritter( id );
    if( !valid( player ) )
        return;
    GameVar@ gv = GetLocalVar( number, player.Id );
    if( !valid( gv ) )
        return;
    gv = value;
}

// ~run debug ValueLocalVar 0 3042 0
void ValueLocalVar( Critter& cr, int id, int number, int )
{
    Critter@ player = GetCritter( id );
    if( !valid( player ) )
        return;
    GameVar@ gv = GetLocalVar( number, player.Id );
    if( !valid( gv ) )
        return;
    Log( "Val=" + gv.GetValue() );
}

void CritterMoveItem( Critter& admin, int crId, int itemid, int slot )
{
	Critter@ critter = GetCritter( crId != 0 ? crId : admin.Id );
	critter.MoveItem( itemid, 1, slot );
    GetItem(itemid).Update();
}
// ~getaccess admin hh
// ~run debug MarkCritter2 1 41 0
void MarkCritter2( Critter& cr, int crId, int pid, int color )
{
    Item@ item = cr.AddItem( pid, 1 );
    AllowSlot( 17, "noini" );
    cr.MoveItem( item.Id, 1, 17 );
    item.LightIntensity = Random( 30, 80 );
    item.LightColor = ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
    item.LightDistance = 5;
    SETFLAG( item.Flags, ITEM_LIGHT );
    item.Update();
}

void r_ChangeCrType( Critter& cr, Critter@ npc, int value )
{
    cr.ChangeCrType( value );
    cr.StatBase[ ST_BASE_CRTYPE ] = value;
}

void MarkCritter( Critter& cr, int crId, int pid, int color )
{

    Item@ item = cr.AddItem( pid, 1 );
    // AllowSlot(17,"");
    cr.MoveItem( item.Id, 1, 17 );
    item.LightIntensity = Random( 30, 80 );
    item.LightColor = ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
    item.LightDistance = 5;
    SETFLAG( item.Flags, ITEM_LIGHT );
    SETFLAG( item.Flags, ITEM_HIDDEN );
    item.Update();
}

// ~run debug AddNpc 32 10121 0
void AddNpc( Critter& cr, int pid, int dialog, int )
{
    if( pid <= 0 || dialog <= 0 )
        return;
    cr.GetMap().AddNpc( pid, cr.HexX - 3, cr.HexY - 2, 0, null, null, null ).StatBase[ ST_DIALOG_ID ] = dialog;
}

void AddTG( Critter& cr, int param0, int param1, int param2 )
{
    #define TEAM_Bandit    ( 8 )
    #define BAG_Sniper1    ( 270 )
    #define BAG_Term1      ( 276 )

    Map @ map = cr.GetMap();
    if( !valid( map ) )
        return;
    int bag = BAG_Sniper1;
    int[] params = { ST_TEAM_ID, TEAM_Bandit, ST_NPC_ROLE, 17, ST_BAG_ID, ( ( Random( 1, 3 ) > 2 ) ? BAG_Sniper1 : BAG_Term1 ) };
    for( int i = 0, j = 0, dy = 0; i < param0; i++ )
    {
        map.AddNpc( 222, cr.HexX + j, cr.HexY + dy, Random( 0, 5 ), params, null, "Mk2@EncounterNpc::_NpcInit" );
        j++;
        if( j == param1 )
        {
            dy += param2;
            j = 0;
        }
    }
    Critter@[] npcs;
    uint count = map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, npcs );
    Log( "Count=" + count );
}

import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";
import uint ProcessSubQuest1( Critter& player, int newVal ) from "quest_warehouse";

void QWHS1( Critter& player, int val, int, int )
{
    ProcessSubQuest1( player, val );
}

void patchSalv( Critter& cr, int, int, int )
{
    Map@ map = GetMapByPid( MAP_newr3, 0 );
    if( valid( map ) )
    {
        Critter@npc = map.AddNpc( 212, 63, 71, 2, null, null, "trader@_CashTraderInit" );
    }
}

void SetEmblem( Critter& cr, int n, int, int )
{
    switch( n )
    {
    case 0:
        cr.StatBase[ ST_HASH_EMBLEM ] = EMBLEM_PURG_TEAM_2;
        break;
    case 1:
        cr.StatBase[ ST_HASH_EMBLEM ] = EMBLEM_PURG_TEAM_3;
        break;
    case 2:
        cr.StatBase[ ST_HASH_EMBLEM ] = EMBLEM_PURG_TEAM_4;
        break;
    default:
        cr.StatBase[ ST_HASH_EMBLEM ] = EMBLEM_PURG_TEAM_1;
        break;
    }
}

void AddBishop( Critter& cr, int, int, int )
{

    int[] params = { ST_DIALOG_ID, 785 };
    Critter @ npc = cr.GetMap().AddNpc( 148, cr.HexX - 1, cr.HexY - 1, 0, params, null, null );

}

void AddListener( Critter& cr, int chanel, int symbols, int )
{
    AddTextListener( SAY_RADIO, "TestListener" + symbols, chanel, "debug@listen_Test" );
}


void AddListener0( Critter& cr, int chanel, int symbols, int )
{
    AddTextListener( SAY_RADIO, "", chanel, "debug@listen_Test" );
}

void EraseListener( Critter& cr, int chanel, int symbols, int )
{
    EraseTextListener( SAY_RADIO, "TestListener" + symbols, chanel );
}

void listen_Test( Critter& player, string& text )
{
    player.Say( SAY_NETMSG, "Listener!" );
}

// ~run debug ViewScript 0 0 0
void ViewScript( Critter& player, int param0, int param1, int param2 )
{
    if( param0 == 0 )
        param0 = 20;

    Map@ map = player.GetMap();
    if( not valid( map ) )
        return;

    Critter@[] critters;
    uint count = 0;
    if( param1 == 0 )
        count = map.GetCrittersHex( player.HexX, player.HexY, param0, FIND_ALL | FIND_ONLY_NPC, critters );
    else
    {
        Critter@ cr = GetCritter( param1 );
        if( not valid( cr ) )
            return;
        critters.resize( 1 );
        @critters[ 0 ] = @cr;
		count = 1;
    }

    for( uint i = 0; i < count; i++ )
    {
        if( valid( critters[ i ] ) )
            critters[ i ].Say( SAY_NORM_ON_HEAD, GetScriptName( critters[ i ].GetScriptId() ) );
    }
}

// ~run debug Unblock 5 0 0
void Unblock( Critter& player, int radius, int, int )
{
    Map@   m = player.GetMap();
    uint16 x = player.HexX;
    uint16 y = player.HexY;
    for( int i = 1; i < radius; i++ )
    {
        m.UnblockHex( x + i, y );
        m.UnblockHex( x - i, y );
        m.UnblockHex( x + i, y - i );
        m.UnblockHex( x - i, y - i );
        m.UnblockHex( x + i, y + i );
        m.UnblockHex( x - i, y + i );
        m.UnblockHex( x, y - i );
        m.UnblockHex( x, y + i );
    }
}

// ~run debug UnSetHexFlag 5 1 0 // Убрать флаг криттера в радиусе
void UnSetHexFlag( Critter& player, int radius, int flag, int )
{
    Map@   m = player.GetMap();
    uint16 x = player.HexX;
    uint16 y = player.HexY;
    for( int i = 1; i < radius; i++ )
    {
        m.UnSetHexFlag( x + i, y, flag );
        m.UnSetHexFlag( x + i, y, flag );
        m.UnSetHexFlag( x - i, y, flag );
        m.UnSetHexFlag( x + i, y - i, flag );
        m.UnSetHexFlag( x - i, y - i, flag );
        m.UnSetHexFlag( x + i, y + i, flag );
        m.UnSetHexFlag( x - i, y + i, flag );
        m.UnSetHexFlag( x, y - i, flag );
        m.UnSetHexFlag( x, y + i, flag );
    }
}

// ~run debug MapStatic 5 0 0
void MapStatic( Critter& player, int radius, int, int )
{
    Map@ m = player.GetMap();
    player.Say( SAY_NETMSG, "Криттеров: " + m.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, null ) + " Итемов: " + m.GetItems( 0, null ) );
}

// ~run debug AddAnimal 0 0 0
void AddAnimal( Critter& player, int protoCritter, int, int )
{
    Item@ it = player.AddItem( PID_LIFE_GECKO, 1 );
    if( valid( it ) )
    {
        it.Val0 = protoCritter;
    }
}

// ~run debug ShowCityParam 0 0 0
void ShowCityParam( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] crits;
        map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, crits );
        if( crits.length() == 0 )
            cr.Say( SAY_NETMSG, "Critters not found!" );
        for( uint n = 0; n < crits.length(); n++ )
            map.SetText( crits[ n ].HexX, crits[ n ].HexY, COLOR_WHITE, "ST_ROLE_CITY " + crits[ n ].Param[ ST_ROLE_CITY ] + ( ( not crits[ n ].CityRole_IsProtected ) ? " COLOR_CONTOUR_RED" : " COLOR_CONTOUR_GREEN" ) );
    }
}

void GetGlobalCarId( Critter& cr, int id, int, int )
{
    Critter@ npc = GetCritter( id );
    if( @npc == null )
        @npc = cr;
    cr.Say( SAY_NETMSG, "npc.GetGlobalGroupCarId() " + npc.GetGlobalGroupCarId() );
}
// ~run debug SetIsProtected 0 0 0
void SetIsProtected( Critter& cr, int id, int CityRole_IsProtected, int )
{
    Critter@ npc = GetCritter( id );
    if( @npc == null )
        return;
    npc.CityRole_IsProtected = CityRole_IsProtected == 1;
}
// ~run debug SetIsGuard 0 0 0
void SetIsGuard( Critter& cr, int id, int CityRole_IsGuard, int )
{
    Critter@ npc = GetCritter( id );
    if( @npc == null )
        return;
    npc.CityRole_IsGuard = CityRole_IsGuard == 1;
}
// ~run debug SetIsNotHelper 0 0 0
void SetIsNotHelper( Critter& cr, int id, int CityRole_IsNotHelper, int )
{
    Critter@ npc = GetCritter( id );
    if( @npc == null )
        return;
    npc.CityRole_IsNotHelper = CityRole_IsNotHelper == 1;
}
// ~run debug SetIsPatrol 0 0 0
void SetIsPatrol( Critter& cr, int id, int CityRole_IsPatrol, int )
{
    Critter@ npc = GetCritter( id );
    if( @npc == null )
        return;
    npc.CityRole_IsPatrol = CityRole_IsPatrol == 1;
}
// ~run debug GetCityParams 0 0 0
void GetCityParams( Critter& cr, int id, int, int )
{
    Critter@ npc = GetCritter( id );
    if( @npc == null )
        return;
    cr.Say( SAY_NETMSG, "npc.CityRole_IsPatrol " + npc.CityRole_IsPatrol );
    cr.Say( SAY_NETMSG, "npc.CityRole_IsGuard " + npc.CityRole_IsGuard );
    cr.Say( SAY_NETMSG, "npc.CityRole_IsProtected " + npc.CityRole_IsProtected );
    cr.Say( SAY_NETMSG, "npc.CityRole_IsNotHelper " + npc.CityRole_IsNotHelper );
}

// ~run debug DeleteArmor 0 0 0
void DeleteArmor( Critter& cr, int id, int, int )
{
    Item@ armor = _CritGetItemArmor( cr );
    DeleteItem( armor );
}

// ~run debug CheckAccessory id 0 0
void CheckAccessory( Critter& cr, int id, int, int )
{
    Item@ item = GetItem( id );
    cr.Say( SAY_NETMSG, "item.Accessory=" + item.Accessory );
}
// ~run debug GetCoordinate id 0 0
void GetCoordinate( Critter& cr, int id, int, int )
{
    Critter@ c = cr;
    if( id != 0 )
        @ c = GetCritter( id );
    if( not valid( c ) )
        @ c = cr;
    cr.Say( SAY_NETMSG, "c.HexX=" + c.HexX + " c.HexY=" + c.HexY );
}

// ~run debug GetAccessContainerId 0 0 0
void GetAccessContainerId( Critter& cr, int id, int, int )
{
    cr.Say( SAY_NETMSG, "AccessContainerId " + cr.LastContainerId );
}

// ~run debug PrevHexTick 0 0 0
void PrevHexTick( Critter& cr, int id, int, int )
{
    cr.Say( SAY_NETMSG, "PrevHexTick " + cr.PrevHexTick );
}

#define DS_FLAG_NOT_WALK    ( 0x00000001 )
#define DS_FLAG_NOT_SHOT    ( 0x00000002 )

// ~run debug DeleteMyArmor 1 0 0
void DeleteMyArmor( Critter& player, int, int, int )
{
    Item@ it = _CritGetItemArmor( player );
    if( valid( it ) )
        DeleteItem( it );
}

// ~run debug GetGlobalGroupTimeCanFollow 1 0 0
void GetGlobalGroupTimeCanFollow( Critter& player, int, int, int )
{
    player.Say( SAY_NETMSG, " " + player.GetGlobalGroupTimeCanFollow() );
}

// ~run debug SetShowCritterDist1 1 0 0
void SetShowCritterDist1( Critter& player, int p0, int, int )
{
    player.ShowCritterDist1 = p0;
}

// ~run debug GetSecond 1 0 0
void GetSecond( Critter& player, int, int, int )
{
    player.Say( SAY_NETMSG, " " + __FullSecond );
}

// ~run debug GetGlobalGroupProcessLastTick 1 0 0
void GetGlobalGroupProcessLastTick( Critter& player, int, int, int )
{
    player.Say( SAY_NETMSG, " " + player.GetGlobalGroupProcessLastTick() );
}

// ~run debug PrevHexTick 0 0 0
// ~run debug GetTick 1 0 0
void GetTick( Critter& player, int, int, int )
{
    player.Say( SAY_NETMSG, " " + GetTick() );
}

class DoubleUint16
{
    DoubleUint16( uint16 a = 0, uint16 b = 0 )
    {
        A = a;
        B = b;
    }

    bool IsDouble( uint16 a = 0, uint16 b = 0 )
    {
        return ( A == a && B == b );
    }

    bool IsDouble( DoubleUint16& other )
    {
        return ( A == other.A && B == other.B );
    }

    uint16 A;
    uint16 B;
}

void VerifyTrigger( Critter& cr, int p0, int p1, int p2 )
{
    cr.GetMap().VerifyTrigger( cr, p0, p1, p2 );
}

void GetItemId( Critter& cr, int p0, int p1, int p2 )
{
    Item@ it = _CritGetItemHand( cr );
    cr.Say( SAY_NETMSG, "ItemId = " + it.Id );
}

void GetItemIdMoveToItem( Critter& cr, int p0, int p1, int p2 )
{
    Item@ it0 = GetItem( p0 );
    Item@ it1 = GetItem( p1 );
    MoveItem( it0, it0.GetCount(), it1, cr.Id );
}

void GetItemsInItem( Critter& cr, int p0, int p1, int p2 )
{
    Item@ it0 = GetItem( p0 );
    cr.ShowContainer( null, it0, TRANSFER_SELF_CONT );
}

void SetItemImageToEffect( Critter& cr, int p0, int p1, int p2 )
{
    Item@            it0 = GetItem( p0 );
    SETFLAG( it0.Flags, ITEM_SHOW_ANIM );
    const ProtoItem@ pi = GetProtoItem( p1 );
    it0.PicMap = pi.PicMap;
    it0.Update();

	Log( "" + pi.PicMap );

    // it0
}

void SetItemAnim( Critter& cr, int p0, int p1, int p2 )
{
    Item@ it0 = GetItem( p0 );
    it0.Animate( p1, p2 );
    it0.Update();

    // it0
}


void SetItemAnimParam( Critter& cr, int p0, int p1, int p2 )
{
    Item@ it0 = GetItem( p0 );
    switch( p1 )
    {
    case 0:
        it0.AnimWaitBase = p2;
        break;

    case 1:
        it0.AnimStayBegin = p2;
        break;

    case 2:
        it0.AnimStayEnd = p2;
        break;

    case 3:
        it0.AnimShowBegin = p2;
        break;

    case 4:
        it0.AnimShowEnd = p2;
        break;

    case 5:
        it0.AnimHideBegin = p2;
        break;

    case 6:
        it0.AnimHideEnd = p2;
        break;
    }
    it0.Update();

    // it0
}

void SetFlagItem( Critter& cr, int p0, int p1, int p2 )
{
    Item@ it0 = GetItem( p0 );
    if( p2 == 0 )
        SETFLAG( it0.Flags, p1 );
    else
        UNSETFLAG( it0.Flags, p1 );
    it0.Update();

    // it0
}
// ~run debug Transfer id type isItem
// id - id
// type тип трансфера 1, 2 - лутание контейнера ( только вблизи ). 5 - воровство у криттера. 6 - бартер с криттером. 7 - лутание контейнера не зависимо от дистанции. 8 - что и 7, но криттера, не важно живой или мертвый.
// isItem - при 0 айди криттера, при 1 айди итема
void Transfer( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cr0 = null;
    Item@    it = null;
    if( p2 == 0 )
        @ cr0 = GetCritter( p0 );
    else
        @ it = GetItem( p0 );
    cr.ShowContainer( cr0, it, p1 );
}

void SetRain( Critter& cr, int p0, int p1, int p2 )
{
    cr.GetMap().SetRain( p0 );
}

void TestValideItem( Critter& cr, int p0, int, int )
{
    cr.Say( SAY_NETMSG, "Run" );
    Item@ it = cr.AddItem( p0, 1 );
    if( valid( it ) )
    {
        cr.Say( SAY_NETMSG, "it valid 1 " );
        if( not it.IsNotValid )
        {
            cr.Say( SAY_NETMSG, "it valid 2 " );
            DeleteItem( it );
            it.Update();
            if( valid( it ) )
            {
                cr.Say( SAY_NETMSG, "it valid 3 " );
                if( not it.IsNotValid )
                    cr.Say( SAY_NETMSG, "it valid 4 " );
                else
                    cr.Say( SAY_NETMSG, "it not valid 4" );
            }
            else
                cr.Say( SAY_NETMSG, "it not valid 3" );
        }
        else
            cr.Say( SAY_NETMSG, "it not valid 2" );
    }
    else
        cr.Say( SAY_NETMSG, "it not valid 1" );
}

// ~run debug CritterSetNoSee 1 0 0
void CritterSetNoSee( Critter&, int id, int, int )
{
    if( valid( GetCritter( id ) ) )
    {
        GetCritter( id ).ModeBase[ MODE_NO_SEE ] = -1;
        GetCritter( id ).RefreshVisible();
    }
}

// ~run debug Action 1 0 0
void Action( Critter& cr, int p, int p1, int itId )
{
    Item@ it = null;
    if( itId != 0 )
        @it = GetItem( itId );
    cr.Action( p, p1, it );
}

//  ~run debug CreateCar pid ox oy
void CreateCar( Critter& cr, int pid, int ox, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX + ox, cr.HexY + oy, pid, 1 );
    if( not valid( car ) )
        return;
    if( car.GetType() != ITEM_TYPE_CAR )
    {
        DeleteItem( car );
        return;
    }

    car.Charge = car.Proto.Car_TankVolume;
    car.Deterioration = 0;

    uint keyId = Random( 10000, 50000 );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;
    cr.AddItem( PID_BLUE_PASS_KEY, 1 ).LockerId = keyId;

    car.Update();
    cr.Say( SAY_NETMSG, "Done." + car.Id + " " + car.GetChild( 0 ).GetProtoId() );
}

//  ~run debug MoveCar id ox oy
void MoveCar( Critter& cr, int id, int ox, int oy )
{
    Item@ car = GetItem( id );
    if( not valid( car ) || car.GetType() != ITEM_TYPE_CAR )
        return;

    cr.Say( SAY_NETMSG, "car.HexX = " + car.HexX + " car.HexY = " + car.HexY );
    uint16 oldX = car.HexX, oldY = car.HexY;
    MoveItem( car, 1, cr.GetMap(), car.HexX + ox, car.HexY + oy );
    cr.Say( SAY_NETMSG, "car.HexX = " + car.HexX + " car.HexY = " + car.HexY );
    // for(uint child=0; child<5; child++)
    {
        Item@ bag = GetItem( car.Id + 1 );
        if( valid( bag ) && ITEM_TYPE_CONTAINER == bag.GetType()  && bag.GetProtoId() >= PID_HIGHWAYMAN_BAG && bag.GetProtoId() <= PID_VERTIBIRD_BAG )
        {
            cr.Say( SAY_NETMSG, "bag.HexX = " + bag.HexX + " bag.HexY = " + bag.HexY );
            MoveItem( bag, 1, cr.GetMap(), car.HexX - int(oldX - bag.HexX), car.HexY - int(oldY - bag.HexY) );
            cr.Say( SAY_NETMSG, "bag.HexX = " + bag.HexX + " bag.HexY = " + bag.HexY );
            // ChangeCoordinateBag( bag.HexX, bag.HexY, uint16( car.HexX + ox + bag.HexX ), uint16( car.HexY+oy+bag.HexY ) );
            bag.Update();
        }
    }
    car.Update();
    cr.Say( SAY_NETMSG, "Done." + car.Id );
}

void ChangeCoordinateBag( uint16& x, uint16& y, uint16 newX, uint16 newY )
{
    x = newX;
    y = newY;
}

void GetAllRegistrPlayers()
{
    // uint[] ids;
    // string
    // GetRegisteredPlayers(uint[]&inout, string@[]&inout)
}

void WhileScript()
{
    while( true )
    {}
}

// TestRunTime trt;

class Tick
{
    Tick()
    {
        tick = GetTick();
    }

    ~Tick()
    {
        Log();
        tick = 0;
    }

    void Log()
    {
        ::Log( "RunTime: " + ( GetTick() - tick ) );
    }


    Tick@ opPostInc()
    {
        tick = GetTick();
        return this;
    }

    Tick@ opPreInc()
    {
        Log();
        return this++;
    }

    uint tick;
}

class TestRunTime
{
    TestRunTime()
    {
        Tick t();

        for( uint i = 0; i < 50000; i++ )
        {
            int[] arr = { 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17 };
        }

        ++t;


        for( uint i = 0; i < 50000; i++ )
        {
            array< int > arr = { 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17, 50, 12, 17 };
        }
    }
}

void t_drop_trigger( Critter& cr, Scenery& trigger, bool entered, uint8 dir, int targetMapPid, int entId )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Location@ loc = map.GetLocation();
        if( valid( loc ) )
        {
            Map@ targetMap = loc.GetMap( targetMapPid );

            if( valid( targetMap ) )
            {
                InjureCritter( cr, Random( 10, 100 ), DAMAGE_UNCALLED, 0, 0 );
                cr.TimeoutBase[ TO_BATTLE ] = 0;
                cr.TransitToMap( targetMap.Id, entId );
                cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( Random( 0, 1 ) == 1 ), cr.Stat[ ST_ACTION_POINTS ] * 3, cr.HexX, cr.HexY );
                for( uint n = 0; n < 4; n++ )
                {
                    if( Random( 1, 100 ) > 74 )
                    {
                        cr.DamageBase[ DAMAGE_RIGHT_ARM + n ] = 1;
                        cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 1575 + n );
                    }
                }
            }
        }
    }
}

void ReloadedFunc( Critter&, int, int, int )
{
    Log( "Funtion 1" );
}

void LoadTestScript( Critter&, int, int, int )
{
    Log( "LoadTestScript" );
    // LoadScriptModule( "test_debbuger" );
    Log( "LoadTestScript2" );
}

void UnloadTestScript( Critter&, int, int, int )
{
    Log( "UnloadTestScript" );
    // UnloadScriptModule( "test_debbuger" );
    Log( "UnloadTestScript2" );
}

void ReloadTestScript( Critter&, int, int, int )
{
    // Log( "ReloadTestScript" );
    file f;
    if( f.open( "reloadFunc.fos", "r" ) != -1 )
    {
        string code = "",
               module = "",
               decl = "";
        f.readLine( module );
        f.readLine( decl );
        f.readString( uint( f.getSize() ), code );
        code = decl + code;
        // Log( "\n\"" + module + "\"\n\"" + decl + "\"\n\"" + code);
        f.close();
        // ReloadFunction( module, decl, code );
        // InfoASEngine( module );
    }
    // Log( "ReloadTestScript2" );
}

void DebbugerCallFunction()
{
    Log( "Call" );
}

void dd( Critter& cr, int num, int, int )
{
    Mk2RunDialog( cr, num, cr.GetMap(), cr.HexX, cr.HexY + 1, true );
}

#include "combat_h.fos"

void DamageMe( Critter& cr, int idx, int dmg, int )
{
    CombatProccess@ a = CombatProccess();
    a.Damage[ idx ] = dmg;
	
	Mk2::CombatTargetPacket@ glob = cast<Mk2::CombatTargetPacket>(@cr.ScriptDescriptor);
    if( valid( glob ) )
        glob.TakeDamage( a, 1, dmg );
}

import bool AddGoToHealPlane( Critter& npc, Critter& target, bool run ) from "npc_planes";

class DebugItemDesript : Mk2::Descriptor
{
	Item@ RealIt;

	DebugItemDesript( Item& it )
	{
		@RealIt = it;
	}
	
	uint get_Priority( )
	{
		return 10;
	}
	
	bool IsSet( Mk2::Descriptor@ new )
	{
		return false;
	}
	
	::string@ get_Name( )
	{
		return "DebugItemDesript" + (valid(RealIt)?"" + RealIt.Id : "Null");
	}
}

//  ~run debug TestItemDescript 0 0 0
void TestItemDescript( Critter& cr, int , int , int )
{
    Item@ it = _CritGetItemHand( cr );
	if(valid(it))
	{
		@it.ScriptDescriptor = @DebugItemDesript( it );
		Mk2::Descriptor@ descr = @it.ScriptDescriptor;
		if(valid(descr))
		{
			Log( "Set descr " + descr.Name );
			if( !Mk2::IsEvent( it, ITEM_EVENT_FINISH ) )
				it.SetEvent( ITEM_EVENT_FINISH, "Mk2@item_finish" );
		}
		else Log( "No set descr " );
	}
}

void ClearDescriptor_ItemFinish( ::Item& item, bool deleted )
{
	@item.ScriptDescriptor = null;
}

//  ~run debug NameItemDescript 0 0 0
void NameItemDescript( Critter& cr, int , int , int )
{
    Item@ it = _CritGetItemHand( cr );
	if(valid(it))
	{
		Mk2::Descriptor@ descr = @it.ScriptDescriptor;
		if(valid(descr))
			Log( "Get descr " + descr.Name );
		else Log( "No get descr " );
	}
}

//  ~run debug YouHealMe id 1803 0
void YouHealMe( Critter& cr, int id, int pidStim, int  )
{
    Critter@ med = GetCritter( id );
    if( valid( med ) )
    {
        if( pidStim > 0 )
        {
            med.AddItem( pidStim, 1 );
        }
        AddGoToHealPlane( med, cr, true );
    }
}

//  ~run debug YouSteal id 1803 0
void YouSteal( Critter& cr, int id, int pidStim, int  )
{
    Critter@ th = GetCritter( id );
    if( valid( th ) )
    {

        if( pidStim > 0 )
        {
            Item@     it = th.AddItem( pidStim, 1 );

            NpcPlane@ plane = CreatePlane();
            plane.Type = AI_PLANE_WALK;
            plane.Priority = AI_PLANE_HEAL_PRIORITY;
            plane.Identifier = 0;
            plane.IdentifierExt = 0;
            plane.Walk_HexX = cr.HexX;
            plane.Walk_HexY = cr.HexY;
            plane.Run = true;
            plane.Walk_Cut = 1;
            plane.Walk_Reason_CritterId = cr.Id;
            plane.Walk_TypeWalkReason = AI_PLANE_WALK_STEAL;
            plane.Walk_Var0 = it.Id;
            th.AddPlane( plane );
        }
    }
}

import bool OnUseExplode( Critter& cr, Item& explode, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint timer ) from "explode";
//  ~run debug YouStealExplode id 0 0
void YouStealExplode( Critter& cr, int id, int pidStim, int  )
{
    Critter@ th = GetCritter( id );
    if( valid( th ) )
    {
        if( pidStim > 0 )
        {
            Item@ it = th.AddItem( PID_DYNAMITE, 1 ), itActive = null;

            if( OnUseExplode( th, it, null, null, null, 5 ) )
            {
                @ itActive = th.GetItem( PID_ACTIVE_DYNAMITE, -1 );
                NpcPlane@ plane = CreatePlane();
                plane.Type = AI_PLANE_WALK;
                plane.Priority = AI_PLANE_HEAL_PRIORITY;
                plane.Identifier = 0;
                plane.IdentifierExt = 0;
                plane.Walk_HexX = cr.HexX;
                plane.Walk_HexY = cr.HexY;
                plane.Run = true;
                plane.Walk_Cut = 1;
                plane.Walk_Reason_CritterId = cr.Id;
                plane.Walk_TypeWalkReason = AI_PLANE_WALK_STEAL;
                plane.Walk_Var0 = itActive.Id;
                th.AddPlane( plane );
            }
        }
    }
}


//  ~run debug YouHealSelf id 0 0
void YouHealSelf( Critter& cr, int id, int pidStim, int  )
{
    Critter@ med = GetCritter( id );
    if( valid( med ) )
    {
        if( pidStim > 0 )
        {
            med.AddItem( pidStim, 2 );
        }

        NpcPlane@ plane = CreatePlane();
        plane.Type = AI_PLANE_WALK;
        plane.Priority = AI_PLANE_HEAL_PRIORITY;
        plane.Identifier = 0;
        plane.IdentifierExt = 0;
        plane.Walk_HexX = cr.HexX;
        plane.Walk_HexY = cr.HexY;
        plane.Run = true;
        plane.Walk_Cut = 1;
        plane.Walk_Reason_CritterId = cr.Id;
        plane.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

        NpcPlane@ plane2 = CreatePlane();
        plane2.Type = AI_PLANE_WALK;
        plane2.Priority = AI_PLANE_HEAL_PRIORITY;
        plane2.Identifier = 0;
        plane2.IdentifierExt = 0;
        plane2.Walk_HexX = med.HexX;
        plane2.Walk_HexY = med.HexY;
        plane2.Run = true;
        plane2.Walk_Cut = 1;
        plane2.Walk_Reason_CritterId = med.Id;
        plane2.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

        Log( "Dead" );
        plane.SetChild( plane2 );
        med.AddPlane( plane );
    }
}

void YouHealSelfAndMe( Critter& cr, int id, int pidStim, int  )
{
    Critter@ med = GetCritter( id );
    if( valid( med ) )
    {
        if( pidStim > 0 )
        {
            med.AddItem( pidStim, 1 );
        }
        AddGoToHealPlane( med, med, false );
    }
}


int16 debugflag = 0;

//  ~run debug DebugFlag 1 2048 0
void DebugFlag( Critter& cr, int set, int flag, int  )
{
    if( set == 1 )
        SETFLAG( debugflag, flag );
    else if( set == 2 )
        UNSETFLAG( debugflag, flag );
    cr.Say( SAY_NORM, " debugflag " + debugflag );
    cr.Say( SAY_NORM, " flag " + flag + " " + ( FLAG( debugflag, flag ) ? "true" : "false" ) );
}

//  ~run debug GetLength 1 1 0
void GetLength( Critter& cr, int set, int flag, int  )
{

    Critter@ targeti = GetCritter( set );
    cr.Say( SAY_NORM, " length " + cr.GetMap().GetPathLength( cr, targeti.HexX, targeti.HexY, flag ) );
}

import bool Zone_Attack( Critter& cr, uint16 hexX, uint16 hexY, int slot ) from "combat";
//  ~run debug IsZoneAttack 1 0 0
void IsZoneAttack( Critter& cr, int set, int flag, int  )
{
    Critter@ target = GetCritter( set );
    cr.Say( SAY_NORM, " zone " + Zone_Attack( cr, target.HexX, target.HexY, SLOT_HAND1 ) );
}


//  ~run debug TestPrioritet 1 0 0
void TestPrioritet( Critter& npc, int targetId, int, int  )
{
    Critter@         target = GetCritter( targetId );
    Map@             map = target.GetMap();

    uint8            mode = 0, targetMode = 0;
    const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode ),
                     targetWeapon = target.GetSlotProto( SLOT_HAND1, targetMode );

    if( !valid( weapon ) )
        return;

    int targetUse = 0,
        targetWpnDist = 1,
        isTargetUnarmed = 0;

    if( valid( targetWeapon ) )
    {
        targetUse = _WeaponModeUse( targetMode );
        targetWpnDist = _WeaponMaxDist( targetWeapon, targetUse );
    }
    else
        isTargetUnarmed = 1;

    int              use = _WeaponModeUse( mode );
    int              wpnDist = _WeaponMaxDist( weapon, use );

    const ProtoItem@ ammo = ( weapon.Weapon_MaxAmmoCount > 0 && weapon.Weapon_Caliber != 0 ? GetProtoItem( _CritGetItemHand( npc ).AmmoPid ) : null );
    bool             validAmmo = valid( ammo );
    uint             ammoCount = _WeaponRound( weapon, use );

    /*if(!valid(plane))
            @plane = npc.GetCurPlane();

       NpcPlane@[] planes;
       NpcPlane@ priorAttack = plane;

       bool changePrior = false;*/

    uint RadiusDamage = weapon.HexWeapon_Radius;
    // if( RadiusDamage == 0 )
    //	RadiusDamage=(weapon.ProtoId==PID_GRANADE_REVOLV_I || weapon.ProtoId==PID_GRANADE_REVOLV_II || weapon.ProtoId==PID_GRANADE_PISTOL || weapon.ProtoId==PID_REVOLV_GRENADE)?1:2;
    bool isRadiusDamage = RadiusDamage != 0;


    int totalDmg = 0;
    int dmgType = _WeaponDmgType( weapon, use ),

        targetDR = target.Stat[ ST_NORMAL_RESIST + dmgType - 1 ],
        targetDT = target.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ],
        dmgMin = _WeaponDmgMin( weapon, use ),
        dmgMax = _WeaponDmgMax( weapon, use ),
        dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1,   // technically, should be *2
        dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1,    // technically, should be *2
        bt = target.Stat[ ST_BODY_TYPE ];

    if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
        targetDT /= 5;
    targetDR += ( ( npc.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
    if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
        totalDmg += 15;
    if( validAmmo )
        targetDR += ammo.Ammo_DrMod;
    targetDR = CLAMP( targetDR, 0, 100 );

    totalDmg = ( dmgMax + dmgMin + 2 * npc.Perk[ PE_BONUS_RANGED_DAMAGE ] ) / 2;
    totalDmg *= dmgMul;
    if( dmgDiv != 0 )
        totalDmg /= dmgDiv;
    totalDmg -= targetDT;
    totalDmg -= ( totalDmg * targetDR ) / 100;
    totalDmg *= ammoCount;
    if( totalDmg < 0 )
        totalDmg = 0;
    if( npc.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( bt == BT_ALIEN || bt == BT_ROBOT ) )
        totalDmg += 15;
    if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
        totalDmg += 20;
    totalDmg -= ( totalDmg * npc.Perk[ PE_TOUGHNESS ] * 5 ) / 100;

    int DeadHitPoints = target.Stat[ ST_DEAD_HIT_POINTS ];
    if( ( DeadHitPoints == __DeadHitPoints && ( bt != BT_MEN && bt != BT_WOMEN &&
                                                bt != BT_CHILDREN && bt != BT_SUPER_MUTANT && bt != BT_GHOUL && bt != BT_BRAHMIN && bt != BT_DOG ) ) ||
        target.Mode[ MODE_NO_KNOCK ] != 0 )
        DeadHitPoints = 0;

    int hp = target.Stat[ ST_CURRENT_HP ] + DeadHitPoints;
    int Value0 = 0;            // ( totalDmg > hp )?1:(hp/totalDmg + ((hp%totalDmg==0)?0:1));

    npc.Say( SAY_NETMSG, "isRadiusDamage " + isRadiusDamage + " RadiusDamage " + RadiusDamage );

    if( isRadiusDamage && RadiusDamage > 0 )
    {
        int Value1 = totalDmg;
        Critter@[] critters;
        for( int i = 0, iEnd = map.GetCrittersHex( target.HexX, target.HexY, RadiusDamage, FIND_LIFE_AND_KO, critters ); i < iEnd; i++ )
        {
            Critter@ targetc = critters[ i ];
            if( !valid( targetc ) )
                continue;

            totalDmg = 0;
            dmgType = _WeaponDmgType( weapon, use );
            targetDR = targetc.Stat[ ST_NORMAL_RESIST + dmgType - 1 ];
            targetDT = targetc.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ];
            dmgMin = _WeaponDmgMin( weapon, use );
            dmgMax = _WeaponDmgMax( weapon, use );
            dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1;               // technically, should be *2
            dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;                // technically, should be *2
            bt = targetc.Stat[ ST_BODY_TYPE ];

            if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
                targetDT /= 5;
            targetDR += ( ( npc.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
            if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
                totalDmg += 15;
            if( validAmmo )
                targetDR += ammo.Ammo_DrMod;
            targetDR = CLAMP( targetDR, 0, 100 );

            totalDmg = ( dmgMax + dmgMin + 2 * npc.Perk[ PE_BONUS_RANGED_DAMAGE ] ) / 2;
            totalDmg *= dmgMul;
            if( dmgDiv != 0 )
                totalDmg /= dmgDiv;
            totalDmg -= targetDT;
            totalDmg -= ( totalDmg * targetDR ) / 100;
            totalDmg *= ammoCount;
            if( totalDmg < 0 )
                totalDmg = 0;
            if( npc.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( bt == BT_ALIEN || bt == BT_ROBOT ) )
                totalDmg += 15;
            if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
                totalDmg += 20;
            totalDmg -= ( totalDmg * npc.Perk[ PE_TOUGHNESS ] * 5 ) / 100;

            if( targetc.IsNpc() && npc.Stat[ ST_TEAM_ID ] == targetc.Stat[ ST_TEAM_ID ] && targetc.Stat[ ST_TEAM_ID ] != 0 )
                Value1 -= totalDmg;
            else
                Value1 += totalDmg;
        }
        Value0 = Value1;

        npc.Say( SAY_NETMSG, "Value0 " + Value0 );
    }
    else
    {
        if( hp > 0 && totalDmg > 0 )
        {
            Value0 = ( totalDmg > hp ) ? 1 : ( hp / totalDmg + ( ( hp % totalDmg == 0 ) ? 0 : 1 ) );

            if( !Zone_Attack( npc, target.HexX, target.HexY, SLOT_HAND1 ) )
            {
                int add = map.GetPathLength( npc, target.HexX, target.HexY, 1 );
                if( add == 0 && !( ( valid( weapon ) && _WeaponSkill( weapon, use ) == SK_UNARMED ) || !valid( weapon ) ) )
                    add = 100;
                totalDmg += add * ( ( ( valid( weapon ) && _WeaponSkill( weapon, use ) == SK_UNARMED ) || !valid( weapon ) ) ? 1 : 6 );
            }
            Value0 *= 100;

            if( Zone_Attack( target, npc.HexX, npc.HexY, SLOT_HAND1 ) )
                Value0 /= 2;

        }
        npc.Say( SAY_NETMSG, "Value0 " + Value0 );
    }
}

void TestDistantion( Critter& npc, int targetId, int, int  )
{
    Critter@         target = ::GetCritter( targetId );

    uint8            mode = 0;
    const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode );
    if( !valid( weapon ) )
        return;
    int              use = _WeaponModeUse( mode );
    int              wpnDist = _WeaponMaxDist( weapon, use );
    const ProtoItem@ ammo = ( weapon.Weapon_MaxAmmoCount > 0 && weapon.Weapon_Caliber != 0 ? GetProtoItem( _CritGetItemHand( npc ).AmmoPid ) : null );

    uint             RadiusDamage = weapon.HexWeapon_Radius;
    // if( RadiusDamage == 0 )
    // RadiusDamage=(weapon.ProtoId==PID_GRANADE_REVOLV_I || weapon.ProtoId==PID_GRANADE_REVOLV_II || weapon.ProtoId==PID_GRANADE_PISTOL || weapon.ProtoId==PID_REVOLV_GRENADE)?1:2;
    bool             isRadiusDamage = RadiusDamage != 0;

    uint8            targetMode = 0;
    const ProtoItem@ targetWeapon = target.GetSlotProto( SLOT_HAND1, targetMode );
    int              targetUse = 0;
    int              targetWpnDist = 1;
    if( valid( targetWeapon ) )
    {
        targetUse = _WeaponModeUse( targetMode );
        targetWpnDist = _WeaponMaxDist( targetWeapon, targetUse );
    }

    int dist = GetDistantion( npc.HexX, npc.HexY, target.HexX, target.HexY );

    if( ( npc.IsCanWalk() ) )                                     // Zone_Attack(npc, target.HexX, target.HexY,SLOT_HAND1 ) )
    {

        int min = 0, best = 0, max = wpnDist;

        min = 0;

        if( RadiusDamage != 0 )
            min = RadiusDamage + 1;

        if( targetWpnDist <= 5 && wpnDist > targetWpnDist && min <= targetWpnDist )
            min = targetWpnDist + 1;

        best = dist;

        if( wpnDist > targetWpnDist )
        {
            best = wpnDist;
        }

        if( wpnDist > 1 )
        {
            if( valid( weapon ) && ( _WeaponSkill( weapon, use ) == SK_BIG_GUNS || _WeaponSkill( weapon, use ) == SK_ENERGY_WEAPONS ) && _WeaponRound( weapon, use ) > 2 )
            {
                best = 1;
                min = 0;
            }
            else if( min <= 3 && valid( targetWeapon ) && ( _WeaponSkill( targetWeapon, targetUse ) == SK_BIG_GUNS || _WeaponSkill( targetWeapon, targetUse ) == SK_ENERGY_WEAPONS ) && _WeaponRound( weapon, targetUse ) > 2 )
            {
                min = 5;
            }
        }

        min = MIN( min, max );
        max = MAX( min, max );
        best = CLAMP( best, min, max );

        npc.Say( SAY_NETMSG, "min " + min + " best " + best + " max " + max + " wpnDist " + wpnDist + " targetWpnDist " + targetWpnDist );

        /*r1 = min;

           r0 = best;

           r2 = max;*/
    }
}

void TestDistantionFor( Critter& cr, int npcId, int targetId, int  )
{
    Critter@         npc = GetCritter( npcId );
    Critter@         target = ::GetCritter( targetId );

    uint8            mode = 0;
    const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode );
    if( !valid( weapon ) )
        return;
    int              use = _WeaponModeUse( mode );
    int              wpnDist = _WeaponMaxDist( weapon, use );
    const ProtoItem@ ammo = ( weapon.Weapon_MaxAmmoCount > 0 && weapon.Weapon_Caliber != 0 ? GetProtoItem( _CritGetItemHand( npc ).AmmoPid ) : null );

    uint             RadiusDamage = weapon.HexWeapon_Radius;
    // if( RadiusDamage == 0 )
    // RadiusDamage=(weapon.ProtoId==PID_GRANADE_REVOLV_I || weapon.ProtoId==PID_GRANADE_REVOLV_II || weapon.ProtoId==PID_GRANADE_PISTOL || weapon.ProtoId==PID_REVOLV_GRENADE)?1:2;
    bool             isRadiusDamage = RadiusDamage != 0;

    uint8            targetMode = 0;
    const ProtoItem@ targetWeapon = target.GetSlotProto( SLOT_HAND1, targetMode );
    int              targetUse = 0;
    int              targetWpnDist = 1;
    if( valid( targetWeapon ) )
    {
        targetUse = _WeaponModeUse( targetMode );
        targetWpnDist = _WeaponMaxDist( targetWeapon, targetUse );
    }

    int dist = GetDistantion( npc.HexX, npc.HexY, target.HexX, target.HexY );

    if( ( npc.IsCanWalk() ) )                                     // Zone_Attack(npc, target.HexX, target.HexY,SLOT_HAND1 ) )
    {

        int min = 0, best = 0, max = wpnDist;

        min = 0;

        if( RadiusDamage != 0 )
            min = RadiusDamage + 1;

        if( targetWpnDist <= 5 && wpnDist > targetWpnDist && min <= targetWpnDist )
            min = targetWpnDist + 1;

        best = dist;

        if( wpnDist > targetWpnDist )
        {
            best = wpnDist;
        }

        if( wpnDist > 1 )
        {
            if( valid( weapon ) && ( _WeaponSkill( weapon, use ) == SK_BIG_GUNS || _WeaponSkill( weapon, use ) == SK_ENERGY_WEAPONS ) && _WeaponRound( weapon, use ) > 2 )
            {
                best = 1;
                min = 0;
            }
            else if( min <= 3 && valid( targetWeapon ) && ( _WeaponSkill( targetWeapon, targetUse ) == SK_BIG_GUNS || _WeaponSkill( targetWeapon, targetUse ) == SK_ENERGY_WEAPONS ) && _WeaponRound( weapon, targetUse ) > 2 )
            {
                min = 5;
            }
        }

        min = MIN( min, max );
        max = MAX( min, max );
        best = CLAMP( best, min, max );

        cr.Say( SAY_NETMSG, "min " + min + " best " + best + " max " + max + " wpnDist " + wpnDist + " targetWpnDist " + targetWpnDist );

        /*r1 = min;

           r0 = best;

           r2 = max;*/
    }
}

void TestPrioritetForCritter( Critter& player, int npcId, int targetId, int  )
{
    Critter@         npc = GetCritter( npcId );
    Critter@         target = GetCritter( targetId );
    Map@             map = target.GetMap();

    uint8            mode = 0, targetMode = 0;
    const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode ),
                     targetWeapon = target.GetSlotProto( SLOT_HAND1, targetMode );
    if( !valid( weapon ) )
        return;
    int targetUse = 0,
        targetWpnDist = 1,
        isTargetUnarmed = 0;

    if( valid( targetWeapon ) )
    {
        targetUse = _WeaponModeUse( targetMode );
        targetWpnDist = _WeaponMaxDist( targetWeapon, targetUse );
    }
    else
        isTargetUnarmed = 1;

    int              use = _WeaponModeUse( mode );
    int              wpnDist = _WeaponMaxDist( weapon, use );

    const ProtoItem@ ammo = ( weapon.Weapon_MaxAmmoCount > 0 && weapon.Weapon_Caliber != 0 ? GetProtoItem( _CritGetItemHand( npc ).AmmoPid ) : null );
    bool             validAmmo = valid( ammo );
    uint             ammoCount = _WeaponRound( weapon, use );

    /*if(!valid(plane))
            @plane = npc.GetCurPlane();

       NpcPlane@[] planes;
       NpcPlane@ priorAttack = plane;

       bool changePrior = false;*/

    uint RadiusDamage = weapon.HexWeapon_Radius;
    // if( RadiusDamage == 0 )
    //	RadiusDamage=(weapon.ProtoId==PID_GRANADE_REVOLV_I || weapon.ProtoId==PID_GRANADE_REVOLV_II || weapon.ProtoId==PID_GRANADE_PISTOL || weapon.ProtoId==PID_REVOLV_GRENADE)?1:2;
    bool isRadiusDamage = RadiusDamage != 0;


    int totalDmg = 0;
    int dmgType = _WeaponDmgType( weapon, use ),

        targetDR = target.Stat[ ST_NORMAL_RESIST + dmgType - 1 ],
        targetDT = target.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ],
        dmgMin = _WeaponDmgMin( weapon, use ),
        dmgMax = _WeaponDmgMax( weapon, use ),
        dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1,   // technically, should be *2
        dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1,    // technically, should be *2
        bt = target.Stat[ ST_BODY_TYPE ];

    if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
        targetDT /= 5;
    targetDR += ( ( npc.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
    if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
        totalDmg += 15;
    if( validAmmo )
        targetDR += ammo.Ammo_DrMod;
    targetDR = CLAMP( targetDR, 0, 100 );

    totalDmg = ( dmgMax + dmgMin + 2 * npc.Perk[ PE_BONUS_RANGED_DAMAGE ] ) / 2;
    totalDmg *= dmgMul;
    if( dmgDiv != 0 )
        totalDmg /= dmgDiv;
    totalDmg -= targetDT;
    totalDmg -= ( totalDmg * targetDR ) / 100;
    totalDmg *= ammoCount;
    if( totalDmg < 0 )
        totalDmg = 0;
    if( npc.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( bt == BT_ALIEN || bt == BT_ROBOT ) )
        totalDmg += 15;
    if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
        totalDmg += 20;
    totalDmg -= ( totalDmg * npc.Perk[ PE_TOUGHNESS ] * 5 ) / 100;

    int DeadHitPoints = target.Stat[ ST_DEAD_HIT_POINTS ];
    if( ( DeadHitPoints == __DeadHitPoints && ( bt != BT_MEN && bt != BT_WOMEN &&
                                                bt != BT_CHILDREN && bt != BT_SUPER_MUTANT && bt != BT_GHOUL && bt != BT_BRAHMIN && bt != BT_DOG ) ) ||
        target.Mode[ MODE_NO_KNOCK ] != 0 )
        DeadHitPoints = 0;

    int hp = target.Stat[ ST_CURRENT_HP ] + DeadHitPoints;
    int Value0 = 0;            // ( totalDmg > hp )?1:(hp/totalDmg + ((hp%totalDmg==0)?0:1));

    player.Say( SAY_NETMSG, "isRadiusDamage " + isRadiusDamage + " RadiusDamage " + RadiusDamage );

    if( isRadiusDamage && RadiusDamage > 0 )
    {
        int Value1 = totalDmg;
        Critter@[] critters;
        for( int i = 0, iEnd = map.GetCrittersHex( target.HexX, target.HexY, RadiusDamage, FIND_LIFE_AND_KO, critters ); i < iEnd; i++ )
        {
            Critter@ targetc = critters[ i ];
            if( !valid( targetc ) )
                continue;

            totalDmg = 0;
            dmgType = _WeaponDmgType( weapon, use );
            targetDR = targetc.Stat[ ST_NORMAL_RESIST + dmgType - 1 ];
            targetDT = targetc.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ];
            dmgMin = _WeaponDmgMin( weapon, use );
            dmgMax = _WeaponDmgMax( weapon, use );
            dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1;               // technically, should be *2
            dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;                // technically, should be *2
            bt = targetc.Stat[ ST_BODY_TYPE ];

            if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
                targetDT /= 5;
            targetDR += ( ( npc.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
            if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
                totalDmg += 15;
            if( validAmmo )
                targetDR += ammo.Ammo_DrMod;
            targetDR = CLAMP( targetDR, 0, 100 );

            totalDmg = ( dmgMax + dmgMin + 2 * npc.Perk[ PE_BONUS_RANGED_DAMAGE ] ) / 2;
            totalDmg *= dmgMul;
            if( dmgDiv != 0 )
                totalDmg /= dmgDiv;
            totalDmg -= targetDT;
            totalDmg -= ( totalDmg * targetDR ) / 100;
            totalDmg *= ammoCount;
            if( totalDmg < 0 )
                totalDmg = 0;
            if( npc.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( bt == BT_ALIEN || bt == BT_ROBOT ) )
                totalDmg += 15;
            if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
                totalDmg += 20;
            totalDmg -= ( totalDmg * npc.Perk[ PE_TOUGHNESS ] * 5 ) / 100;

            if( targetc.IsNpc() && npc.Stat[ ST_TEAM_ID ] == targetc.Stat[ ST_TEAM_ID ] && targetc.Stat[ ST_TEAM_ID ] != 0 )
                Value1 -= totalDmg;
            else
                Value1 += totalDmg;
        }
        Value0 = Value1;

        player.Say( SAY_NETMSG, "Value0 " + Value0 );
    }
    else
    {
        if( hp > 0 && totalDmg > 0 )
        {
            Value0 = ( totalDmg > hp ) ? 1 : ( hp / totalDmg + ( ( hp % totalDmg == 0 ) ? 0 : 1 ) );

            if( !Zone_Attack( npc, target.HexX, target.HexY, SLOT_HAND1 ) )
            {
                int add = map.GetPathLength( npc, target.HexX, target.HexY, 1 );
                if( add == 0 && !( ( valid( weapon ) && _WeaponSkill( weapon, use ) == SK_UNARMED ) || !valid( weapon ) ) )
                    add = 100;
                totalDmg += add * ( ( ( valid( weapon ) && _WeaponSkill( weapon, use ) == SK_UNARMED ) || !valid( weapon ) ) ? 1 : 6 );
            }
            Value0 *= 100;

            if( Zone_Attack( target, npc.HexX, npc.HexY, SLOT_HAND1 ) )
                Value0 /= 2;

        }
        player.Say( SAY_NETMSG, "Value0 " + Value0 );
    }
}

void TestPrioritetMe( Critter& target, int npcId, int, int  )
{
    Critter@         npc = GetCritter( npcId );
    Map@             map = target.GetMap();

    uint8            mode = 0, targetMode = 0;
    const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode ),
                     targetWeapon = target.GetSlotProto( SLOT_HAND1, targetMode );

    if( !valid( weapon ) )
        return;

    int targetUse = 0,
        targetWpnDist = 1,
        isTargetUnarmed = 0;

    if( valid( targetWeapon ) )
    {
        targetUse = _WeaponModeUse( targetMode );
        targetWpnDist = _WeaponMaxDist( targetWeapon, targetUse );
    }
    else
        isTargetUnarmed = 1;

    int              use = _WeaponModeUse( mode );
    int              wpnDist = _WeaponMaxDist( weapon, use );

    const ProtoItem@ ammo = ( weapon.Weapon_MaxAmmoCount > 0 && weapon.Weapon_Caliber != 0 ? GetProtoItem( _CritGetItemHand( npc ).AmmoPid ) : null );
    bool             validAmmo = valid( ammo );
    uint             ammoCount = _WeaponRound( weapon, use );

    /*if(!valid(plane))
            @plane = npc.GetCurPlane();

       NpcPlane@[] planes;
       NpcPlane@ priorAttack = plane;

       bool changePrior = false;*/

    uint RadiusDamage = weapon.HexWeapon_Radius;
    // if( RadiusDamage == 0 )
    //	RadiusDamage=(weapon.ProtoId==PID_GRANADE_REVOLV_I || weapon.ProtoId==PID_GRANADE_REVOLV_II || weapon.ProtoId==PID_GRANADE_PISTOL || weapon.ProtoId==PID_REVOLV_GRENADE)?1:2;
    bool isRadiusDamage = RadiusDamage != 0;


    int totalDmg = 0;
    int dmgType = _WeaponDmgType( weapon, use ),

        targetDR = target.Stat[ ST_NORMAL_RESIST + dmgType - 1 ],
        targetDT = target.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ],
        dmgMin = _WeaponDmgMin( weapon, use ),
        dmgMax = _WeaponDmgMax( weapon, use ),
        dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1,   // technically, should be *2
        dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1,    // technically, should be *2
        bt = target.Stat[ ST_BODY_TYPE ];

    if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
        targetDT /= 5;
    targetDR += ( ( npc.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
    if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
        totalDmg += 15;
    if( validAmmo )
        targetDR += ammo.Ammo_DrMod;
    targetDR = CLAMP( targetDR, 0, 100 );

    totalDmg = ( dmgMax + dmgMin + 2 * npc.Perk[ PE_BONUS_RANGED_DAMAGE ] ) / 2;
    totalDmg *= dmgMul;
    if( dmgDiv != 0 )
        totalDmg /= dmgDiv;
    totalDmg -= targetDT;
    totalDmg -= ( totalDmg * targetDR ) / 100;
    totalDmg *= ammoCount;
    if( totalDmg < 0 )
        totalDmg = 0;
    if( npc.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( bt == BT_ALIEN || bt == BT_ROBOT ) )
        totalDmg += 15;
    if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
        totalDmg += 20;
    totalDmg -= ( totalDmg * npc.Perk[ PE_TOUGHNESS ] * 5 ) / 100;

    int DeadHitPoints = target.Stat[ ST_DEAD_HIT_POINTS ];
    if( ( DeadHitPoints == __DeadHitPoints && ( bt != BT_MEN && bt != BT_WOMEN &&
                                                bt != BT_CHILDREN && bt != BT_SUPER_MUTANT && bt != BT_GHOUL && bt != BT_BRAHMIN && bt != BT_DOG ) ) ||
        target.Mode[ MODE_NO_KNOCK ] != 0 )
        DeadHitPoints = 0;

    int hp = target.Stat[ ST_CURRENT_HP ] + DeadHitPoints;
    int Value0 = 0;            // ( totalDmg > hp )?1:(hp/totalDmg + ((hp%totalDmg==0)?0:1));

    target.Say( SAY_NETMSG, "isRadiusDamage " + isRadiusDamage + " RadiusDamage " + RadiusDamage );

    if( isRadiusDamage && RadiusDamage > 0 )
    {
        int Value1 = totalDmg;
        Critter@[] critters;
        for( int i = 0, iEnd = map.GetCrittersHex( target.HexX, target.HexY, RadiusDamage, FIND_LIFE_AND_KO, critters ); i < iEnd; i++ )
        {
            Critter@ targetc = critters[ i ];
            if( !valid( targetc ) )
                continue;

            totalDmg = 0;
            dmgType = _WeaponDmgType( weapon, use );
            targetDR = targetc.Stat[ ST_NORMAL_RESIST + dmgType - 1 ];
            targetDT = targetc.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ];
            dmgMin = _WeaponDmgMin( weapon, use );
            dmgMax = _WeaponDmgMax( weapon, use );
            dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1;               // technically, should be *2
            dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;                // technically, should be *2
            bt = targetc.Stat[ ST_BODY_TYPE ];

            if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
                targetDT /= 5;
            targetDR += ( ( npc.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
            if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
                totalDmg += 15;
            if( validAmmo )
                targetDR += ammo.Ammo_DrMod;
            targetDR = CLAMP( targetDR, 0, 100 );

            totalDmg = ( dmgMax + dmgMin + 2 * npc.Perk[ PE_BONUS_RANGED_DAMAGE ] ) / 2;
            totalDmg *= dmgMul;
            if( dmgDiv != 0 )
                totalDmg /= dmgDiv;
            totalDmg -= targetDT;
            totalDmg -= ( totalDmg * targetDR ) / 100;
            totalDmg *= ammoCount;
            if( totalDmg < 0 )
                totalDmg = 0;
            if( npc.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( bt == BT_ALIEN || bt == BT_ROBOT ) )
                totalDmg += 15;
            if( npc.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
                totalDmg += 20;
            totalDmg -= ( totalDmg * npc.Perk[ PE_TOUGHNESS ] * 5 ) / 100;

            if( targetc.IsNpc() && npc.Stat[ ST_TEAM_ID ] == targetc.Stat[ ST_TEAM_ID ] && targetc.Stat[ ST_TEAM_ID ] != 0 )
                Value1 -= totalDmg;
            else
                Value1 += totalDmg;
        }
        Value0 = Value1;

        target.Say( SAY_NETMSG, "Value0 " + Value0 );
    }
    else
    {
        if( hp > 0 && totalDmg > 0 )
        {
            Value0 = ( totalDmg > hp ) ? 1 : ( hp / totalDmg + ( ( hp % totalDmg == 0 ) ? 0 : 1 ) );

            if( !Zone_Attack( npc, target.HexX, target.HexY, SLOT_HAND1 ) )
            {
                int add = map.GetPathLength( npc, target.HexX, target.HexY, 1 );
                if( add == 0 && !( ( valid( weapon ) && _WeaponSkill( weapon, use ) == SK_UNARMED ) || !valid( weapon ) ) )
                    add = 100;
                Value0 += add * ( ( ( valid( weapon ) && _WeaponSkill( weapon, use ) == SK_UNARMED ) || !valid( weapon ) ) ? 1 : 6 );
            }
            Value0 *= 100;

            if( Zone_Attack( target, npc.HexX, npc.HexY, SLOT_HAND1 ) )
                Value0 /= 2;

        }
        target.Say( SAY_NETMSG, "Value0 " + Value0 );
    }
}

void AddItemToItem( Critter& cr, int pid, int c, int s )
{
    Item@ it = _CritGetItemHand( cr );
    it.AddItem( pid, c, s );
}

void SetWait( Critter& player, int param0, int param1, int param3 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    target.Wait( param1 );
}

void MerkDebug( Critter& cr, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, cr.Id ) );

    if( param1 == 0 )
    {
        array< uint > ids;
        for( uint i = 0, iEnd = target.GetMercIds( ids ); i < iEnd; i++ )
        {
            Critter@ merc = GetCritter( ids[ i ] );
            if( !valid( merc ) )
            {
                target.FreeMercSlot( i-- );
                iEnd--;
                target.Say( SAY_NETMSG, "You lose merc" );
            }
            else
                target.Say( SAY_NETMSG, "Valid merc " + ids[ i ] );
        }
    }
}

//  ~run debug GetAp 0 0 0
void GetAp( Critter& cr, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, cr.Id ) );

    cr.Say( SAY_NETMSG, "Action point " + ( param1 == 0 ? cr.Stat[ ST_CURRENT_AP ] : cr.StatBase[ ST_CURRENT_AP ] ) );
}

void GetItem( Critter& cr, int param0, int param1, int param2 )
{
	GetItem( param0 );
}

void TrashMap( Critter& critter, int param0, int param1, int param2 )
{
    Map@ map = critter.GetMap();
	
	for( uint16 x = critter.HexX - param0; x < critter.HexX + param0; x++ )
	{
		for( uint16 y = critter.HexY - param0; y < critter.HexY + param0; y++ )
		{
			for( uint c = 0, cend = Random( 5, 20 ); c < cend; c++ )
			{
				uint pid = Random(1,3000); 
				if( GetProtoItem( pid ) !is null )
					map.AddItem( x, y, pid, Random ( 10, 30 ) );
			}
		}
	}
}

# pragma interface "TestIface"
# pragma interface "TestIface uint get_Id ( )"

# pragma funcdef "void TestCreateFuncdef ( ) "

class TestEngineIface : TestIface
{
	uint get_Id ( ) override
	{
		return 10;
	}
}

class Test1
{
	bool IsOk;

	Test1( )
	{
		TestIface@ iface = TestIface::Create( "debug", "TestEngineIface" );
		IsOk = iface.Id == 10;
		
		TestCreateFuncdef@ function = TestCreateFuncdef::Create( "debug", "TestCreateFunction", "return;", "generation_section" );
		if( function !is null ) function();
		
		@ function = TestCreateFuncdef::Get( "debug", "TestCreateFunction" );
		if( function !is null ) function();
	}
}

void CheckArmor( Critter& critter, int, int, int )
{
	Item@ armor = critter.GetItem( 0, SLOT_ARMOR );
	Log( "AntiCrit " + armor.ArmorBonus_CriticalResist );
	Log( "Critter bonus " + critter.MyBonusBase[ARMOR_BONUS_CRITICAL_RESISTANCE] + " " + critter.MyBonus[ARMOR_BONUS_CRITICAL_RESISTANCE] );
	Log( "Critter anticrit " + critter.StatBase[ST_CRITICAL_RESISTANCE] + " " + critter.Stat[ST_CRITICAL_RESISTANCE] );
	// Log( "AntiCrit proto " + armor.ArmorBonus_CriticalResist );
}

void CheckItemStack( Critter& critter, int, int, int )
{
	Item@ item = critter.GetItem( 0, SLOT_HAND1 );
	Item@ item2 = critter.GetItem( 0, SLOT_HAND2 );
	
#define CHECK_ITEM_STACK_DATA #( data ) Log( "iemstack " + item.data + " " + item2.data )
	CHECK_ITEM_STACK_DATA( AmmoCount );
	CHECK_ITEM_STACK_DATA( HolodiskNumber );
	CHECK_ITEM_STACK_DATA( RadioFlags );
	CHECK_ITEM_STACK_DATA( RadioBroadcastSend );
	CHECK_ITEM_STACK_DATA( RadioBroadcastRecv );
	CHECK_ITEM_STACK_DATA( RadioChannel );
	CHECK_ITEM_STACK_DATA( Charge ) ;
	CHECK_ITEM_STACK_DATA( LockerComplexity ) ;
	CHECK_ITEM_STACK_DATA( LockerCondition );
	CHECK_ITEM_STACK_DATA( LockerId );
	CHECK_ITEM_STACK_DATA( AmmoPid );
	CHECK_ITEM_STACK_DATA( Deterioration );
	CHECK_ITEM_STACK_DATA( Indicator ) ;
	CHECK_ITEM_STACK_DATA( BrokenFlags ) ;
	CHECK_ITEM_STACK_DATA( BrokenCount );
	CHECK_ITEM_STACK_DATA( LightColor );
	CHECK_ITEM_STACK_DATA( LightFlags );
	CHECK_ITEM_STACK_DATA( LightDistance );
	CHECK_ITEM_STACK_DATA( LightIntensity );
	CHECK_ITEM_STACK_DATA( TrapValue ) ;
	CHECK_ITEM_STACK_DATA( Flags );
	CHECK_ITEM_STACK_DATA( Val0 ) ;
	CHECK_ITEM_STACK_DATA( Val1 ) ;
	CHECK_ITEM_STACK_DATA( Val2 ) ;
	CHECK_ITEM_STACK_DATA( Val3 );
	CHECK_ITEM_STACK_DATA( Val4 ) ;
	CHECK_ITEM_STACK_DATA( Val5 ) ;
	CHECK_ITEM_STACK_DATA( Val6 );
	CHECK_ITEM_STACK_DATA( Val7 ) ;
	CHECK_ITEM_STACK_DATA( Val8 ) ;
	CHECK_ITEM_STACK_DATA( Val9 );
	CHECK_ITEM_STACK_DATA( Info ) ;
	CHECK_ITEM_STACK_DATA( PicMap ) ;
	CHECK_ITEM_STACK_DATA( PicInv );
	CHECK_ITEM_STACK_DATA( CrafterId );
	CHECK_ITEM_STACK_DATA( WeaponBonus_MinDamage );
	CHECK_ITEM_STACK_DATA( WeaponBonus_MaxDamage );
	CHECK_ITEM_STACK_DATA( WeaponBonus_Critroll ) ;
	CHECK_ITEM_STACK_DATA( WeaponBonus_ToHit ) ;
	CHECK_ITEM_STACK_DATA( WeaponBonus_CritChance );
	CHECK_ITEM_STACK_DATA( WeaponBonus_AP );
	CHECK_ITEM_STACK_DATA( ArmorBonus_DRNormal ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DRLaser ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DRFire );
	CHECK_ITEM_STACK_DATA( ArmorBonus_DRPlasma ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DRElectr ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DRExplode );
	CHECK_ITEM_STACK_DATA( ArmorBonus_DTNormal ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DTLaser ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DTFire );
	CHECK_ITEM_STACK_DATA( ArmorBonus_DTPlasma ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DTElectr ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_AC );
	CHECK_ITEM_STACK_DATA( ArmorBonus_DTExplode ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DRRad ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_CarryWeight );
	CHECK_ITEM_STACK_DATA( ArmorBonus_FasterHealing ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_Harisma );
	CHECK_ITEM_STACK_DATA( ArmorBonus_Perception );
	CHECK_ITEM_STACK_DATA( ArmorBonus_Strength ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_CriticalResist ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_Luck );
	CHECK_ITEM_STACK_DATA( ArmorBonus_AP ) ;
	CHECK_ITEM_STACK_DATA( ArmorBonus_DeteriorateResist );
#undef CHECK_ITEM_STACK_DATA
}
