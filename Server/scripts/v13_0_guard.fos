// Name: v13_0_guard
// Author: Sufir
// Edited by:

// Uses
#include "_macros.fos"
#include "pids_groups.fos"
#include "utils_for_array.fos"
#include "v13_0_guard_h.fos"
#include "v13_guard_lib.fos"
#include "v13_q_dclaw_lib.fos"
#include "merc_h.fos"
import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";
import bool AddMiscPlane( Critter& npc, uint priority, uint waitSecond, string@ funcName ) from "npc_planes";
import uint GetPlayerMercs( Critter& player, Critter@[]& mercs ) from "merc";
import void CancelMerc( Critter& merc ) from "merc";

// Defines
uint[] player_warned = {};
uint[] player_ban = {};
uint[] player_done = {};
#define QUEST_TIMEOUT    ( 0.5 )        // Переодичность, в игровых сутках, с которой квест "Добыть самку" дается игрокам.
uint QuestAllowTime = 0;


void _GuardInit( Critter& guard, bool firstTime )
{

    guard.ModeBase[ MODE_NO_SUPPLY ] = 1;
    guard.SetEvent( CRITTER_EVENT_IDLE,                              "e_GuardIdle" );
    guard.SetEvent( CRITTER_EVENT_HIDE_CRITTER,              "e_GuardHide" );
    guard.SetEvent( CRITTER_EVENT_SMTH_DROP_ITEM,    "e_GuardMined" );

}


// Ищем беспредельщиков, предупреждаем и непослушных убиваем.
void e_GuardIdle( Critter& guard )
{

    // Ищем игроков.
    Critter@[] players;
    guard.GetCritters( false, FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, players );
    if( players.length() > 0 )
    {
        for( uint i = 0, iMax = players.length(); i < iMax; i++ )
        {
            // Если игроки найдены, видны охраннику и у них в руках оружие.
            if( players[ i ].IsPlayer() && players[ i ].IsSeenBy( guard ) && players[ i ].StatBase[ ST_CURRENT_HP ] > 0 )
            {
                // Если игрок в списке нарушителей - агрим на него охрану. Если он убрал оружие - убираем из списка.
                if( player_ban.find( players[ i ].Id ) >= 0 )
                {
                    if( SearchWeapon( _CritGetItemHand( players[ i ] ) ) )
                    {
                        // Отдаём приказ атаковать нарушителя.
                        guard.SendMessage( MSG_V13_GUARD_ALARM, players[ i ].Id, MESSAGE_TO_WHO_SEES_ME );
                        guard.SayMsg( SAY_SHOUT_ON_HEAD, TEXTMSG_DLG, DLGSTR( guard.Stat[ ST_DIALOG_ID ], 1 ) );
                        // guard.AddEnemyInStack(players[i].Id);
                    }
                    else
                    {
                        player_ban.removeAt( uint( player_ban.find( players[ i ].Id ) ) );
                        guard.SayMsg( SAY_NORM_ON_HEAD, TEXTMSG_DLG, DLGSTR( guard.Stat[ ST_DIALOG_ID ], 3 ) );
                    }
                }
                // Проверяем занесён-ли игрок в список предупреждённых и соответственно добавляем туда или убираем...
                if( player_warned.find( players[ i ].Id ) >= 0 && player_ban.find( players[ i ].Id ) < 0 )
                {
                    if( SearchWeapon( _CritGetItemHand( players[ i ] ) ) )
                    {
                        guard.SayMsg( SAY_SHOUT_ON_HEAD, TEXTMSG_DLG, DLGSTR( guard.Stat[ ST_DIALOG_ID ], 2 ) );
                        player_ban.insertLast( players[ i ].Id );
                    }
                    else
                    {
                        player_warned.removeAt( uint( player_warned.find( players[ i ].Id ) ) );
                        guard.SayMsg( SAY_NORM_ON_HEAD, TEXTMSG_DLG, DLGSTR( guard.Stat[ ST_DIALOG_ID ], 3 ) );
                    }
                }
                else if( player_warned.find( players[ i ].Id ) < 0 && player_ban.find( players[ i ].Id ) < 0 )
                {
                    if( SearchWeapon( _CritGetItemHand( players[ i ] ) ) )
                    {
                        player_warned.insertLast( players[ i ].Id );
                        guard.SayMsg( SAY_NORM_ON_HEAD, TEXTMSG_DLG, DLGSTR( guard.Stat[ ST_DIALOG_ID ], 2 ) );
                    }
                }

            }

        }
    }
    return;

}


// Если игрок пропал из поля зрения, убираем его из списков предупреждённых.
void e_GuardHide( Critter& npc, Critter& player )
{

    if( player.IsNpc() )
        return;
    player_ban.removeAt( uint( player_ban.find( player.Id ) ) );
    player_warned.removeAt( uint( player_warned.find( player.Id ) ) );
    return;

}


// Охранник болезненно реагирует на попытку минирования и отдаёт приказ солдатам на атаку.
void e_GuardMined( Critter& guard, Critter& dropper, Item& item )
{

    // if(!guard.IsNoPlanes()) return;
    if( !valid( dropper ) )
        return;
    if( dropper.IsNpc() )
        return;
    if( !dropper.IsLife() )
        return;
    // Заминировать нас не так-то просто, нужно быть действительно мастером и удачливым ловкачем.
    if( IsMined( guard, item, dropper, guard.StatBase[ ST_PERCEPTION ] * 20, Pids_MiscActiveExplosions ) )
    {
        // player_ban.insertLast(dropper.Id);
        guard.SendMessage( MSG_V13_GUARD_KILL, dropper.Id, MESSAGE_TO_WHO_SEES_ME );
        guard.SayMsg( SAY_SHOUT_ON_HEAD, TEXTMSG_DLG, DLGSTR( guard.Stat[ ST_DIALOG_ID ], 1 ) );
    }
    return;

}


/*===================Триггеры===================*/


// Открываем диалог с игроком.
void t_Frontier( Critter& player, Scenery& trigger, bool entered, uint8 dir )
{

    if( player.IsNpc() )
        return;
    if( !entered )
        return;
    if( HaveAccess( player ) )
        return;

    Critter@ guard = player.GetMap().GetNpc( ROLE_GUARDIAN, FIND_LIFE | FIND_ONLY_NPC, 0 );
    if( !valid( guard ) )
        return;

    if( !guard.IsLife() )
        return;

    if( player.ModeBase[ MODE_HIDE ] > 0 || !player.IsSeenBy( guard ) )
    {
        // Можно пробраться в скрытности. Чем выше навык и удача, тем шанс больше.
        if( player.Skill[ SK_SNEAK ] / 3 >= Random( 60, 100 ) - player.Stat[ ST_LUCK ] )
        {
            // Разрешаем игроку пройти в убежище.
            AllowAccess( player );
            return;
        }
        else
        {
            // Открываем диалог с неудачно попытавшимся пробраться.
            player.Wait( 0 );
            Mk2RunDialog( player, guard, true );
            return;
        }
    }
    else
    {
        // Если игрок не прячется - просто откроем диалог.
        player.Wait( 0 );
        Mk2RunDialog( player, guard, true );
        return;
    }

}


// Проход в убежище. Если идём внутрь и нет пропуска - атака.
void t_Entrance( Critter& player, Scenery& trigger, bool entered, uint8 dir )
{

    if( player.IsNpc() )
        return;
    if( !entered )
        return;
    if( dir == 2 || dir == 3 )
        return;

    Critter@ guard = player.GetMap().GetNpc( ROLE_GUARDIAN, FIND_LIFE | FIND_ONLY_NPC, 0 );
    if( !valid( guard ) )
        return;

    // Если гвардян не жив, значит можно всем проходить спокойно.
    if( !guard.IsLife() )
        return;

    if( !HaveAccess( player ) )
    {
        guard.SendMessage( MSG_V13_GUARD_KILL, player.Id, MESSAGE_TO_WHO_SEES_ME );
        guard.SayMsg( SAY_SHOUT_ON_HEAD, TEXTMSG_DLG, DLGSTR( guard.Stat[ ST_DIALOG_ID ], 1 ) );
    }
    return;

}


// Проход в убежище. Если идём внутрь и нет пропуска - атака.
/*void t_Exit(Critter& player, Scenery& trigger, bool entered, uint8 dir)
   {

        if(player.IsNpc()) return;
        if(!entered) return;
        if(dir==2 || dir==3) {
                if(FindInArray(player_done, player.Id)<0){
                        player_done.insertLast(player.Id);
                }
        }

        return;

   }*/


/*===================Диалоги===================*/


// Разрешаем игроку пройти в убежище.
void r_AllowAccess( Critter& player, Critter@ npc )
{

    AllowAccess( player );
    return;

}


// Разрешаем игроку пройти в убежище.
uint r_GuardDialog( Critter& player, Critter@ npc )
{

    // Если есть пропуск и броня - не позволяем пронести только взрывчатку.
    // В противном случае не позволяем проносить и любое оружие.
    //

    // Если в руках игрока оружие.
    /*if(SearchWeapon(_CritGetItemHand(player))){
            return 1;
       // Если в инвентаре запрещенные предметы - взрывчатка.
       } else if(EquipmentInspection(player, Pids_MiscExplosions) || EquipmentInspection(player, Pids_MiscActiveExplosions)){
            return 2;
       }  else if(EquipmentInspection(player, Pids_MiscExplosions) || EquipmentInspection(player, Pids_MiscActiveExplosions)){
            return 2;
       }*/
    if( player.ModeBase[ MODE_HIDE ] == 1 )
    {
        // player.ModeBase[MODE_HIDE]=0;
        return 100;
    }
    else if( SearchWeapon( _CritGetItemHand( player ) ) )
    {
        return 101;
    }
    return 2;

}


// Запуск квеста "Добыть самку".
void r_StartQuest( Critter& player, Critter@ npc )
{

    player.AddItem( PID_ROPE, 1 );
    Item@ Collar = player.AddItem( PID_PSYCHIC_NULLIFIER, 1 );
    if( !valid( Collar ) )
        return;
    Collar.SetScript( "q_item_v13_collar@_CollarInit" );
    Collar.Update();
    int[] ChangeStages = { 0, 3, 5 };
    SetGroupQuestStage( player, ChangeStages, 1 );
    // Устанавливаем таймаут для квеста. Квест не может быть взят другими игроками ранее чем через QUEST_TIMEOUT суток.
    QuestAllowTime = __FullSecond + uint( 60 * 60 * 24 * QUEST_TIMEOUT );

}


// Завершаем квест.
void r_QuestDone( Critter& player, Critter@ npc )
{

    Critter@[] group;
    Critter@ leader = GetCritter( GetLeaderId( player ) );
    group.insertLast( @leader );
    leader.GetFollowGroup( FIND_ALL, group );

    for( uint i = 0, iMax = group.length(); i < iMax; i++ )
    {
        // Если в группе есть НПС, а он есть, если самка поймана, - пропускаем его.
        if( group[ i ].IsPlayer() )
        {

            if( GetQuestStage( group[ i ] ) == 2 )
            {
                Critter@[] mercs;
                if( GetPlayerMercs( group[ i ], mercs ) > 0 )
                {
                    for( uint n = 0, nMax = group.length(); n < nMax; n++ )
                    {
                        if( mercs[ n ].StatBase[ ST_NPC_ROLE ] == 1001 )
                        {

                            CancelMerc( mercs[ n ] );
                            group[ i ].StatBase[ ST_EXPERIENCE ] += 8000;
                            // ToDo: Сделать, что-бы один из солдат приходил и забирал самку.
                            /*if(valid(npc)){
                                    guard.SendMessage(MSG_V13_GUARD_DCLAW, players[i].Id, MESSAGE_TO_WHO_SEES_ME);
                               } else {
                                    GetFreeHex(Map& map, uint radius, uint16& hx, uint16& hy);
                                    player.GetMap().GetEntireCoords(250, uint8 num, uint16& hexX, uint16& hexY);

                               }*/
                            uint16 x = 0, y = 0;
                            if( player.GetMap().GetEntireCoords( 250, 0, x, y ) )
                            {
                                // GetFreeHex(player.GetMap(), 1, x, y);
                                AddWalkPlane( mercs[ n ], 10, x, y, 0, false, 0 );
                                AddMiscPlane( mercs[ n ], 5, 0, "q_npc_v13_dclaw@DclawFinish" );
                            }
                            else
                            {}
                            //
                            SetQuestStage( group[ i ], 4 );

                        }
                    }
                }
            }

        }
    }
    return;

}


// Проверяем на наличие оружия вруках.
/*bool d_SearchWeapon(Critter& player, Critter@ npc)
   {

        return SearchWeapon(_CritGetItemHand(player));

   }


   // Проверяем на наличие запрещённых предметов в инвентаре.
   bool d_EquipmentInspection(Critter& player, Critter@ npc)
   {

        if(EquipmentInspection(player, Pids_MiscExplosions) || EquipmentInspection(player, Pids_MiscActiveExplosions)){
                return true;
        }
        return false;

   }*/


// Проверяем наличие, размер и сосав группы для квеста "Добыть самку".
bool d_GroupCheck( Critter& player, Critter@ npc )
{

    return GroupCheck( player );

}


// Проверяем наличие, размер и сосав группы для квеста "Добыть самку".
bool d_GroupNotCheck( Critter& player, Critter@ npc )
{

    if( GroupCheck( player ) )
    {
        return false;
    }
    else
    {
        return true;
    }

}


// Проверка - потерян ли ошейник.
bool d_CollarLost( Critter& player, Critter@ npc )
{

    if( GetQuestStage( player ) == 3 )
    {
        return true;
    }
    return false;

}


// Проверяем был ли квест уже взят участниками группы. Если более чем половина участников уже брали квест - не даём.
// Те кто выполнил квест могут участвовать и помогать, но не получат опыта и награды.
bool d_QuestCheck( Critter& player, Critter@ npc )
{

    // Проверяем как давно квест брался другими игроками
    if( QuestAllowTime > __FullSecond )
        return false;
    // Находим группу в которой состоит игрок и лидера этой группы.
    Critter@[] group;
    Critter@ leader = GetCritter( GetLeaderId( player ) );
    group.insertLast( @leader );
    leader.GetFollowGroup( FIND_ALL, group );
    uint QuestDone = 0;
    for( uint i = 0, iMax = group.length(); i < iMax; i++ )
    {
        // Если в группе есть НПС - пропускаем его, он может быть любого уровня.
        if( group[ i ].IsPlayer() )
        {
            // Если игроки уже брали квест.
            if( GetQuestStage( group[ i ] ) != 0 )
                QuestDone += 1;
        }
    }
    if( QuestDone <= group.length() / 2 )
    {
        return true;
    }
    return false;

}


// Проверяем в броне ли игрок.
bool d_ArmorCheck( Critter& player, Critter@ npc )
{

    Item@[] PlayerArmor;
    if( player.GetItems( SLOT_ARMOR, PlayerArmor ) <= 0 )
        return false;
    if( PlayerArmor.length() == 1 )
    {
        if( !valid( PlayerArmor[ 0 ] ) )
            return false;
        if( PlayerArmor[ 0 ].GetProtoId() == PID_ADVANCED_POWER_ARMOR || PlayerArmor[ 0 ].GetProtoId() == PID_ADVANCED_POWER_ARMOR_MK2 )
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    return false;

}


// Проверяем выполнен ли квест.
bool d_QuestDone( Critter& player, Critter@ npc )
{

    Critter@[] group;
    Critter@ leader = GetCritter( GetLeaderId( player ) );
    group.insertLast( @leader );
    leader.GetFollowGroup( FIND_ALL, group );
    for( uint i = 0, iMax = group.length(); i < iMax; i++ )
    {
        // Если в группе есть НПС, а он есть, если самка поймана, - пропускаем его.
        if( group[ i ].IsPlayer() )
        {
            if( GetQuestStage( group[ i ] ) == 2 )
            {
                Critter@[] mercs;
                if( GetPlayerMercs( group[ i ], mercs ) > 0 )
                {
                    for( uint n = 0, nMax = group.length(); n < nMax; n++ )
                    {
                        if( mercs[ n ].StatBase[ ST_NPC_ROLE ] == 1001 )
                            return true;
                    }
                }
            }
        }
    }
    return false;

}


/*===================ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ===================*/


// Проверяем группу. Минимальный размер и колличество игроков.
bool GroupCheck( Critter& player )
{

    uint minPlayers = 2;
    int  groupLvl = 0;

    // Находим группу в которой состоит игрок и лидера этой группы.
    Critter@[] group;
    Critter@ leader = GetCritter( GetLeaderId( player ) );
    group.insertLast( @leader );
    leader.GetFollowGroup( FIND_ALL, group );

    // Проверяем размер группы в которой состоит игрок берущий квест. Если игроков менее minPlayers возвращаем false.
    if( group.length() < minPlayers )
    {
        return false;
    }

    // Проверяем уровни группы в которой состоит игрок берущий квест.
    for( uint i = 0, iMax = group.length(); i < iMax; i++ )
    {
        // Если в группе есть НПС - пропускаем его, он может быть любого уровня.
        if( group[ i ].IsPlayer() )
            groupLvl += group[ i ].Stat[ ST_LEVEL ];
	}

    // Если суммарный уровень группы менее 40 возвращаем false.
    if( groupLvl < 20 )
    {
        return false;
    }

    // Если группа прошла все проверки - возвращаем true.
    return true;

}


// Вспомогательная функция. Помещает Id игрока в массив допущенных в убежище.
void AllowAccess( Critter& player )
{

    if( !HaveAccess( player ) )
    {
        player_done.insertLast( player.Id );
    }
    return;

}


// Вспомогательная функция. Удаляет Id игрока из массива допущенных в убежище.
void DenyAccess( Critter& player )
{

    if( !HaveAccess( player ) )
    {
        player_done.removeAt( uint( GetAccessId( player ) ) );
    }
    return;

}


// Вспомогательная функция. Возвращает true если игрок допущен и false если отсутсвует в массиве допущенных.
bool HaveAccess( Critter& player )
{
    if( GetAccessId( player ) >= 0 )
    {
        return true;
    }
    return false;
}

// Вспомогательная функция. Возвращает ключ записи в массиве допущенных игроков.
int GetAccessId( Critter& player )
{
    if( !valid( player ) )
        return -1;
    for( uint i = 0, iMax = player_done.length(); i < iMax; i++ )
    {
        if( player_done[ i ] == player.Id )
        {
            return i;
        }
    }
    return -1;
}
