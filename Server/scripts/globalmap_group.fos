// Author: cvet
#include "_macros.fos"
#include "_maps.fos"
#include "_msgstr.fos"
#include "_math.fos"
#include "entire.fos"
#include "_offplayer.fos"
#include "worldmap_h.fos"

#define RADAR_VISIBLE        ( 58 )
#define GLOBAL_PVP_RADIUS    ( 50 )
#define GLOBAL_PVP_TICK      ( 100 )
import void               FindEncounter( Critter@[]& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer, bool empty ) from "worldmap";
import void               InviteToEncounter( Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir ) from "worldmap";
import CFoundedEncounter@ CFE_InviteToEncounter( Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir ) from "worldmap";
import uint               GetGlobalMapRelief( uint x, uint y ) from "worldmap";
import string@            GetFractionName( uint num ) from "Mk2";

uint[] trackerId = { 0, 0, 0, 0 };
uint[] tracked1, tracked2, tracked3, tracked4;

// //////////////////////////////////////////////////////////////////////////////////////////////////
// int processType    - see in Global map events in _defines.fos;
// Critter& cr        - who called this function, in most times is leader of group;
// Item@ car          - group car, can be null;
// float& curX, &curY - current position;
// float& toX, &toY   - destination position;
// float& speed       - speed of group, must set in GLOBAL_PROCESS_SET_MOVE,
//                      also you can type zero to stop group;
// uint encounterDescriptor - if encounterDescriptor !=0 than global_invite calls;
// bool waitForAnswer       - if waitForAnswer==false than global_invite calls after this function,
//                            else call after leader confirm invite;

void global_process( int processType, Critter& cr, Item@ car,
                     float& curX, float& curY, float& toX, float& toY, float& speed,
                     uint& encounterDescriptor, bool& waitForAnswer )
{
    int movementType = ( valid( car ) ? car.Proto.Car_MovementType : GM_WALK_GROUND ),
        curXi = int(curX),
        curYi = int(curY);

    if( processType != GLOBAL_PROCESS_ENTER && processType != GLOBAL_PROCESS_NPC_IDLE )
    {
        Critter@[] @ group = cr.GetGlobalGroup();
        if( valid( group ) )
        {
            bool isCheck = true;
            if( trackerId[ 0 ] != 0 )
            {
                Critter@ tracker = GetCritter( trackerId[ 0 ] );
                if( !valid( tracker ) )
                    trackerId[ 0 ] = 0;
                else if( isCheck && cr.WorldX < 701 && cr.WorldY < 751 )
                {
                    isCheck = false;
                    if( cr.GlobalGroupUid != tracker.GlobalGroupUid )
                    {
                        if( sqrt( POW2( int(cr.WorldX) - int(tracker.WorldX) ) + POW2( int(cr.WorldY) - int(tracker.WorldY) ) ) <= TRACK_RADIUS + tracker.Param[ PE_TRACKER ] * 25 )
                        {
                            TryAddTracked( 1, group[ 0 ].Id );
                        }
                    }
                }
            }

            if( trackerId[ 1 ] != 0 )
            {
                Critter@ tracker = GetCritter( trackerId[ 1 ] );
                if( !valid( tracker ) )
                    trackerId[ 1 ] = 0;
                else if( isCheck && cr.WorldX > 700 && cr.WorldY < 751 )
                {
                    isCheck = false;
                    if( cr.GlobalGroupUid != tracker.GlobalGroupUid )
                    {

                        if( sqrt( POW2( int(cr.WorldX) - int(tracker.WorldX) ) + POW2( int(cr.WorldY) - int(tracker.WorldY) ) ) <= TRACK_RADIUS + tracker.Param[ PE_TRACKER ] * 25 )
                        {
                            TryAddTracked( 2, group[ 0 ].Id );
                        }
                    }
                }
            }

            if( trackerId[ 2 ] != 0 )
            {
                Critter@ tracker = GetCritter( trackerId[ 2 ] );
                if( !valid( tracker ) )
                    trackerId[ 2 ] = 0;
                else if( isCheck && cr.WorldX < 701 && cr.WorldY > 750 )
                {
                    isCheck = false;
                    if( cr.GlobalGroupUid != tracker.GlobalGroupUid )
                    {

                        if( sqrt( POW2( int(cr.WorldX) - int(tracker.WorldX) ) + POW2( int(cr.WorldY) - int(tracker.WorldY) ) ) <= TRACK_RADIUS + tracker.Param[ PE_TRACKER ] * 25 )
                        {
                            TryAddTracked( 3, group[ 0 ].Id );
                        }
                    }
                }
            }

            if( trackerId[ 3 ] != 0 )
            {
                Critter@ tracker = GetCritter( trackerId[ 3 ] );
                if( !valid( tracker ) )
                    trackerId[ 3 ] = 0;
                else if( isCheck && cr.WorldX > 700 && cr.WorldY > 750 )
                {
                    isCheck = false;
                    if( cr.GlobalGroupUid != tracker.GlobalGroupUid )
                    {
                        if( sqrt( POW2( int(cr.WorldX) - int(tracker.WorldX) ) + POW2( int(cr.WorldY) - int(tracker.WorldY) ) ) <= TRACK_RADIUS + tracker.Param[ PE_TRACKER ] * 25 )
                        {
                            TryAddTracked( 4, group[ 0 ].Id );
                        }
                    }
                }
            }
        }
    }

    if( processType == GLOBAL_PROCESS_MOVE )
    {
        // Save current distantion to compare in the end
        float lastDist = DISTANCE( curX, curY, toX, toY ),

        // Calcuate speed
              speedPix = speed * float(__GlobalMapMoveTime) / 1000.0f,
              speedAngle = atan2( toY - curY, toX - curX ),
              speedX = cos( speedAngle ) * speedPix,
              speedY = sin( speedAngle ) * speedPix,

              speedMod = 1.0f;

        if( movementType == GM_WALK_GROUND )
        {
            // Speed modifiers
            //  F   E   D   C   B   A   9    8   7    6   5    4   3    2   1    0
            // 1.5 1.4 1.3 1.2 1.1 1.0 0.95 0.9 0.85 0.8 0.75 0.7 0.65 0.6 0.55 0.0
            switch( GetGlobalMapRelief( curXi, curYi ) )
            {
            case 0x0:
                speedMod = 1.00f;
                break;
            case 0x1:
                speedMod = 0.55f;
                break;
            case 0x2:
                speedMod = 0.60f;
                break;
            case 0x3:
                speedMod = 0.65f;
                break;
            case 0x4:
                speedMod = 0.70f;
                break;
            case 0x5:
                speedMod = 0.75f;
                break;
            case 0x6:
                speedMod = 0.80f;
                break;
            case 0x7:
                speedMod = 0.85f;
                break;
            case 0x8:
                speedMod = 0.90f;
                break;
            case 0x9:
                speedMod = 0.95f;
                break;
            case 0xA:
                speedMod = 1.00f;
                break;
            case 0xB:
                speedMod = 1.10f;
                break;
            case 0xC:
                speedMod = 1.20f;
                break;
            case 0xD:
                speedMod = 1.30f;
                break;
            case 0xE:
                speedMod = 1.40f;
                break;
            case 0xF:
                speedMod = 1.50f;
                break;
            default:
                break;
            }
        }

        if( valid( car ) && speedMod != 1.0f )
        {
            float pass = float(car.Proto.Car_Passability);
            if(    pass > 100.0f && speedMod < 1.0f )
                speedMod += ( 1.0f - speedMod ) * ( pass - 100.0f ) / 100.0f;
            else if( pass > 100.0f && speedMod > 1.0f )
                speedMod -= ( speedMod - 1.0f ) * ( pass - 100.0f ) / 100.0f;
            else if( pass < 100.0f && speedMod < 1.0f )
                speedMod -= ( 1.0f - speedMod ) * ( 100.0f - pass ) / 100.0f;
            else if( pass < 100.0f && speedMod > 1.0f )
                speedMod += ( speedMod - 1.0f ) * ( 100.0f - pass ) / 100.0f;
        }

        // Apply step
        curX += speedX * speedMod;
        curY += speedY * speedMod;

        int oldXi = curXi,
            oldYi = curYi;
        curXi = int(curX);       // Round
        curYi = int(curY);       // Round

        // Check new position
        if( oldXi != curXi || oldYi != curYi )
        {
            // Check borders
            int gmWidth = __GlobalMapWidth * __GlobalMapZoneLength,
                gmHeight = __GlobalMapHeight * __GlobalMapZoneLength;
            if( curXi < 0 || curYi < 0 || curXi >= gmWidth || curYi >= gmHeight )
            {
                if( curXi < 0 )
                    curXi = 0;
                else if( curXi >= gmWidth )
                    curXi = gmWidth - 1;
                if( curYi < 0 )
                    curYi = 0;
                else if( curYi >= gmHeight )
                    curYi = gmHeight - 1;

                // Stop group
                curX = float(curXi);
                curY = float(curYi);
                speed = 0.0f;
                return;
            }

            // Move from old to new and find last correct position
            int relief = GetGlobalMapRelief( oldXi, oldYi ),
                steps = MAX( ABS( curXi - oldXi ), ABS( curYi - oldYi ) ),
                newXi = oldXi,
                newYi = oldYi;

            if( steps > 0 )
            {
                float xx = float(oldXi),
                      yy = float(oldYi),
                      oxx = float(curXi - oldXi) / float(steps),
                      oyy = float(curYi - oldYi) / float(steps);

                for( int i = 0; i < steps; i++ )
                {
                    xx += oxx;
                    yy += oyy;
                    int xxi = int(xx >= 0.0f ? xx + 0.5f : xx - 0.5f),
                        yyi = int(yy >= 0.0f ? yy + 0.5f : yy - 0.5f);

                    uint relief_ = GetGlobalMapRelief( xxi, yyi );
                    if( movementType == GM_WALK_GROUND && relief != 0 && relief_ == 0 )
                        break;
                    if( movementType == GM_WALK_WATER && relief_ != 0 )
                        break;

                    newXi = xxi;
                    newYi = yyi;
                }
            }

            if( newXi != curXi || newYi != curYi )
            {
                // Stop group
                curX = float(newXi);
                curY = float(newYi);
                speed = 0.0f;
                return;
            }

            // Zone
            int oldZoneX = oldXi / __GlobalMapZoneLength,
                oldZoneY = oldYi / __GlobalMapZoneLength,
                curZoneX = curXi / __GlobalMapZoneLength,
                curZoneY = curYi / __GlobalMapZoneLength;

            // Change zone
            if( oldZoneX != curZoneX || oldZoneY != curZoneY )
            {
                Critter@[] @ group = cr.GetGlobalGroup();
                if( valid( group ) )
                    ScanZone( group, curZoneX, curZoneY );
            }

            // Check for complete travelling
            float curDist = DISTANCE( curX, curY, toX, toY );
            if( curDist <= 0.01f || curDist > lastDist )
            {
                curX = toX;
                curY = toY;
                speed = 0.0f;
                return;
            }
        }

        // Car processing
        if( valid( car ) )
        {
            int fuel = car.Charge,
                deterioration = car.Deterioration;

            if( fuel <= 0 || deterioration >= int(car.Proto.Car_MaxDeterioration) )
            {
                uint str = ( fuel <= 0 ? STR_CAR_FUEL_EMPTY : STR_CAR_BROKEN );
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, str );
                speed = 0.0f;
                return;
            }

            // Car values created for the call every 500 ms
            fuel -= car.Proto.Car_FuelConsumption * __GlobalMapMoveTime / 500;
            deterioration += car.Proto.Car_DeteriorationRate * __GlobalMapMoveTime / 500;
            if( fuel < 0 )
                fuel = 0;
            if( deterioration > int(car.Proto.Car_MaxDeterioration) )
                deterioration = int(car.Proto.Car_MaxDeterioration);

            if( fuel != int( car.Charge )  || deterioration != int( car.Deterioration ) )
            {
                car.Charge = fuel;
                car.Deterioration = deterioration;
                car.Update();
            }
        }
		cr.GlobalMapMoveCounter = cr.GlobalMapMoveCounter + 1;
        if( cr.GlobalMapMoveCounter % ( __EncounterTime / __GlobalMapMoveTime ) == 0 )
        {
            Critter@[] @ group = cr.GetGlobalGroup();
            if( valid( group ) )
            {
                uint16 bioCount = 0,
                       robotCount = 0;
                for( uint i = 0, iMax = group.length(); i < iMax; i++ )
                    if( group[ i ].Stat[ ST_BODY_TYPE ] == BT_ROBOT )
                        robotCount++;
                    else
                        bioCount++;

                // Validate charisma
                Critter@ leader = group[ 0 ];
                if( valid( car ) )
                {
                    if( bioCount > car.Proto.Car_CrittersCapacity )
                    {
                        leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CAR_CRIT_OVERLOAD );
                        speed = 0.0f;                       // Stop
                        return;
                    }
                }
                else if( int(bioCount - 4) > leader.Stat[ ST_CHARISMA ] + leader.Perk[ PE_MAGNETIC_PERSONALITY ] )
                {
                    leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CRIT_BAD_CHARISMA );
                    speed = 0.0f;                   // Stop
                    return;
                }
                if( int(robotCount) > leader.Stat[ ST_INTELLECT ] )
                {
                    leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CRIT_BAD_INTELLECT );
                    speed = 0.0f;                   // Stop
                    return;
                }

                // Try find encounter
                if( GetVisibleLocations( curXi, curYi, 0, cr, null ) == 0 )
                    FindEncounter( group, car, curXi, curYi, encounterDescriptor, waitForAnswer, false );
            }
        }
        Critter@[] @ group = cr.GetGlobalGroup();
        if( valid( group ) && cr.IsPlayer() )
        {
            bool noSeeLoc = true;
            Location@[] locations;
            for( uint i = 0, iEnd = GetLocations( cr.WorldX, cr.WorldY, 1, locations ); i < iEnd; i++ )
            {
                if( cr.IsKnownLoc( true, locations[ i ].Id ) )
                {
                    noSeeLoc = false;
                    break;
                }
            }

            if( noSeeLoc )
            {
                uint tick = GetTick();
                if( group[ 0 ].GlobalPVP_LastHunterTick + GLOBAL_PVP_TICK <= tick || tick < group[ 0 ].GlobalPVP_LastHunterTick )
                {
                    int maxLevel = 1;
                    for( uint n = 0; n < group.length(); n++ )
                    {
                        if( group[ n ].IsPlayer() && group[ n ].Stat[ ST_LEVEL ] > maxLevel )
                            maxLevel = group[ n ].Stat[ ST_LEVEL ];
                    }
                    Critter@[] crs;
                    GetGlobalMapCritters( cr.WorldX, cr.WorldY, GLOBAL_PVP_RADIUS / 2, FIND_ALL | FIND_ONLY_PLAYERS, crs );
                    if( Random( 0, 199 ) <= int( group.length() ) && crs.length() > 0 )
                    {
                        Critter@ target = crs[ Random( 0, crs.length() - 1 ) ];
                        uint     carId2 = target.GetGlobalGroupCarId();
                        if( valid( target ) && target.IsPlayer() && carId2 == 0 && target.GlobalGroupUid != cr.GlobalGroupUid )
                        {
                            Location@[] tarLocations;
                            for( uint i = 0, iEnd = GetLocations( target.WorldX, target.WorldY, 1, tarLocations ); i < iEnd; i++ )
                            {
                                if( target.IsKnownLoc( true, tarLocations[ i ].Id ) )
                                {
                                    noSeeLoc = false;
                                    break;
                                }
                            }

                            if( noSeeLoc )
                            {
                                Critter@[] @ group2 = target.GetGlobalGroup();
                                if( valid( group2 ) )
                                {
                                    int maxLevel2 = 1;
                                    for( uint n = 0; n < group2.length(); n++ )
                                    {
                                        if( group2[ n ].IsPlayer() && group2[ n ].Stat[ ST_LEVEL ] > maxLevel2 )
                                            maxLevel2 = group2[ n ].Stat[ ST_LEVEL ];
                                    }
                                    if( maxLevel2 < maxLevel )
                                        return;                                                        // TabaK. Не кошмарим нубов.
                                    Critter@ leadTarget = group2[ 0 ];
                                    if( valid( leadTarget ) )
                                    {
                                        // GLOBAL_PVP_TICK
                                        if( leadTarget.GlobalPVP_LastHunterId != group[ 0 ].Id || leadTarget.GlobalPVP_LastHunterTick != group[ 0 ].GlobalPVP_LastHunterTick )
                                        {
                                            // uint
                                            group[ 0 ].Say( SAY_FLASH_WINDOW, "" );
                                            group[ 0 ].GlobalPVP_TargetGroupLeadId = leadTarget.Id;
                                            leadTarget.GlobalPVP_PosX = leadTarget.WorldX;
                                            leadTarget.GlobalPVP_PosY = leadTarget.WorldY;
                                            // group[0].GlobalPVP_PosY = group[0].WorldY; GLOBAL_PVP_RADIUS
                                            FindEncounter( group, car, curXi, curYi, encounterDescriptor, waitForAnswer, true );
                                            leadTarget.GlobalPVP_LastHunterId = group[ 0 ].Id;
                                            leadTarget.GlobalPVP_LastHunterTick = tick;
                                            group[ 0 ].GlobalPVP_LastHunterTick = tick;
                                            waitForAnswer = true;
                                            string@ name = leadTarget.IsPlayer() ? GetPlayerName( leadTarget.Id ) : "@msg DLG " + STR_NPC_NAME( leadTarget.Stat[ ST_DIALOG_ID ], leadTarget.GetProtoId() ) + "@";
                                            group[ 0 ].SayMsg( SAY_ENCOUNTER_RT, TEXTMSG_GM, ( group2.length() > 1 ? STR_QUESTION_ONLY_PLAYERS : STR_QUESTION_ONLY_PLAYER ), "$player" + name );
                                        }
                                        // leadTarget.;
                                        /*const int    GlobalPVP_PosX;
                                           const int    GlobalPVP_PosY;
                                           const uint   GlobalPVP_LastHunterId;

                                           const uint   GlobalPVP_LastHunterTick;
                                           const uint   GlobalPVP_TargetGroupLeadId;*/
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    else if( processType == GLOBAL_PROCESS_ENTER )
    {
        // Enter to empty encounter
        if( movementType == GM_WALK_WATER && GetGlobalMapRelief( curXi, curYi ) == 0 )
        {
            // Find land
            bool      landFounded = false;
            const int maxx = __GlobalMapWidth * __GlobalMapZoneLength,
                      maxy = __GlobalMapHeight * __GlobalMapZoneLength;
            for( int ox = -1; ox <= 1; ox++ )
            {
                for( int oy = -1; oy <= 1; oy++ )
                {
                    int xx = curXi + ox,
                        yy = curYi + oy;
                    if( xx >= 0 && xx < maxx && yy >= 0 && yy < maxy && GetGlobalMapRelief( xx, yy ) != 0 )
                    {
                        FindEncounter( cr.GetGlobalGroup(), car, xx, yy, encounterDescriptor, waitForAnswer, true );
                        ox = oy = 2;                     // Exit from loop
                        landFounded = true;
                    }
                }
            }

            if( !landFounded )
                FindEncounter( cr.GetGlobalGroup(), car, curXi, curYi, encounterDescriptor, waitForAnswer, true );
        }
        else
            FindEncounter( cr.GetGlobalGroup(), car, curXi, curYi, encounterDescriptor, waitForAnswer, true );
    }
    else if( processType == GLOBAL_PROCESS_SET_MOVE )
    {
        Critter@[] @ group = cr.GetGlobalGroup();
        if( valid( group ) )
        {
            uint16 bioCount = 0,
                   robotCount = 0;
            for( uint i = 0, iMax = group.length(); i < iMax; i++ )
                if( group[ i ].Stat[ ST_BODY_TYPE ] == BT_ROBOT )
                    robotCount++;
                else
                    bioCount++;

            Critter@ leader = group[ 0 ];

            if( valid( car ) )
            {
                if( bioCount > car.Proto.Car_CrittersCapacity )
                {
                    leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CAR_CRIT_OVERLOAD );
                    speed = 0.0f;                   // Stop
                    return;
                }
            }
            else if( int(bioCount - 4) > leader.Stat[ ST_CHARISMA ] + leader.Perk[ PE_MAGNETIC_PERSONALITY ] )
            {
                leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CRIT_BAD_CHARISMA );
                speed = 0.0f;               // Stop
                return;
            }
            if( int(robotCount) > leader.Stat[ ST_INTELLECT ] )
            {
                leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CRIT_BAD_INTELLECT );
                speed = 0.0f;               // Stop
                return;
            }

            // Calculate speed
            speed = GLOBAL_MAP_BASE_SPEED;
            if( cr.IsPlayer() && cr.GetAccess() >= ACCESS_TESTER )
                speed *= 20.0f;                                                             // All, exclude clients have highly speed

            if( valid( car ) )
            {
                // Validate car
                uint strNum = 0;
                // if(group.length() > car.Proto.Car_CrittersCapacity) strNum=STR_CAR_CRIT_OVERLOAD;
                if( car.Charge == 0 )
                    strNum = STR_CAR_FUEL_EMPTY;
                else if( car.Deterioration >= car.Proto.Car_MaxDeterioration )
                    strNum = STR_CAR_BROKEN;
                if( strNum != 0 )
                {
                    leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, strNum );
                    speed = 0.0f;
                    if( valid( car ) )
                        CheckForLocationWithoutParking( cr, car, curX, curY );
                    return;
                }

                speed = car.Proto.Car_Speed * GLOBAL_MAP_BASE_SPEED / 20.0f;

                // Find near water for boats
                // In radius of one zone (left, top, right, bottom)
                if( car.Proto.Car_MovementType == GM_WALK_WATER )
                {
                    if( GetGlobalMapRelief( curXi, curYi ) != 0 )
                    {
                        const int   maxx = __GlobalMapWidth * __GlobalMapZoneLength,
                                    maxy = __GlobalMapHeight * __GlobalMapZoneLength;
                        const int[] ox = { -1,  0, 1, 0 },
                                    oy = { 0, -1, 0, 1 };
                        int         xx = 0, yy = 0;
                        for( int i = 1, ii = __GlobalMapZoneLength; i <= ii; i++ )
                        {
                            for( int j = 0; j < 4; j++ )
                            {
                                xx = curXi + ox[ j ] * i;
                                yy = curYi + oy[ j ] * i;
                                if( xx >= 0 && xx < maxx && yy >= 0 && yy < maxy && GetGlobalMapRelief( xx, yy ) == 0 )
                                {
                                    curX = float(xx);
                                    curY = float(yy);
                                    // Exit from loop
                                    i = ii;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                // Pathfinder perk bonus
                int   speedDiv = 100 - cr.Perk[ PE_PATHFINDER ] * 25;

                Item@ sensor = _CritGetItemHand( leader );
                if( @sensor == null || sensor.GetProtoId() != PID_ACTIVE_MOTION_SENSOR )
                    @sensor = _CritGetItemBonus( leader );
                if( valid( sensor ) && sensor.GetProtoId() == PID_ACTIVE_MOTION_SENSOR )
                    speedDiv += 70;

                if( speedDiv <= 0 )
                    speedDiv = 1;
                speed = speed * 100.0f / float(speedDiv);
            }

            if( cr.IsPlayer() && cr.Stat[ ST_FACTION ] != 0 )       // Бонус за владение Пилигримом
            {
                Location@ pilgrim = GetLocationByPid( LOCATION_Pilgrim, 0 );
                if( valid( pilgrim ) &&
                    pilgrim.GetMapByIndex( 0 ).GetData( 0 ) == cr.Stat[ ST_FACTION ] )
                    speed *= 1.25f;
            }

        }
    }
    /*else if(processType==GLOBAL_PROCESS_NPC_IDLE)
       {
            if(curX==toX && curY==toY)
            {
                    if( cr.Stat[ ST_ROLE_CITY ] == CITY_klamath_child && cr.CityRole[ CITY_ROLE_IM_HOME ] == 1 )
                    {
                            bool isNight = __Hour>=21 || __Hour<5;
                            if( not isNight )
                            {
                                    uint mapid = 0;
                                    uint16 var = 0;
                                    uint8 var0 = 0;
                                    cr.GetHomePos( mapid, var, var, var0 );
                                    Log( " mapid = " + mapid );
                                    cr.TransitToMap ( mapid, 0 );
                            }
                    }
            }
            // Critter& cr - is npc who call idle
            // Process npc group on global map
            //if(curX==toX && curY==toY) // Stopped
            {
                    // If you want enter to location under group than type
                    // encounterDescriptor=uint(-1);
                    // waitForAnswer=false;
            }
       }*/
    else if( processType == GLOBAL_PROCESS_KICK )
    {
        if( GetGlobalMapRelief( curXi, curYi ) == 0 )
        {
            // Say to leader
            Critter@[] @ group = cr.GetGlobalGroup();
            if( valid( group ) )
                group[ 0 ].SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CANT_KICK_ON_WATER );
            return;
        }

        cr.LeaveGlobalGroup();
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on invite to encaunter.
// If mapId !=0 than group enter to it.
void global_invite( Critter& leader, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir )
{
    // Enter to map under group
    if( encounterDescriptor == uint( -1 ) )
    {
        Location@[] locations;
        if( GetLocations( leader.WorldX, leader.WorldY, 0, locations ) != 0 )
        {
            Location@ loc = locations[ 0 ];
            Map@      map = loc.GetMapByIndex( 0 );
            if( valid( map ) && map.GetEntireCoords( 0, 0, hexX, hexY ) )
            {
                mapId = map.Id;
                dir = 0xFF;
            }
        }
        return;
    }

    // Find encounter

    if( leader.GlobalPVP_TargetGroupLeadId != 0 )
    {
        Critter@ target = GetCritter( leader.GlobalPVP_TargetGroupLeadId );
        leader.GlobalPVP_TargetGroupLeadId = 0;
        if( valid( target ) && not valid( target.GetMap() ) && DISTANCE( target.WorldX, target.WorldY, leader.WorldX, leader.WorldY ) <= GLOBAL_PVP_RADIUS )
        {
            CFoundedEncounter@ fe = CFE_InviteToEncounter( leader.GetGlobalGroup(), car, encounterDescriptor, combatMode, mapId, hexX, hexY, dir );
            if( valid( fe ) )
            {
                // target.GlobalPVP_PosX
                // target.GlobalPVP_PosY
                // group[0].GlobalPVP_PosY = group[0].WorldY; GLOBAL_PVP_RADIUS
                Critter@[] @ group2 = target.GetGlobalGroup();
                if( valid( group2 ) )
                {
                    Map@ map = GetMap( mapId );
                    if( valid( map ) )
                    {
                        uint16 targetHexX = 0, targetHexY = 0;
                        map.GetEntireCoords( 0, Random( 0, map.CountEntire( 0 ) - 1 ), targetHexX, targetHexY );
                        for( uint i = 0, iEnd = group2.length(); i < iEnd; i++ )
                        {
                            group2[ i ].Say( SAY_FLASH_WINDOW, "" );
                            targetHexX = Random( targetHexX - 5, targetHexX + 5 );
                            targetHexY = Random( targetHexY - 5, targetHexY + 5 );
                            group2[ i ].TransitToMap( mapId,  targetHexX,  targetHexY,  0 );
                        }
                    }
                }
            }
        }
        else
            mapId = 0;
        return;
    }
    else
        InviteToEncounter( leader.GetGlobalGroup(), car, encounterDescriptor, combatMode, mapId, hexX, hexY, dir );
}

void ScanZone( Critter@[]& group, int zx, int zy )
{
    uint[] locIds1, locIds2;
    bool locIds2Founded = false;

    GetZoneLocationIds( zx, zy, 1, locIds1 );

    for( uint i = 0, iMax = group.length(); i < iMax; i++ )
    {
        Critter@ cr = group[ i ];
        if( cr.IsNpc() )
            continue;

        int lookLen = cr.PerkBase[ PE_SCOUT ] != 0 ? 2 : 1;

        if( lookLen == 2 && !locIds2Founded )
        {
            GetZoneLocationIds( zx, zy, 2, locIds2 );
            locIds2Founded = true;
        }

        // Open fog
        int mapw = __GlobalMapWidth;
        int maph = __GlobalMapHeight;
        for( int x = -lookLen; x <= lookLen; x++ )
        {
            for( int y = -lookLen; y <= lookLen; y++ )
            {
                int zx_ = zx + x;
                int zy_ = zy + y;
                if( zx_ >= 0 && zx_ < mapw && zy_ >= 0 && zy_ < maph )
                {
                    int fog = ( zx == zx_ && zy == zy_ ? FOG_NONE : FOG_HALF );
                    if( cr.GetFog( zx_, zy_ ) < fog )
                        cr.SetFog( zx_, zy_, fog );
                }
            }
        }

        // Find new locations
        uint[] @ locIds = lookLen == 1 ? locIds1 : locIds2;
        for( uint j = 0, jMax = locIds.length(); j < jMax; j++ )
        {
            uint locId = locIds[ j ];
            if( !cr.IsKnownLoc( true, locId ) )
            {
                Location@ loc = GetLocation( locId );
                if( valid( loc ) )
                    cr.SetKnownLoc( true, locId );
            }
        }
    }
}

void CheckForLocationWithoutParking( Critter& cr, Item& car, float& curX, float& curY )
{
    Location@[] locations;
    if( GetVisibleLocations( int( curX ), int( curY ), 0, cr, locations ) != 0 )
    {
        Location@ loc = locations[ 0 ];
        Map@      map = loc.GetMapByIndex( 0 );

        bool      placeFounded = false;
        Entire[] entires;
        ParseEntires( map, entires, car.Proto.Car_Entrance );
        for( uint i = 0, iMax = entires.length(); i < iMax; i++ )
        {
            if( map.CheckPlaceForItem( entires[ i ].HexX, entires[ i ].HexY, car.GetProtoId() ) )
            {
                placeFounded = true;
                break;
            }
        }

        if( !placeFounded )
        {
            curX = loc.WorldX + int(loc.Radius) * ( Random( 0, 1 ) == 0 ? int(1) : int(-1) );
            curY = loc.WorldY + int(loc.Radius) * ( Random( 0, 1 ) == 0 ? int(1) : int(-1) );
        }
    }
}

// TabaK. Слежка.
void CheckTracker( Critter& cr )
{
    if( cr.IsPlayer() )
    {
        if( cr.Mode[ MODE_TRACKER ] < 0 )
        {
            cr.RunClientScript( "client_main@__SetTrack", -1, 0, 0, null, null );
            cr.EraseTimeEvents( CTE_TRACK );
        }
        else
        {
            if( trackerId[ cr.Mode[ MODE_TRACKER ] ] == cr.Id )
            {
                cr.EraseTimeEvents( CTE_TRACK );
                switch( cr.Mode[ MODE_TRACKER ] )
                {
                case 0:
                    tracked1.resize( 0 );
                    break;
                case 1:
                    tracked2.resize( 0 );
                    break;
                case 2:
                    tracked3.resize( 0 );
                    break;
                case 3:
                    tracked4.resize( 0 );
                    break;
                default:
                    break;
                }
                trackerId[ cr.Mode[ MODE_TRACKER ] ] = cr.Id;
                if( cr.IsPlayer() )
                    cr.RunClientScript( "client_main@__SetTrack", cr.Mode[ MODE_TRACKER ], 0, 0, null, null );
                cr.AddTimeEvent( "cte_Track", REAL_SECOND( 1 ), CTE_TRACK );
            }
            else
            {
                cr.RunClientScript( "client_main@__SetTrack", -1, 0, 0, null, null );
                cr.EraseTimeEvents( CTE_TRACK );
            }
        }
    }
}

void SetTracker( Critter& cr, int trackId )
{
    if( trackId > 3 )
        return;
    if( trackId < 0 )
    {
        if( cr.IsPlayer() )
            cr.RunClientScript( "client_main@__SetTrack", -1, 0, 0, null, null );
        cr.ModeBase[ MODE_TRACKER ] = -1;
        cr.EraseTimeEvents( CTE_TRACK );
        return;
    }
    if( trackerId[ trackId ] != 0 )
    {
        Critter@ tracker = GetCritter( trackerId[ trackId ] );
        if( valid( tracker ) )
        {
            if( tracker.IsPlayer() )
                tracker.RunClientScript( "client_main@__SetTrack", -1, 0, 0, null, null );
            tracker.EraseTimeEvents( CTE_TRACK );
        }
        else
        {
            string@ name = GetPlayerName( trackerId[ trackId ] );
            if( valid( name ) )
            {
                file f;
                if( f.open( "./save/clients/" + name + ".client", "r" ) != -1 )
                {
                    f.close();
                    OffClient off;
                    off.Name = name;
                    off.SetParam( MODE_TRACKER, 0 );
                }
            }
        }
        switch( trackId )
        {
        case 0:
            tracked1.resize( 0 );
            break;
        case 1:
            tracked2.resize( 0 );
            break;
        case 2:
            tracked3.resize( 0 );
            break;
        case 3:
            tracked4.resize( 0 );
            break;
        default:
            break;
        }
    }
    if( cr.IsPlayer() )
    {
        if( cr.Id == trackerId[ 0 ] )
        {
            trackerId[ 0 ] = 0;
            cr.EraseTimeEvents( CTE_TRACK );
            tracked1.resize( 0 );
        }
        else if( cr.Id == trackerId[ 1 ] )
        {
            trackerId[ 1 ] = 0;
            cr.EraseTimeEvents( CTE_TRACK );
            tracked2.resize( 0 );
        }
        else if( cr.Id == trackerId[ 2 ] )
        {
            trackerId[ 2 ] = 0;
            cr.EraseTimeEvents( CTE_TRACK );
            tracked3.resize( 0 );
        }
        else if( cr.Id == trackerId[ 3 ] )
        {
            trackerId[ 3 ] = 0;
            cr.EraseTimeEvents( CTE_TRACK );
            tracked4.resize( 0 );
        }
        trackerId[ trackId ] = cr.Id;
        cr.ModeBase[ MODE_TRACKER ] = trackId;
        if( cr.IsPlayer() )
            cr.RunClientScript( "client_main@__SetTrack", trackId, 0, 0, null, null );
        cr.AddTimeEvent( "cte_Track", REAL_SECOND( 1 ), CTE_TRACK );
    }
}

void TryAddTracked( uint8 Id, uint crId )
{
    bool     isAdded = false;
    Critter@ cr = GetCritter( crId );
    if( valid( cr ) )
    {
        Critter@[] crits = cr.GetGlobalGroup();
        for( uint n = 0, nMax = crits.length(); n < nMax; n++ )
        {
            if( crits[ n ].Stat[ ST_LEVEL ] <= 17 )
                return;
            Map@ m = crits[ n ].GetMap();
            if( valid( m ) )
            {
                uint locPid = m.GetLocation().GetProtoId();
                if( locPid >= LOCATION_SpecialFirstSpecial && locPid <= LOCATION_SpecialHell )
                    return;

            }
            if( PID_SIGNAL_QUENCHER != 0 )
            {
                Item@ q = crits[ n ].GetItem( PID_SIGNAL_QUENCHER, -1 );
                if( valid( q ) )
                    return;
            }
        }
    }

    switch( Id )
    {
    case 1:
        for( uint n = 0, nMax = tracked1.length(); n < nMax; n++ )
        {
            if( tracked1[ n ] == crId )
                isAdded = true;
        }
        if( !isAdded )
            tracked1.insertLast( crId );
        break;
    case 2:
        for( uint n = 0, nMax = tracked2.length(); n < nMax; n++ )
        {
            if( tracked2[ n ] == crId )
                isAdded = true;
        }
        if( !isAdded )
            tracked2.insertLast( crId );
        break;
    case 3:
        for( uint n = 0, nMax = tracked3.length(); n < nMax; n++ )
        {
            if( tracked3[ n ] == crId )
                isAdded = true;
        }
        if( !isAdded )
            tracked3.insertLast( crId );
        break;
    case 4:
        for( uint n = 0, nMax = tracked4.length(); n < nMax; n++ )
        {
            if( tracked4[ n ] == crId )
                isAdded = true;
        }
        if( !isAdded )
            tracked4.insertLast( crId );
        break;
    default:
        break;
    }
}

uint cte_Track( Critter& cr, int, int&, int& )
{
    if( cr.ModeBase[ MODE_TRACKER ] < 0 )
        return 0;
    int    beep = 1;
    string desc;
    int[] coords;
    if( valid( cr.GetMap() ) )
        return REAL_SECOND( 3 );
    if( cr.Id == trackerId[ 0 ] )
    {
        if( cr.WorldX > 700 || cr.WorldY > 750 )
        {
            tracked1.resize( 0 );
            beep = 0;
        }
        uint8[] toRemove;
        for( uint8 m = 0, mMax = tracked1.length(); m < mMax; m++ )
        {
            Critter@ tracked = GetCritter( tracked1[ m ] );
            if( valid( tracked ) )
            {
                bool skip = false;
                if( sqrt( POW2( int(tracked.WorldX) - int(cr.WorldX) ) + POW2( int(tracked.WorldY) - int(cr.WorldY) ) ) > TRACK_RADIUS + cr.Param[ PE_TRACKER ] * 25 ||
                    tracked.WorldX > 700 || tracked.WorldY > 750 )
                    skip = true;
                Map@ map = tracked.GetMap();
                if( valid( map ) && !skip )
                {
                    Location@ loc = map.GetLocation();
                    if( map.GetData( RADAR_VISIBLE ) != 0 )
                    {
                        cr.SetKnownLoc( true, loc.Id );
                    }
                    else
                        skip = true;
                }
                if( !skip )
                {
                    Critter@[] @ group = tracked.GetGlobalGroup();
                    if( valid( group ) )
                    {
                        if( group.length() > 1 )
                            desc += "Группа(" + group.length() + ") ";
                    }
                    if( tracked.Param[ ST_FACTION ] != 0 )
                    {
                        desc += "[" + GetFractionName( tracked.Param[ ST_FACTION ] ) + "]";
                    }
                    if( tracked.IsPlayer() )
                        desc += GetPlayerName( tracked.Id ) + "\n";
                    coords.insertLast( int( tracked.WorldX | ( tracked.WorldY << 16 ) ) );
                }
                else
                {
                    toRemove.insertLast( m );
                }
            }
            else
                toRemove.insertLast( m );
        }
        for( uint8 n = 0; n < toRemove.length(); n++ )
        {
            if( tracked1.length() - 1 >= toRemove[ n ] )
                tracked1.removeAt( toRemove[ n ] );
        }
    }
    else if( cr.Id == trackerId[ 1 ] )
    {
        if( cr.WorldX < 701 || cr.WorldY > 750 )
        {
            tracked2.resize( 0 );
            beep = 0;
        }
        uint8[] toRemove;
        for( uint8 m = 0, mMax = tracked2.length(); m < mMax; m++ )
        {
            Critter@ tracked = GetCritter( tracked2[ m ] );
            if( valid( tracked ) )
            {
                bool skip = false;
                if( sqrt( POW2( int(tracked.WorldX) - int(cr.WorldX) ) + POW2( int(tracked.WorldY) - int(cr.WorldY) ) ) > TRACK_RADIUS + cr.Param[ PE_TRACKER ] * 25 ||
                    tracked.WorldX < 701 || tracked.WorldY > 750 )
                    skip = true;
                Map@ map = tracked.GetMap();
                if( valid( map ) && !skip )
                {
                    Location@ loc = map.GetLocation();
                    if( map.GetData( RADAR_VISIBLE ) != 0 )
                    {
                        cr.SetKnownLoc( true, loc.Id );
                    }
                    else
                        skip = true;
                }
                if( !skip )
                {
                    Critter@[] @ group = tracked.GetGlobalGroup();
                    if( valid( group ) )
                    {
                        if( group.length() > 1 )
                            desc += "Группа(" + group.length() + ") ";
                    }
                    if( tracked.Param[ ST_FACTION ] != 0 )
                    {
                        desc += "[" + GetFractionName( tracked.Param[ ST_FACTION ] ) + "]";
                    }
                    if( tracked.IsPlayer() )
                        desc += GetPlayerName( tracked.Id ) + "\n";
                    coords.insertLast( int( tracked.WorldX | ( tracked.WorldY << 16 ) ) );
                }
                else
                    toRemove.insertLast( m );
            }
            else
                toRemove.insertLast( m );
        }
        for( uint8 n = 0; n < toRemove.length(); n++ )
        {
            if( tracked2.length() - 1 >= toRemove[ n ] )
                tracked2.removeAt( toRemove[ n ] );
        }
    }
    else if( cr.Id == trackerId[ 2 ] )
    {
        if( cr.WorldX > 700 || cr.WorldY < 751 )
        {
            tracked3.resize( 0 );
            beep = 0;
        }
        uint8[] toRemove;
        for( uint8 m = 0, mMax = tracked3.length(); m < mMax; m++ )
        {
            Critter@ tracked = GetCritter( tracked3[ m ] );
            if( valid( tracked ) )
            {
                bool skip = false;
                if( sqrt( POW2( int(tracked.WorldX) - int(cr.WorldX) ) + POW2( int(tracked.WorldY) - int(cr.WorldY) ) ) > TRACK_RADIUS + cr.Param[ PE_TRACKER ] * 25 ||
                    tracked.WorldX > 700 || tracked.WorldY < 751 )
                    skip = true;
                Map@ map = tracked.GetMap();
                if( valid( map ) && !skip )
                {
                    Location@ loc = map.GetLocation();
                    if( map.GetData( RADAR_VISIBLE ) != 0 )
                    {
                        cr.SetKnownLoc( true, loc.Id );
                    }
                    else
                        skip = true;
                }
                if( !skip )
                {
                    Critter@[] @ group = tracked.GetGlobalGroup();
                    if( valid( group ) )
                    {
                        if( group.length() > 1 )
                            desc += "Группа(" + group.length() + ") ";
                    }
                    if( tracked.Param[ ST_FACTION ] != 0 )
                    {
                        desc += "[" + GetFractionName( tracked.Param[ ST_FACTION ] ) + "]";
                    }
                    if( tracked.IsPlayer() )
                        desc += GetPlayerName( tracked.Id ) + "\n";
                    coords.insertLast( int( tracked.WorldX | ( tracked.WorldY << 16 ) ) );
                }
                else
                    toRemove.insertLast( m );
            }
            else
                toRemove.insertLast( m );
        }
        for( uint8 n = 0; n < toRemove.length(); n++ )
        {
            if( tracked3.length() - 1 >= toRemove[ n ] )
                tracked3.removeAt( toRemove[ n ] );
        }
    }
    else if( cr.Id == trackerId[ 3 ] )
    {
        if( cr.WorldX < 701 || cr.WorldY < 751 )
        {
            tracked4.resize( 0 );
            beep = 0;
        }
        uint8[] toRemove;
        for( uint8 m = 0, mMax = tracked4.length(); m < mMax; m++ )
        {
            Critter@ tracked = GetCritter( tracked4[ m ] );
            if( valid( tracked ) )
            {
                bool skip = false;
                if( sqrt( POW2( int(tracked.WorldX) - int(cr.WorldX) ) + POW2( int(tracked.WorldY) - int(cr.WorldY) ) ) > TRACK_RADIUS + cr.Param[ PE_TRACKER ] * 25 ||
                    tracked.WorldX < 701 || tracked.WorldY < 751 )
                    skip = true;
                Map@ map = tracked.GetMap();
                if( valid( map ) && !skip )
                {
                    Location@ loc = map.GetLocation();
                    if( map.GetData( RADAR_VISIBLE ) != 0 )
                    {
                        cr.SetKnownLoc( true, loc.Id );
                    }
                    else
                        skip = true;
                }
                if( !skip )
                {
                    Critter@[] @ group = tracked.GetGlobalGroup();
                    if( valid( group ) )
                    {
                        if( group.length() > 1 )
                            desc += "Группа(" + group.length() + ") ";
                    }
                    if( tracked.Param[ ST_FACTION ] != 0 )
                    {
                        desc += "[" + GetFractionName( tracked.Param[ ST_FACTION ] ) + "]";
                    }
                    if( tracked.IsPlayer() )
                        desc += GetPlayerName( tracked.Id ) + "\n";
                    coords.insertLast( int( tracked.WorldX | ( tracked.WorldY << 16 ) ) );
                }
                else
                    toRemove.insertLast( m );
            }
            else
                toRemove.insertLast( m );
        }
        for( uint8 n = 0; n < toRemove.length(); n++ )
        {
            if( tracked4.length() - 1 >= toRemove[ n ] )
                tracked4.removeAt( toRemove[ n ] );
        }
    }
    else
    {
        if( cr.IsPlayer() )
            cr.RunClientScript( "client_main@__SetTrack", -1, 0, 0, null, null );
        return 0;
    }
    if( cr.IsPlayer() )
	{
        cr.RunClientScript( "client_main@__SetTrackStat", beep, 0, 0, desc, coords );
    }
	return REAL_SECOND( 3 );
}
/*
   void unsafe_GetRelativeOrgList(Critter& cr, int param0, int param1, int param2, string@ param3, int[]@ param4)
   {
        int[] retArray=GetEnemyList(cr.Param[ST_FACTION]);
        int[] friends=GetFriendList(cr.Param[ST_FACTION]);
        int eCount=int(retArray.length());
        int fCount=int(friends.length());
        for(uint n=0; n<uint(fCount);n++)
        {
                retArray.insertLast(friends[n]);
        }
        cr.RunClientScript("client_main@__SetRelativeList", eCount, fCount,0,null, retArray);
   }*/
// ~run globalmap_group SetGlobalMapMoveCounter 0 0 0
void SetGlobalMapMoveCounter( Critter& cr, int p0, int, int )
{
    cr.GlobalMapMoveCounter = p0;
}
// ~run globalmap_group toglobal 0 0 0
void toglobal( Critter& cr, int p0, int, int )
{
    // cr.GlobalMapMoveCounter = p0;
    cr.TimeoutBase[ TO_BATTLE ] = 0;
    cr.TransitToGlobal( false );
}
