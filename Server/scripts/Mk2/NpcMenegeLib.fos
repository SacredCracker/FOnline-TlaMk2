// FOS Server
//	+++++++++++++++++++++++++++++++++++++++
//	+ Методы, для управления группой нпц. +
//	+++++++++++++++++++++++++++++++++++++++

#define TIME_TO_DELETE_MOBS                (REAL_SECOND(30)) // Время до удаления мобов.

// Добавить группу НПЦ
// map			- мапа
// params		- набор дополнительных параметров криттера
// x 			- координта x респа, если ентайр равен нулю
// y			- координата у респа, если ентайр равен нулю
// entire		- ентайр респа, если он задан не нулевым значением
// dir 			- направление
// params		- дополнительные параметры криттера
// count		- количество криттеров
::array<::Critter@> addGroupNpc( ::Map& map, uint pid, ::array<int> params , uint x, uint y, int entire, uint dir, uint count, ::string script)
{
	::array<::Critter@> group = {};
	
	//Координаты
	uint16 XSpawn=0;
	uint16 YSpawn=0;
	uint entNum=map.CountEntire(entire);
	if(entire!=0) 
	{
		if(not map.GetEntireCoords(entire, ::Random(0,entNum-1), XSpawn, YSpawn))
		{
			return group;
		}
	}
	else
	{
		XSpawn=x;
		YSpawn=y;		
	}

	// Создание группы
	::Critter@ cr = null;
	uint SaveX=XSpawn;
	int8 attempt=0; //количество неудачных попыток создать моба
	for(uint i=0, j=count;i<j;i++)
	{
		if(map.IsHexPassed(XSpawn, YSpawn))
			@cr=map.AddNpc(pid, XSpawn, YSpawn, 5, params, null, script);
		XSpawn++;
		if(XSpawn>SaveX+5) 
		{	
			XSpawn=SaveX;
			YSpawn++;
		}

		if(valid(cr))
			group.insertLast(@cr);
		else if(attempt<10)
		{
			i--;
			map.GetEntireCoords(entire, ::Random(0,entNum-1), XSpawn, YSpawn);
			attempt++;
		}
	}	
	return group;
}

// Метод, обьединяющий две группы в одну. Возвращает единую группу.
// При этом, нпц могут иметь разные команды.
// group1 - первая группа
// group2 - вторая группа
::array<::Critter@> uniteGroupNpc(::array<::Critter@> group1, ::array<::Critter@> group2)
{
    ::array<::Critter@> newGroup = {};
	
	for(uint i=0, iMax=group1.length();i<iMax;i++)
	{
		newGroup.insertLast(@group1[i]);
	}
	
	for(uint i=0, iMax=group2.length();i<iMax;i++)
	{
		newGroup.insertLast(@group2[i]);
	}
	
	return newGroup;
}

//Метод задания передвижения группы.
//
//
//
//
//
//
//
void moveGroupsNpc ( ::Map& map, ::array<::Critter@> group, uint x, uint y, int entire, uint dir, uint priority,  bool run) 
{
	//Координаты
	uint16 XMove, YMove;
	for(uint i=0, iMax=group.length(); i<iMax;i++)
	{
		if(entire!=0) 
		{
		uint entNum=map.CountEntire(entire);
			if(not map.GetEntireCoords(entire, ::Random(0,entNum-1), XMove, YMove))
			{
				return;
			}
		}
		else
		{
			XMove=x;
			YMove=y;			
		}		
		NpcPlanes::AddWalkPlane(group[i], priority, XMove+i, YMove+i, dir, run, 1);
	}
}

// Добавляет игроков в враги группе.
// 
// 
void addEnemyGroupsNpc ( Map& map, array<Critter@> group) 
{
	array<Critter@> enemy = {};
	if(map.GetCritters(0,FIND_LIFE_AND_KO, enemy)>0)
	{
		for(uint i=0, iMax=group.length(); i<iMax; i++)
		{
			Critter@ cr=group[i];
			for(uint j=0, jMax=enemy.length(); j<jMax; j++) 
			{
				if(enemy[j].IsNpc() && enemy[j].StatBase[ST_TEAM_ID] == cr.StatBase[ST_TEAM_ID])
					continue;
				
				NpcPlanes::AddAttackPlane(cr,0,enemy[j]);
			}
		}
	}
}

// Переносит группу нпц, по заданым координатам заданой карты.
//
//
//
//
void transitGroupsNpc ( ::Map& map, ::array<::Critter@> group, uint x, uint y, int entire) 
{
	//Координаты
	uint16 Xtransit, Ytransit;
	if(entire!=0) 
	{
		uint entNum=map.CountEntire(entire);
		if(not map.GetEntireCoords(entire, ::Random(0,entNum-1), Xtransit, Ytransit))
			return;
	}
	else
	{
			Xtransit=x;
			Ytransit=y;	
	}
	
	for(uint i=0, iMax=group.length(); i<iMax; i++)
		group[i].TransitToMap(map.Id, x,y, ::Random(0,5));
}

// Инициализация группы.
void GroupInit(::array<::Critter@> atackers)
{
	for(uint i=0, iMax=atackers.length(); i<iMax; i++)
	{
		atackers[i].SetEvent(CRITTER_EVENT_DEAD,"NpcMenegeLib::_CritterDead");
	}
}

// Криттер умирает
void _CritterDead(::Critter& cr, ::Critter@ attacker)
{
	::CreateTimeEvent( ::__FullSecond+TIME_TO_DELETE_MOBS,"NpcMenegeLib::e_DeleteSpawnedMob",cr.Id,true);
}

// Удаление криттера
uint e_DeleteSpawnedMob(::array<uint>@ values)
{
	::Critter@ mob = ::GetCritter(values[0]);
	if (valid(mob))
		::DeleteNpc(mob);
	return 0;
}