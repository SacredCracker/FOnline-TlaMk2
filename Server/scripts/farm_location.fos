// Author: Team MK2

// #define __DEBUG

#ifdef __DEBUG
# define DL                   # (str) Log( str )
// #define DumpMap #(str) Log(str)
#endif // __DEBUG
#ifndef __DEBUG
# define DL                   # ( str )
#endif // !__DEBUG

#include "_macros.fos"
#include "_items_generate_table.fos"
#include "_farm_defines.fos"
#include "serializator.fos"
#include "_teams.fos"

#ifdef __SERVER

import void SetDeterioration( Item& item, int deteriorationProcent ) from "Mk2";
import void InitRandomisationItem( Item& item, bool isCrafted, Critter& cr, string sufix ) from "Mk2";
#endif

#ifndef __SERVER

#endif

#define TABLE_MAP_COUNT       ( MapCount )
#define TABLE_ITEMS_COUNT     ( ItemsCount )
#define TABLE_MAP_PID         # (mapIndex)              ( MapsPids[ ( mapIndex ) ] )
#define TABLE_REFRESH_HOUR    # (mapIndex)              ( REAL_MINUTE( RespTime[ ( mapIndex ) ] ) )

#define TABLE_ITEM_PID        # (itemIndex)             ( ItemPids[ ( itemIndex ) ] )
#define TABLE_ITEM_COUNT      # ( mapIndex, itemIndex )( ItemCountsforMaps[ ( itemIndex + mapIndex * TABLE_ITEMS_COUNT ) ] )
#define TABLE_ITEM_CHANCE     # ( mapIndex, itemIndex )( ChanceData[ ( itemIndex + mapIndex * TABLE_ITEMS_COUNT ) ] )

#define REFRESH_TIME_RANGE    ( 60 )               // Разброс времени каждого респа, в процентах.

void _MapRespawnItemInContainers( Map& map, bool firstTime )
{
    CreateTimeEvent( __FullSecond + TABLE_REFRESH_HOUR( getMapIndex( map ) ) * uint( Random( 100 - REFRESH_TIME_RANGE, REFRESH_TIME_RANGE + 100 ) * 0.01 ), "e_RespawnItem", map.Id, true );
}

void _MapRespawnItemInEntire( Map& map, bool firstTime, int entire )
{
    int[] values = { map.Id, entire };
    CreateTimeEvent( __FullSecond + TABLE_REFRESH_HOUR( getMapIndex( map ) ) * uint( Random( 100 - REFRESH_TIME_RANGE, REFRESH_TIME_RANGE + 100 ) * 0.01 ), "e_RespawnItem", values, true );
}

uint e_RespawnItem( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( not validEngineObject( map ) )
        return 0;
    Item@[] containers = getAllContainer( map );
    uint mapIndex = getMapIndex( map );
    respItem( map, containers, values[ 1 ], false );
    Log( "TIME=" + ( TABLE_REFRESH_HOUR( mapIndex ) * uint( Random( 100 - REFRESH_TIME_RANGE, REFRESH_TIME_RANGE + 100 ) * 0.01 ) ) );
    return TABLE_REFRESH_HOUR( mapIndex ) * uint( Random( 100 - REFRESH_TIME_RANGE, REFRESH_TIME_RANGE + 100 ) * 0.01 );
}

// Респавн предметов
// mapIndex - индекс карты, на которой респятся предметы
// containers - ящики, в которых возможно отреспятся предметы
// deleteOldItems - удалять ли старые предметы
void respItem( Map& map, Item@[] containers, int entire, bool deleteOldItems )
{
    uint mapIndex = getMapIndex( map );
    uint countContainers = containers.length();         // Количество контейнеров на карте
    if( entire == 0 )
    {
        if( countContainers == 0 )
            return;

        // Если нужно очистить контейнеры от старых предметов, то удаляем их
        if( deleteOldItems )
        {
            for( uint i = 0; i < countContainers; i++ )
            {
                Item@[] oldItems;
                if( validEngineObject( containers[ i ] ) )
                {
                    containers[ i ].GetItems( 0, oldItems );
                    for( uint j = 0, jMax = oldItems.length(); j < jMax; j++ )
                    {
                        if( validEngineObject( oldItems[ j ] ) )
                            DeleteItem( oldItems[ j ] );
                    }
                }
            }
        }
    }

    // Респим предметы
    for( uint i = 0; i < TABLE_ITEMS_COUNT; i++ )
    {
        int pid = TABLE_ITEM_PID( i );
        if( pid < 1 )
            continue;

        int              needCount = TABLE_ITEM_COUNT( mapIndex, i );
        // rifleman17 23/08/13. Добавлено назначение размера стака
        int              addingCount = 1;
        const ProtoItem@ proto = GetProtoItem( pid );
        if( proto !is null )
        {
            addingCount = needCount;
            needCount = 1;
        }
        // <--- rifleman17 23/08/13.

        if( needCount < 1 )
            continue;

        for( uint j = 0; j < uint( needCount ); j++ )
        {
            if( Random( 0, 1000 ) < TABLE_ITEM_CHANCE( mapIndex, i ) )
            {
                // Обработка особо редких крафтерских предметов. Быдлокод привязанный к пидам и дублируется в trader.fos
                // В дальнейшем необходимо универсализировать данную хуйню и отвязать от проверки на пиды.
                // bydloCode on
                if( pid == PID_MOTIVATOR )
                {
                    GameVar@ timeout_var = GetGlobalVar( GVAR_timeout_motivator );
                    if( timeout_var !is null )
					{
                        if( uint( timeout_var.GetValue() ) < __FullSecond )
                            timeout_var = __FullSecond + REAL_HOUR( Random( 72, 120 ) );
                        else
							continue;
					}
                }
                else if( pid == PID_K9_MOTIVATOR )
                {
                    GameVar@ timeout_var = GetGlobalVar( GVAR_timeout_motivator_k9 );
                    if( timeout_var !is null )
					{
                        if( uint( timeout_var.GetValue() ) < __FullSecond )
                            timeout_var = __FullSecond + REAL_HOUR( Random( 96, 144 ) );
                        else
                            continue;
					}
                }
                else if( pid == PID_OIL_CAN_TRUE )
                {
                    GameVar@ timeout_var = GetGlobalVar( GVAR_timeout_oil_can );
                    if( timeout_var !is null )
					{
                        if( uint( timeout_var.GetValue() ) < __FullSecond )
                            timeout_var = __FullSecond + REAL_HOUR( Random( 8, 10 ) );
                        else
                            continue;
					}
                }
                // bydloCode off

                Item@ item = null, last_cont;
                if( entire == 0 )
                {
                    @last_cont = containers[ Random( 0, countContainers - 1 ) ];
                    if( validEngineObject( last_cont ) )
                        @item = last_cont.AddItem( pid, 1, 0 );                          // Добавляем предмет
                }
                else
                {
                    uint16 XSpawn = 0;
                    uint16 YSpawn = 0;
                    uint   entNum = map.CountEntire( entire );
                    if( map.GetEntireCoords( entire, Random( 0, entNum - 1 ), XSpawn, YSpawn ) )
                    {
                        const ProtoItem@ protoItem = GetProtoItem( pid );
                        if( protoItem !is null )
                            map.AddItem( XSpawn, YSpawn, pid, addingCount );
                        else
                        {
                            DL( "+++ Cracker Debug +++ Прототипа под номером " + pid + " не существует." );
                        }
                    }
                }
                if( validEngineObject( item ) && item.IsDeteriorable() )
                    SetDeterioration( item, Random( 5, 25 ) );                                                                   // Устанавливаем износ
            }
        }
    }
}

// Получить все контейнеры с карты
Item@[] getAllContainer( Map& map )
{
    Item@[] containers;
    map.GetItemsByType( ITEM_TYPE_CONTAINER, containers );
    return containers;
}

// Получает индекс карты
int getMapIndex( Map& map )
{
    int mapPid = map.GetProtoId();
    if( mapPid > 0 )
    {
        for( uint i = 0, iMax = TABLE_MAP_COUNT; i < iMax; i++ )
        {
            if( TABLE_MAP_PID( i ) == mapPid )
                return i;
        }
    }
    return -1;
}

// Отладка. Респит предметы на текущеё карте, но по параметру заданной любой другой карты
// ~run farm_lacation addItemInContainers 1 0 0
void addItemInContainers( Critter& cr, int entire, int param1, int param2 )
{
    Map@ map = cr.GetMap();
    if( not validEngineObject( map ) )
        return;
    Item@[] containers;
    map.GetItemsByType( ITEM_TYPE_CONTAINER, containers );
    respItem( map, containers, entire, false );
}

#define _MODULE_FARM_MAIN
#include "farm_location_h.fos"


// ~run farm_location TestFarmLocation x 0 0
void TestFarmLocation( Critter& cr, int id, int, int )
{
    Location@ loc = ( Farm::AllLocs[ id - 1 ] ).Create( 666, 666 );
    if( validEngineObject( loc ) )
    {
        cr.TransitToMap( loc.GetMapByIndex( 0 ).Id, 0 );
    }
    else
        Log( "Error №0" );
}

bool GetConstantValue( const int& in constCollection, string@ name, int& out value )
{
    value = ::GetConstantValue( constCollection, name );
    return ( value != -1 );
}
 
void FarmItemBagsItemsLineCompil( const string& in line, array< SlotBags@ >& inout slots, dictionary& in libItemSets, array< string@ >& inout includes, uint blockf, uint linei, string@ defName )
{
    array< string@ > memSt = splitEx( line, " " ), varStr, varStr0,
                     itemsStr, itemsParam, secondStr, blueprintStr;

    string@ tempStr = null, tempStr2 = null;
    int     mem = -1,
            percent = 0,
            ItemSlot = SLOT_INV;

    bool noSlot = false,
         IsBlueprint = false;

    uint bluePrintPid = 0,
         bluePrintCount = 0;

    SlotBags@ subSlot = null;

    for( uint j = 0, jMax = memSt.length(); j < jMax; j++ )
    {
        mem = -1;
        percent = 0;

        array< array< FarmItem@ > > arrIts;
        itemsStr = splitEx( memSt[ j ], "*" );
        if( itemsStr.length() > 1 )
            StrToInt( itemsStr[ 1 ], percent );

        varStr = splitEx( itemsStr[ 0 ], "+" );
        for( uint iline0 = 0, iline0_max = varStr.length(); iline0 < iline0_max; iline0++ )
        {
            array< FarmItem@ > its;
            itemsStr = splitEx( varStr[ iline0 ], "||" );
            for( uint iline1 = 0, iline1_max = itemsStr.length(); iline1 < iline1_max; iline1++ )
            {
                array< FarmItem@ > subIts;
                @ tempStr = itemsStr[ iline1 ];
                @ tempStr2 = null;
                array< string@ > mStr = splitEx( tempStr, ")" );

                if( mStr.length() == 2 )
                {
                    @ tempStr2 = mStr[ 1 ];
                    mStr = splitEx( mStr[ 0 ], "(" );
                    if( mStr.length() != 2 )
                        continue;
                    @ tempStr = mStr[ 0 ] + tempStr2;

                    varStr0 = splitEx( mStr[ 1 ], "," );
                    for( uint iline2 = 0, iline2_max = varStr0.length(); iline2 < iline2_max; iline2++ )
                    {
                        itemsParam = splitEx( varStr0[ iline2 ], "^" );
                        ItemSlot = SLOT_INV;
                        noSlot = ( itemsParam.length() == 1 );
                        if( not noSlot )
                        {
                            if( itemsParam[ 1 ] == "m" )
                                ItemSlot = SLOT_HAND1;
                            else if( itemsParam[ 1 ] == "e" )
                                ItemSlot = SLOT_HAND2;
                            else if( itemsParam[ 1 ] == "a" )
                                ItemSlot = SLOT_ARMOR;
                        }

                        itemsParam = splitEx( itemsParam[ 0 ], "%" );
                        secondStr = splitEx( itemsParam[ 0 ], ":" );

                        int posOpenSpec = findFirst( secondStr[ 0 ], "<" ),
                            posCloseSpec = findFirst( secondStr[ 0 ], ">" );

                        string  argString = "";

                        string@ funcCreated, funcIsCreated;

                        int     keyId = 0;

                        if( posOpenSpec != -1 )
                        {
                            if( posCloseSpec == -1 )
                            {
                                ClearLog( "(Bags.fofarmloc)Ошибка, не закрытая строка аргументов: " + secondStr[ 0 ] );
                                continue;
                            }
                            argString = substring( secondStr[ 0 ], posOpenSpec + 1, posCloseSpec - posOpenSpec - 1 );
                            secondStr[ 0 ] = substring( secondStr[ 0 ], 0, posOpenSpec );

                            array< string@ > formatArgs = splitEx( argString, "," ),
                                             argsMems;
                            for( uint t = 0, tMax = formatArgs.length(); t < tMax; t++ )
                            {
                                if( formatArgs[ t ] !is null )
                                {
                                    argsMems = splitEx( formatArgs[ t ], "=" );
                                    if( argsMems.length() == 2 )
                                    {
                                        if( argsMems[ 0 ] == "FuncCreated" )
                                            @funcCreated = argsMems[ 1 ];
                                        else if( argsMems[ 0 ] == "FuncIsCreated" )
                                            @funcIsCreated = argsMems[ 1 ];
                                        else if( argsMems[ 0 ] == "KeyId" )
                                            StrToInt( argsMems[ 1 ], keyId );
                                    }
                                }
                            }

                        }

                        if( GetConstantValue( CONSTANTS_ITEM, secondStr[ 0 ], mem ) )
                        {}
                        else if( libItemSets.exists( secondStr[ 0 ] ) )
                        {
                            libItemSets.get( secondStr[ 0 ], mem );
                            includes.insertLast( secondStr[ 0 ] );
                            Farm::AddDefineItems( arrIts, mem );
                            continue;
                        }
                        else if( not StrToInt( secondStr[ 0 ], mem ) )
                            continue;
                        FarmItem it( mem, funcCreated, funcIsCreated, keyId );

                        it.ItemSlot = ItemSlot;
                        if( itemsParam.length() > 1 )
                            StrToInt( itemsParam[ 1 ], it.Percent );

                        if( secondStr.length() > 1 )
                        {
                            itemsParam = splitEx( secondStr[ 1 ], "-" );
                            if( StrToInt( itemsParam[ 0 ], mem ) )
                            {
                                it.Count.Min = mem;

                                if( itemsParam.length() == 2 )
                                    StrToInt( itemsParam[ 1 ], mem );

                                it.Count.Max = mem;
                            }
                        }
                        subIts.insertLast( it );
                    }
                }
                else if( findFirst( tempStr, "(" ) != -1 && findFirst( tempStr, ")" ) == -1 )
                {

                    ClearLog( "(Bags.fofarmloc)Ошибка, не закрытая скобка: " + tempStr + " блок " + blockf + " линия " + linei + " defName " + defName );
                    continue;
                }

                @ subSlot = null;
                IsBlueprint = false;
                itemsParam = splitEx( tempStr, "^" );                 // Указан ли слот в котором будет итем.
                ItemSlot = SLOT_INV;
                noSlot = ( itemsParam.length() == 1 );
                if( not noSlot )
                {
                    if( itemsParam[ 1 ] == "m" )
                        ItemSlot = SLOT_HAND1;
                    else if( itemsParam[ 1 ] == "e" )
                        ItemSlot = SLOT_HAND2;
                    else if( itemsParam[ 1 ] == "a" )
                        ItemSlot = SLOT_ARMOR;
                }

                itemsParam = splitEx( itemsParam[ 0 ], "%" );
                secondStr = splitEx( itemsParam[ 0 ], ":" );

                int posOpenSpec = findFirst( secondStr[ 0 ], "<" ),
                    posCloseSpec = findFirst( secondStr[ 0 ], ">" );

                string  argString = "";

                string@ funcCreated, funcIsCreated;
                int     keyId = 0;

                if( posOpenSpec != -1 )
                {
                    if( posCloseSpec == -1 )
                    {
                        ClearLog( "(Bags.fofarmloc)Ошибка, не закрытая фигурная скобка (>): " + secondStr[ 0 ] );
                        continue;
                    }
                    argString = substring( secondStr[ 0 ], posOpenSpec + 1, posCloseSpec - posOpenSpec - 1 );
                    secondStr[ 0 ] = substring( secondStr[ 0 ], 0, posOpenSpec );

                    array< string@ > formatArgs = splitEx( argString, "," ),
                                     argsMems;
                    for( uint t = 0, tMax = formatArgs.length(); t < tMax; t++ )
                    {
                        if( formatArgs[ t ] !is null )
                        {
                            argsMems = splitEx( formatArgs[ t ], "=" );
                            if( argsMems.length() == 2 )
                            {
                                if( argsMems[ 0 ] == "FuncCreated" )
                                    @funcCreated = argsMems[ 1 ];
                                else if( argsMems[ 0 ] == "FuncIsCreated" )
                                    @funcIsCreated = argsMems[ 1 ];
                                else if( argsMems[ 0 ] == "KeyId" )
                                    StrToInt( argsMems[ 1 ], keyId );
                            }
                        }
                    }

                }


                if( GetConstantValue( CONSTANTS_ITEM, secondStr[ 0 ], mem ) )
                {}
                else if( libItemSets.exists( secondStr[ 0 ] ) )
                {
                    libItemSets.get( secondStr[ 0 ], mem );
                    includes.insertLast( secondStr[ 0 ] );
                    Farm::AddDefineItems( arrIts, mem );
                    continue;
                }
                else if( secondStr[ 0 ] == "BLUEPRINT" )
                {
                    if( argString.length() != 0 )
                    {
                        DL( substring( secondStr[ 0 ], 10, secondStr[ 0 ].length() ) );
                        blueprintStr = splitEx( substring( argString, 0, argString.length() ), "," );
                        DL( " " + blueprintStr.length() );

                        if( blueprintStr.length() == 2 )
                        {
                            DL( blueprintStr[ 0 ] );
                            DL( blueprintStr[ 1 ] );
                            if( GetConstantValue( CONSTANTS_ITEM, blueprintStr[ 0 ], mem ) )
                            {}
                            else if( not StrToInt( blueprintStr[ 0 ], mem ) )
                                continue;

                            bluePrintPid = mem;
                            if( not StrToInt( blueprintStr[ 1 ], mem ) )
                                continue;
                            bluePrintCount = mem;

                            mem = PID_BLUEPRINT;
                            IsBlueprint = true;
                        }
                        else
                            continue;
                    }
                    else
                        continue;
                }
                else if( not StrToInt( secondStr[ 0 ], mem ) )
                {
                    ClearLog( "(Bags.fofarmloc)Строка не опознана " + secondStr[ 0 ] + " блок " + blockf + " линия " + linei + " defName " + defName );
                    continue;
                }
                FarmItem it( mem, funcCreated, funcIsCreated, keyId, subIts );

                if( IsBlueprint )
                {
                    it.IsBluePrint = IsBlueprint;
                    it.BluePrint_Pid = bluePrintPid;
                    it.BluePrint_Count = bluePrintCount;
                }

                it.ItemSlot = ItemSlot;
                if( itemsParam.length() > 1 )
                    StrToInt( itemsParam[ 1 ], it.Percent );

                if( secondStr.length() > 1 )
                {
                    itemsParam = splitEx( secondStr[ 1 ], "-" );
                    if( StrToInt( itemsParam[ 0 ], mem ) )
                    {
                        it.Count.Min = mem;

                        if( itemsParam.length() == 2 )
                            StrToInt( itemsParam[ 1 ], mem );

                        it.Count.Max = mem;
                    }
                }
                its.insertLast( it );
            }
            arrIts.insertLast( its );
        }
        slots.insertLast( SlotBags( arrIts, percent ) );
    }
}

void FarmItemBagsBlockCompil( const string& in Dataf, dictionary& inout libItemSets, uint blockf )
{
    array< SlotBags@ > slots;

    array< string@ >   line = splitEx( Dataf, "\n" ),
                       incl, temp;

    string@ defName = null;

    uint    pid = uint( -1 ), percent = 0;
    int     mem = -1;

    for( uint i = 0, iEnd = line.length(); i < iEnd; i++ )
    {
        temp = splitEx( line[ i ], "=" );
        if( temp[ 0 ].length() > 0 && temp[ 0 ] != "" )
        {
            string formatTxt = "";
            if( temp.length() > 1 )
            {
                formatTxt = temp[ 1 ];
                for( uint c = 2, cEnd =  temp.length(); c < cEnd; c++ )
                    formatTxt += "=" + temp[ c ];
            }
            mem = -1;
            if( temp[ 0 ] == "Pid" )
            {
                if( StrToInt( formatTxt, mem ) )
                    pid = mem;
            }
            else if( temp[ 0 ] == "Items" )
                FarmItemBagsItemsLineCompil( formatTxt, slots, libItemSets, incl, blockf, i, ( defName !is null ? defName : "" ) );
            else if( temp[ 0 ] == "DefName" )
            {
                if( not libItemSets.exists( formatTxt ) )
                    @ defName = formatTxt;
            }
            else if( temp[ 0 ] == "MaxPercent" )
            {
                if( StrToInt( formatTxt, mem ) )
                    percent = mem;
            }
        }
    }
    if( pid > Farm::AllBags.length() )
        Farm::AllBags.resize( pid );
    // FarmBags protoBags( pid, slots );
    @ Farm::AllBags[ pid - 1 ] = FarmBags( pid, slots );
    FarmBags@ bags = ( Farm::AllBags[ pid - 1 ] );
    if( bags !is null )
    {
        @ bags.DefName = defName;
        if( percent != 0 )
            bags.MaxPercent = percent;
        if( defName !is null )
            libItemSets.set( defName, pid );
    }
    else
        Log( "Error!" );
}

void InitializeBags( string path )
{
	file       f;
    dictionary libItemSets;

    string     str = "";
    string@[] data1, temp;
    int        mem = -1;

    if( f.open( path, "r" ) != -1 )
    {
		str = "";

		f.readString( uint( f.getSize() ), str );
		f.close();

		data1 = splitEx( str, "[FarmBag]" );

		str = "";

		uint iEnd = data1.length();
		if( iEnd != 0 )
		{
			temp = splitEx( data1.first(), "=" );
			mem = 0;

			if( StrToInt( temp[ 1 ], mem ) )
			{
				Farm::AllBags.resize( mem );
				for( uint ibags = 1; ibags < iEnd; ibags++ )
					FarmItemBagsBlockCompil( data1[ ibags ], libItemSets, ibags );
			}
		}
	}

    for( uint i = 0, iEnd = Farm::AllBags.length(); i < iEnd; i++ )
        if( Farm::AllBags[ i ] !is null )
            ( Farm::AllBags[ i ] ).Initialize();
}

void InitializeCritters( string path )
{
	file       f;
    string     str = "";
    string@[] data1, temp, line;
    int        mem = -1;

    {
        if( f.open( path, "r" ) != -1 )
        {
            array< string@ > AllNameR, AllNameE, AllNameU;
            str = "";
            f.readString( uint( f.getSize() ), str );
            f.close();
            data1 = splitEx( str, "[FarmCritter]" );
            str = "";
            uint countMob = 0;

            uint iEnd = data1.length();
            if( iEnd > 1 )
            {
                string@ namer, namee, nameu;
                line = splitEx( data1.first(), "\n" );

                mem = 0;
				iEnd = line.length();
                for( uint i = 0; i < iEnd; i++ )
                {
                    temp = splitEx( line[ i ], "=" );
                    if( temp.length() > 1 )
                    {
                        if( temp[ 0 ] == "MaxFarmCritter" && StrToInt( temp[ 1 ], mem ) )
                            countMob += mem;
                    }
                    else if( temp.length() == 1 && temp[ 0 ].length() > 2 && temp[ 0 ][ 0 ] == '#' )
                    {
                        temp[ 0 ] = substring( temp[ 0 ], 1, temp[ 0 ].length() );
                        temp = splitEx( temp[ 0 ], " " );
                        if( temp[ 0 ] == "include" )
                        {
                            if( f.open( "data\\farm_locations\\" + temp[ 1 ], "r" ) != -1 )
                            {
                                str = "";
                                f.readString( uint( f.getSize() ), str );
                                f.close();
                                array< string@ > blockStringArr = splitEx( str, "[FarmCritter]" ), lineS, tempS;
                                str = "";

                                uint iEndS = blockStringArr.length();
                                if( iEndS != 0 )
                                {
                                    lineS = splitEx( blockStringArr[ 0 ], "\n" );
                                    int memS = 0;
                                    for( uint iline = 0, ilineEnd = lineS.length(); iline < ilineEnd; iline++ )
                                        if( tempS.length() > 1 && tempS[ 0 ] == "MaxFarmCritter" && StrToInt( tempS[ 1 ], memS ) )
                                            countMob += memS;

                                    for( uint iline = 1; iline < iEndS; iline++ )
                                        data1.insertLast( blockStringArr[ iline ] );
                                }
                            }
                        }
                    }
                }

                iEnd = data1.length();
                Farm::AllMobs.resize( countMob );
                AllNameR.resize( countMob + 1 );
                AllNameE.resize( countMob + 1 );
                AllNameU.resize( countMob + 1 );
                uint                           pid = 0;
                array< uint > memData( Farm::Constant::Mob::Data::CountData );
                array< Farm::Param@ > mobParam;
                string@ aiScript = null;
                for( uint i = 1; i < iEnd; i++ )
                {
                    mobParam.resize( 0 );
                    for( uint iline = 0; iline < Farm::Constant::Mob::Data::CountData; iline++ )
                        memData[ iline ] = 0;
                    @ aiScript = null;
                    line = splitEx( data1[ i ], "\n" );
                    for( uint iline = 0, ilineEnd = line.length(); iline < ilineEnd; iline++ )
                    {
                        if( line[ iline ] !is null && line[ iline ].length() > 0 )
                        {
                            if( line[ iline ][ 0 ] == '#' )
                                continue;
                            temp = splitEx( line[ iline ], "=" );
                            if( temp[ 0 ] == "Pid" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    pid = mem;
                            }
                            else if( temp[ 0 ] == "CritterPid" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::Mob::Data::Proto ] = mem;
                            }
                            else if( temp[ 0 ] == "BagPid" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::Mob::Data::Bag ] = mem;
                            }
                            else if( temp[ 0 ] == "Type" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::Mob::Data::Type ] = mem;
                            }
                            else if( temp[ 0 ] == "TypeVar" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::Mob::Data::TypeVar ] = mem;
                            }
                            else if( temp[ 0 ] == "GameName_russ" )
                            {
                                @namer = temp[ 1 ];
                                @namee = temp[ 1 ];
                                @nameu = temp[ 1 ];
                                mobParam.insertLast( Farm::Param( ST_NPC_NAME_RUSS, GetStrHash( temp[ 1 ] ), 0 ) );
                                mobParam.insertLast( Farm::Param( ST_NPC_NAME_UKRA, GetStrHash( temp[ 1 ] ), 0 ) );
                                mobParam.insertLast( Farm::Param( ST_NPC_NAME_ENGL, GetStrHash( temp[ 1 ] ), 0 ) );
                            }
                            else if( temp[ 0 ] == "GameName_engl" )
                            {
                                @namee = temp[ 1 ];
                                mobParam.insertLast( Farm::Param( ST_NPC_NAME_ENGL, GetStrHash( temp[ 1 ] ), 0 ) );
                            }
                            else if( temp[ 0 ] == "GameName_ukra" )
                            {
                                @nameu = temp[ 1 ];
                                mobParam.insertLast( Farm::Param( ST_NPC_NAME_UKRA, GetStrHash( temp[ 1 ] ), 0 ) );
                            }
                            else if( temp[ 0 ] == "AiScript" )
                            {
                                @ aiScript = temp[ 1 ];
                            }
                            else if( GetConstantValue( CONSTANTS_PARAM, temp[ 0 ], mem ) )
                            {
                                int  value = 0;
                                uint index = 0, percent = 0;
                                index = mem;
                                temp = splitEx( temp[ 1 ], "%" );
                                if( StrToInt( temp[ 0 ], mem ) )
                                {
                                    value = mem;
                                    if( temp.length() > 1 && StrToInt( temp[ 1 ], mem ) )
                                        percent = mem;

                                    mobParam.insertLast( Farm::Param( index, value, percent ) );
                                }
                            }
                        }
                    }
                    if( pid > countMob )
                    {
                        countMob = pid;
                        Farm::AllMobs.resize( countMob );
                        AllNameR.resize( countMob + 1 );
                        AllNameE.resize( countMob + 1 );
                        AllNameU.resize( countMob + 1 );
                    }
                    if( memData[ Farm::Constant::Mob::Data::Proto ] == 0 )
                    {
                        if( memData[ Farm::Constant::Mob::Data::Type ] == uint( Farm::Constant::Mob::E_Type::Dead ) )
                            memData[ Farm::Constant::Mob::Data::Proto ] = 1;
                        else
                            Log( "Error CritterPid is null (" + pid + ")" );
                    }

                    @ Farm::AllMobs[ pid - 1 ] = FarmMob( pid );
                    ( Farm::AllMobs[ pid - 1 ] ).Initialize( memData, mobParam, aiScript );

                    @AllNameR[ pid ] = namer;
                    @AllNameE[ pid ] = namee;
                    @AllNameU[ pid ] = nameu;

                }
            }

            file listName;
            uint genTick = GetTick();
            if( listName.open( "scripts\\gen_farm_names.fos", "w" ) != -1 )
            {
                listName.writeString( "void LoadFarmNames( string@[]&out n, const string&in l )\n{\n" );

                listName.writeString( "\tif( l == \"russ\" )\n\t{\n\t\tstring@[] arr = \n\t\t{\n\t\t\t" );
                #define defWriteFirst    # (s) listName.writeString( s !is null ? ( "\"" + s + "\"" ) : "null" )
                #define defWrite         # (s) listName.writeString( s !is null ? ( " , \"" + s + "\"" ) : " , null" )
                defWriteFirst( AllNameR[ 0 ] );
                for( uint i = 1; i < countMob + 1; i++ )
                {
                    defWrite( AllNameR[ i ] );
                }

                listName.writeString( "\n\t\t};\n" );
                listName.writeString( "\t\tn = arr;\n" );
                listName.writeString( "\t}\n\t" );

                listName.writeString( "else if( l == \"engl\" )\n\t{\n\t\tstring@[] arr = \n\t\t{\n\t\t\t" );
                defWriteFirst( AllNameE[ 0 ] );
                for( uint i = 1; i < countMob + 1; i++ )
                {
                    defWrite( AllNameE[ i ] );
                }

                listName.writeString( "\n\t\t};\n" );
                listName.writeString( "\t\tn = arr;\n" );
                listName.writeString( "\t}\n\t" );

                listName.writeString( "else if( l == \"ukra\" )\n\t{\n\t\tstring@[] arr = \n\t\t{\n\t\t\t" );
                defWriteFirst( AllNameU[ 0 ] );
                for( uint i = 1; i < countMob + 1; i++ )
                {
                    defWrite( AllNameU[ i ] );
                }
                listName.writeString( "\n\t\t};\n" );
                listName.writeString( "\t\tn = arr;\n" );
                listName.writeString( "\t}\n" );

                listName.writeString( "}" );
                listName.close();
            }
            ClearLog( "Generation client farm names: " + ( GetTick() - genTick ) + "ms." );
        }
    }
}

void InitializeTeamCritters( string path )
{
	file       f;

    string     str = "";
    string@[] data1, temp, line;
    int        mem = -1;
	{
        if( f.open( path, "r" ) != -1 )
        {
            str = "";

            f.readString( uint( f.getSize() ), str );
            f.close();
            data1 = splitEx( str, "[FarmTeamCritter]" );

            str = "";

            uint iEnd = data1.length();
            if( iEnd > 1 )
            {
                temp = splitEx( data1[ 0 ], "=" );
                mem = 0;

                if( StrToInt( temp[ 1 ], mem ) )
                {
                    uint countTeam = mem;
                    Farm::AllTeamMobs.resize( countTeam );
                    uint pid = 0;
                    array< uint > memData;
                    array< Farm::Param@ > mobParam;

                    bool isStatic = false;

                    uint EntireSpawn = 0,
                         CountMobs_min = 0,
                         CountMobs_max = 0;

                    for( uint i = 1; i < iEnd; i++ )
                    {
                        EntireSpawn = 0;
                        CountMobs_min = 0;
                        CountMobs_max = 0;

                        mobParam.resize( 0 );
                        memData.resize( 0 );

                        isStatic = false;

                        line = splitEx( data1[ i ], "\n" );
                        for( uint iline0 = 0, iline0End = line.length(); iline0 < iline0End; iline0++ )
                        {
                            temp = splitEx( line[ iline0 ], "=" );
                            if( temp[ 0 ] == "Pid" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    pid = mem;
                            }
                            else if( temp[ 0 ] == "Critters" )
                            {
                                string@[] memSt = splitEx( temp[ 1 ], " " );
                                for( uint j = 0, jMax = memSt.length(); j < jMax; j++ )
                                    if( StrToInt( memSt[ j ], mem ) )
                                        memData.insertLast( mem );
                            }
                            else if( temp[ 0 ] == "EntireSpawn" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    EntireSpawn = mem;
                            }
                            else if( temp[ 0 ] == "CountMobs_min" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    CountMobs_min = mem;
                            }
                            else if( temp[ 0 ] == "CountMobs_max" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    CountMobs_max = mem;
                            }
                            else if( temp[ 0 ] == "StaticCount" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    isStatic = ( mem == 1 );
                            }
                            else if( GetConstantValue( CONSTANTS_PARAM, temp[ 0 ], mem ) )
                            {
                                int value = 0;
                                uint index = 0, percent = 0;
                                index = mem;
                                temp = splitEx( temp[ 1 ], "%" );
                                if( StrToInt( temp[ 0 ], mem ) )
                                {
                                    value = mem;
                                    if( temp.length() > 1 && StrToInt( temp[ 1 ], mem ) )
                                        percent = mem;

                                    mobParam.insertLast( Farm::Param( index, value, percent ) );
                                }
                            }
                        }

                        if( pid > countTeam )
                        {
                            countTeam = pid;
                            Farm::AllTeamMobs.resize( countTeam );
                        }
                        @Farm::AllTeamMobs[ pid - 1 ] = FarmTeamMob( pid );
                        ( Farm::AllTeamMobs[ pid - 1 ] ).Initialize( memData, EntireSpawn, CountMobs_min, CountMobs_max, mobParam, isStatic );
                    }
                }
            }
        }
    }
}

void InitializeContainers( string path )
{
	file       f;

    string     str = "";
    string@[] data1, temp, line;
    int        mem = -1;
	{
        if( f.open( path, "r" ) != -1 )
        {
            str = "";
            f.readString( uint( f.getSize() ), str );
            f.close();
            data1 = splitEx( str, "[FarmContainer]" );
            str = "";

            uint iEnd = data1.length();
            if( iEnd > 1 )
            {
                temp = splitEx( data1[ 0 ], "=" );
                mem = 0;
                if( StrToInt( temp[ 1 ], mem ) )
                {
                    uint countCont = mem;
                    Farm::AllFarmContainer.resize( countCont );
                    uint pid = 0;
                    array< uint > memData;
                    array< uint > pids;
                    array< array< uint > > bags;
                    string@ strScript = null;
                    for( uint i = 1; i < iEnd; i++ )
                    {
                        // 325728477
                        pids.resize( 0 );
                        bags.resize( 0 );
                        @ strScript = null;
                        memData.resize( Farm::Constant::Container::Data::CountData );
                        for( uint m = 0; m < uint( Farm::Constant::Container::Data::CountData ); m++ )
                            memData[ m ] = 0;
                        line = splitEx( data1[ i ], "\n" );
                        for( uint iline0 = 0, iline0End = line.length(); iline0 < iline0End; iline0++ )
                        {
                            temp = splitEx( line[ iline0 ], "=" );
                            if( temp[ 0 ] != "" && temp[ 0 ].length() > 0 )
                            {
                                if( temp[ 0 ] == "Pid" )
                                {
                                    if( StrToInt( temp[ 1 ], mem ) )
                                        pid = mem;
                                }
                                else if( temp[ 0 ] == "ProtoId" )
                                {
                                    array< string@ > memSt = splitEx( temp[ 1 ], " " );
                                    for( uint j = 0, jMax = memSt.length(); j < jMax; j++ )
                                        if( StrToInt( memSt[ j ], mem ) )
                                            pids.insertLast( mem );
                                }
                                else if( temp[ 0 ] == "BagPid" )
                                {
                                    array< string@ > memSt = splitEx( temp[ 1 ], " " );
                                    for( uint j = 0, jMax = memSt.length(); j < jMax; j++ )
                                    {
                                        array< uint > bag;
                                        array< string@ > memSt0 = splitEx( temp[ 1 ], "||" );
                                        for( uint j0 = 0, j0Max = memSt0.length(); j0 < j0Max; j0++ )
                                        { 
                                            if( StrToInt( memSt0[ j0 ], mem ) )
                                                bag.insertLast( mem );
                                        }
                                        bags.insertLast( bag );
                                    }
                                }
                                else if( temp[ 0 ] == "EntireSpawn" )
                                {
                                    if( StrToInt( temp[ 1 ], mem ) )
                                        memData[ Farm::Constant::Container::Data::EntId ] = mem;
                                }
                                else if( temp[ 0 ] == "BorderChance" )
                                {
                                    if( StrToInt( temp[ 1 ], mem ) )
                                        memData[ Farm::Constant::Container::Data::RespawnBorderChance ] = mem;
                                }
                                else if( temp[ 0 ] == "Chance" )
                                {
                                    if( StrToInt( temp[ 1 ], mem ) )
                                        memData[ Farm::Constant::Container::Data::RespawnChance ] = mem;
                                }
                                else if( temp[ 0 ] == "NoCreate" )
                                {
                                    if( StrToInt( temp[ 1 ], mem ) )
                                        memData[ Farm::Constant::Container::Data::NoCreate ] = mem;
                                }
                                else if( temp[ 0 ] == "Script" )
                                    @strScript = temp[ 1 ];
                            }
                        }

                        if( pid > countCont )
                        {
                            countCont = pid;
                            Farm::AllFarmContainer.resize( countCont );
                        }

                        @Farm::AllFarmContainer[ pid - 1 ] = FarmContainer( pid );
                        ( Farm::AllFarmContainer[ pid - 1 ] ).Initialize( memData, pids, bags, strScript );
                    }
                }
            }
        }
    }
}

void InitializeLocations( string path )
{
	file       f;

    string     str = "";
    string@[] data1, temp, line;
    int        mem = -1;
	
	{
        if( f.open( path, "r" ) != -1 )
        {
            str = "";
            f.readString( uint( f.getSize() ), str );
            f.close();
            data1 = splitEx( str, "[FarmLocation]" );
            str = "";

            uint iEnd = data1.length();
            if( iEnd > 1 )
            {
                temp = splitEx( data1[ 0 ], "=" );
                mem = 0;
                if( StrToInt( temp[ 1 ], mem ) )
                {
                    uint countLoc = mem;
                    Farm::AllLocs.resize( countLoc );
                    array< string@ >@ memSt;
                    for( uint i = 1; i < iEnd; i++ )
                    {
                        uint pid = 0;
                        array< uint8 > ProtectMask( 0 );
                        array< uint >  memData( uint( Farm::Constant::FLocation::Data::CountData ) ),
                        teamIds( 0 ), conids( 0 ), pids( 0 );
                        line = splitEx( data1[ i ], "\n" );
                        string@ nameLoc = null;
                        for( uint iline0 = 0, iline0End = line.length(); iline0 < iline0End; iline0++ )
                        {
                            temp = splitEx( line[ iline0 ], "=" );
                            if( temp[ 0 ] == "Pid" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    pid = mem;
                            }
                            else if( temp[ 0 ] == "Time" )
                            {
                                @memSt = splitEx( temp[ 1 ], "-" );
                                if( memSt.length() > 0 )
                                {
                                    if( StrToInt( memSt[ 0 ], mem ) )
                                        memData[ Farm::Constant::FLocation::Data::TimeDelete_Min ] = mem;
                                    memData[ Farm::Constant::FLocation::Data::TimeDelete_Max ] = mem;
                                }
                                if( memSt.length() > 1 )
                                {
                                    if( StrToInt( memSt[ 1 ], mem ) )
                                        memData[ Farm::Constant::FLocation::Data::TimeDelete_Max ] = mem;
                                }

                                // if( StrToInt( temp[ 1 ], mem ) )
                                //	memData[ Farm::Constant::FLocation::Data::TimeDelete ] = mem;
                            }
                            else if( temp[ 0 ] == "PrivateTimeouts" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::FLocation::Data::PrivateTimeouts ] = mem;
                            }
                            else if( temp[ 0 ] == "GlobalTimeouts" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::FLocation::Data::GlobalTimeouts ] = mem;
                            }
                            else if( temp[ 0 ] == "CountPlayerMin" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::FLocation::Data::CountPlayerMin ] = mem;
                            }
                            else if( temp[ 0 ] == "CountPlayerMax" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::FLocation::Data::CountPlayerMax ] = mem;
                            }
                            else if( temp[ 0 ] == "LevelMin" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::FLocation::Data::PlayerLevelMin ] = mem;
                            }
                            else if( temp[ 0 ] == "LevelMax" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::FLocation::Data::PlayerLevelMax ] = mem;
                            }
                            else if( temp[ 0 ] == "LocationPid" )
                            {
                                @memSt = splitEx( temp[ 1 ], " " );
                                for( uint j = 0, jMax = memSt.length(); j < jMax; j++ )
                                    if( StrToInt( memSt[ j ], mem ) )
                                        pids.insertLast( mem );
                            }
                            else if( temp[ 0 ] == "TeamMobs" )
                            {
                                @memSt = splitEx( temp[ 1 ], " " );
                                for( uint j = 0, jMax = memSt.length(); j < jMax; j++ )
                                    if( StrToInt( memSt[ j ], mem ) )
                                        teamIds.insertLast( mem );
                            }
                            else if( temp[ 0 ] == "Containers" )
                            {
                                @memSt = splitEx( temp[ 1 ], " " );
                                for( uint j = 0, jMax = memSt.length(); j < jMax; j++ )
                                    if( StrToInt( memSt[ j ], mem ) )
                                        conids.insertLast( mem );
                            }
                            else if( temp[ 0 ] == "Type" )
                            {
                                if( StrToInt( temp[ 1 ], mem ) )
                                    memData[ Farm::Constant::FLocation::Data::Type ] = mem;
                            }
                            else if( temp[ 0 ] == "ProtectMask" )
                            {
                                const uint lenStr = temp[ 1 ].length();
                                for( uint iline1 = 0; iline1 < lenStr; iline1++ )
                                {
                                    if( temp[ 1 ][ iline1 ] == '0' )
                                        ProtectMask.insertLast( 0 );
                                    else if( temp[ 1 ][ iline1 ] == '1' )
                                        ProtectMask.insertLast( 1 );
                                    else
                                        Log( "Error - ProtectMask" );
                                }
                            }
                            else if( temp[ 0 ] == "Name" )
                                @nameLoc = temp[ 1 ];
                        }

                        if( pid > countLoc )
                        {
                            countLoc = pid;
                            Farm::AllLocs.resize( countLoc );
                        }

                        @Farm::AllLocs[ pid - 1 ] = FarmLocation( pid );
                        ( Farm::AllLocs[ pid - 1 ] ).Initialize( pids, memData, teamIds, conids, ProtectMask );
                        if( nameLoc !is null )
                            Farm::AllLocs[ pid - 1 ].Name = nameLoc;
                    }
                }
            }
        }
    }
}

void InitializeFarmLocation()
{
	InitializeBags( "data\\farm_locations\\Bags.fofarmloc" );
	InitializeCritters( "data\\farm_locations\\Critter.fofarmloc" );
	InitializeTeamCritters( "data\\farm_locations\\TeamCritter.fofarmloc" );
	InitializeContainers( "data\\farm_locations\\Container.fofarmloc" );
	InitializeLocations( "data\\farm_locations\\Locations.fofarmloc" );
}

enum FarmAddItemFlag
{
	None,
	NoSlot
}

final class FarmMob : Farm::Mob
{
    FarmMob( const uint &in id )
    {
        super( id );
    }

    void Initialize( const array< uint >& in data, const array< Farm::Param@ >& in params, string@ script ) override
    {
        if( data.length() == uint( Farm::Constant::Mob::Data::CountData ) )
        {
            ProtoId = data[ Farm::Constant::Mob::Data::Proto ];
            BagId = data[ Farm::Constant::Mob::Data::Bag ];
            IsInit = 0;
            Param = params;
            Type = data[ Farm::Constant::Mob::Data::Type ];
            TypeVar = data[ Farm::Constant::Mob::Data::TypeVar ];
            @ AiScript = script;
            if( Type == uint( Farm::Constant::Mob::E_Type::Dead ) )
            {
                if( TypeVar < ANIM2_DEAD_BEGIN || TypeVar >= ANIM2_DEAD_END )
                    TypeVar = ANIM2_DEAD_FRONT;
            }
            else if( Type == uint( Farm::Constant::Mob::E_Type::AI ) )
            {
                switch( TypeVar )
                {
                case Farm::Constant::Mob::E_AI::Slayer:
                {
                    @ AiScript = "pattern_slayer@_CritterInit";
                } break;
                case Farm::Constant::Mob::E_AI::Sniper:
                {
                    @ AiScript = "pattern_sniper@_CritterInit";
                } break;
                case Farm::Constant::Mob::E_AI::Term:
                {
                    @ AiScript = "pattern_term@_CritterInit";
                } break;
                default:
                    break;
                }
            }
        }

    }

    array< int >@ GetAddItems() override
    {
        if( BagId == 0 )
            return null;
        array< int > items;

        SlotBags@ slot = Farm::AllBags[ BagId - 1 ].getSlot();
        if( slot is null || slot.Items is null )
            return null;

        uint endItems = 0;
        int rand = 0, count = 0;
        for( uint i = 0, iEnd = slot.Items.length(); i < iEnd; i++ )
        {
            FarmItem@ fi = slot.Items[ i ][ Random( 0, slot.Items[ i ].length() - 1 ) ];

            if( fi !is null )
            {
                rand = Random( 1, 100 );
                if( rand <= fi.Percent || fi.Percent == 0 )
                {
                    count = Random( fi.Count.Min, fi.Count.Max );

                    items.insertLast( fi.ItemPid );
                    items.insertLast( count );
                    items.insertLast( fi.ItemSlot );

                    endItems++;
                }
            }
        }
        return items;
    }

    void InitCritter( Critter& inout mob ) override
    {
        if( mob.GetScriptId() == 0 && ( mob.Stat[ ST_TEAM_ID ] == 0 || ( mob.Stat[ ST_TEAM_ID ] >= 24 && mob.Stat[ ST_TEAM_ID ] <= 33 ) || mob.Stat[ ST_TEAM_ID ] == TEAM_FarmMobs ) )
            mob.SetScript( "Mk2@Mob::_MobInit" );

        uint additemFlag = FarmAddItemFlag::None;

        if( Type == uint( Farm::Constant::Mob::E_Type::Dead ) )
        {
            mob.ToDead( TypeVar, null );
            additemFlag = FarmAddItemFlag::NoSlot;
        }

        mob.FarmProtoMobId = Id;
        mob.IsFarmGenerated = true;

        if( BagId != 0 && BagId <= Farm::AllBags.length() )
        {
            FarmBags@ bag = ( Farm::AllBags[ BagId - 1 ] );
            if( bag !is null )
            {
                SlotBags@ slot = bag.getSlot();
                if( slot !is null )
                {
                    array< FarmItem@ >@ Its = null;
                    array< array< FarmItem@ > >@ Items = slot.Items;
                    FarmItem@ fi = null;

                    if( Items !is null )
                    {
                        for( uint i = 0, iEnd = Items.length(); i < iEnd; i++ )
                        {
                            @ Its = Items[ i ];
                            if( Its !is null && Its.length() > 0  )
                            {
                                @ fi = Its[ Random( 0, Its.length() - 1 ) ];
                                if( fi !is null )
                                    fi.AddItem( mob, additemFlag );
                            }
                        }
                    }
                }
            }
        }
    }
}

final class FarmTeamMob : Farm::TeamMobs
{
    FarmTeamMob( const uint &in id )
    {
        super( id );
    }

    void Initialize( const array< uint >& in critterIds, const uint& in entId, const uint& in min, const uint& in max, const array< Farm::Param@ >& in params, const bool& in isStatic ) override
    {
        Critters = critterIds;
        EntireSpawn = entId;
        CountMobs.Min = min;
        CountMobs.Max = max;
        GeneralParams = params;
        StaticCount = isStatic;
        GeneralParamsLength = GeneralParams.length();
        CrittersCount = Critters.length();
        IsInit = 0;
    }

    void Generate( Map& map, const uint8& in countPlayer, /* ToDo: */ uint& inout mapMobUID, array< uint >& values  ) override
    {
        FarmMob@ mob = null;
        Critter@ cr = null;
        // array< int > params;

        uint mapId = map.Id;

        uint16 hexX = 0, hexY = 0, hx = 0, hy = 0;
        uint CountMob = 0, ui0 = 0, ui1 = 0, ui2 = 0, maxMob = CountMobs.Max, Radius = 0;
        int xDelta = 0, yDelta = 0;
		
        if( !StaticCount )
			Farm::FixValue( maxMob, countPlayer, 30 );

        const uint16 mapWidth =  map.GetWidth() - 5,
                  mapHeight =  map.GetHeight() - 5;
        array< int > paramsSpawn;
        const uint ui0End = GetFarmEntire( map, paramsSpawn, SPAWN_ENTIRE_PID_MOB, EntireSpawn );
        // endMapMobUID = mapMobUID + maxMob * ui0End;

        while( ui0 < ui0End )
        {
            /*
               MapId
               MobId
               MobTeamId
               HexX
               HexY
             */

            {
                hexX = paramsSpawn[ SE_FARM_COUNT_MASK_PARAM * ui0 + SE_FARM_X ];
                hexY = paramsSpawn[ SE_FARM_COUNT_MASK_PARAM * ui0 + SE_FARM_Y ];
                Radius = paramsSpawn[ SE_FARM_COUNT_MASK_PARAM * ui0 + SE_FARM_RADIUS ];
                CountMob = Random( CountMobs.Min, CountMobs.Max );

                if( map.IsHexPassed( hexX, hexY ) )
                {
                    values.insertLast( mapId );
                    values.insertLast( Critters[ Random( 0, CrittersCount - 1 ) ] - 1 );
                    values.insertLast( Id );
                    values.insertLast( hexX );
                    values.insertLast( hexY );
                    values.insertLast( countPlayer );
                    CountMob--;

                    /*@ mob = (Farm::AllMobs[ Critters[ Random( 0, CrittersCount - 1 ) ] - 1 ]);
                       if( mob !is null )
                       {
                            params.resize( 0 );
                            params.insertLast( ST_IS_FARM_CRITTER );
                            params.insertLast( mob.Id );
                            params.insertLast( ST_REPLICATION_TIME );
                            params.insertLast( -1 );
                            params.insertLast( ST_ROLE_CITY );
                            params.insertLast( CITY_NONE_PROTECT );
                            for( ui1 = 0; ui1 < mob.Param.length( ); ui1 ++ )
                            {
                                    params.insertLast( mob.Param[ui1].Index );
                                    params.insertLast( mob.Param[ui1].GetValue( countPlayer ) );
                            }
                            for( ui1 = 0; ui1 < GeneralParamsLength; ui1 ++ )
                            {
                                    params.insertLast( GeneralParams[ ui1 ].Index );
                                    params.insertLast( GeneralParams[ ui1 ].GetValue( countPlayer ) );
                            }
                            @ cr = map.AddNpc( mob.ProtoId, hexX, hexY, Random( 0, 5 ), params, null, mob.AiScript );
                            if( cr !is null )
                                    mob.InitCritter( cr );
                            CountMob--;
                       }*/
                }

                while( 0 < CountMob )
                {
                    hx = hexX;
                    hy = hexY;
                    if( hx == 0 || hy == 0 || hx >= mapWidth || hy >= mapHeight )
                    {
                        CountMob--;
                        continue;
                    }

                    ui2 = 10;
                    while( ui2-- > 0 )
                    {
                        xDelta = Random( 0 - Radius, Radius );
                        yDelta = Random( 0 - Radius, Radius );
                        uint length = map.GetPathLength( hx, hy, hx + xDelta, hy + yDelta, 0 );
                        if( map.IsHexPassed( hx + xDelta, hy + yDelta ) &&
                            ( ( xDelta == 0 && yDelta == 0 ) || ( length != 0 && length < Radius * 2 ) ) )
                        {
                            // Log("Length" + Length +" Radius" +Radius);
                            values.insertLast( mapId );
                            values.insertLast( Critters[ Random( 0, CrittersCount - 1 ) ] - 1 );
                            values.insertLast( Id );
                            values.insertLast( hx + xDelta );
                            values.insertLast( hy + yDelta );
                            values.insertLast( countPlayer );

                            /*@ mob = (Farm::AllMobs[ Critters[ Random( 0, CrittersCount - 1 ) ] - 1 ]);
                               if( mob !is null )
                               {
                                    params.resize( 0 );
                                    params.insertLast( ST_IS_FARM_CRITTER );
                                    params.insertLast( mob.Id );
                                    params.insertLast( ST_REPLICATION_TIME );
                                    params.insertLast( -1 );
                                    params.insertLast( ST_ROLE_CITY );
                                    params.insertLast( CITY_NONE_PROTECT );
                                    for( ui1 = 0; ui1 < mob.Param.length( ); ui1 ++ )
                                    {
                                            params.insertLast( mob.Param[ui1].Index );
                                            params.insertLast( mob.Param[ui1].GetValue( countPlayer ) );
                                    }
                                    for( ui1 = 0; ui1 < GeneralParamsLength; ui1 ++ )
                                    {
                                            params.insertLast( GeneralParams[ ui1 ].Index );
                                            params.insertLast( GeneralParams[ ui1 ].GetValue( countPlayer ) );
                                    }
                                    @ cr = map.AddNpc( mob.ProtoId, hx + xDelta, hy + yDelta, Random( 0, 5 ), params, null, mob.AiScript );
                                    if( cr !is null )
                                            mob.InitCritter( cr );
                               }*/
                            break;
                        }
                    }
                    CountMob--;
                }
            }
            ui0++;
        }
        // mapMobUID = endMapMobUID;
    } 
}

final class FarmBags // : Farm::CProto
{
    FarmBags( const uint &in id, const SlotBags@[] & in slots ) final
    {
        ProtoType = Farm::Constant::E_ProtoType::EPT_Bags;
        Id = id;
        Slots = slots;
        MaxPercent = 1000;
    }

    FarmBags@ opAdd( const FarmBags& in other ) final
    {
        for( uint i = 0, iEnd = other.Slots.length(); i < iEnd; i++ )
            Slots.insertLast( other.Slots[ i ] );
        Initialize();
        return this;
    }

    FarmBags@ opAdd( const array< FarmBags@ >& in other ) final
    {
        for( uint n = 0, nEnd = other.length(); n < nEnd; n++ )
            for( uint i = 0, iEnd = other[ n ].Slots.length(); i < iEnd; i++ )
                Slots.insertLast( other[ n ].Slots[ i ] );
        Initialize();
        return this;
    }

    FarmBags@ opAddAssign( const FarmBags& in other ) final
    {
        for( uint i = 0, iEnd = other.Slots.length(); i < iEnd; i++ )
            Slots.insertLast( other.Slots[ i ] );
        Initialize();
        return this;
    }

    FarmBags@ opAddAssign( const array< FarmBags@ >& in other ) final
    {
        for( uint n = 0, nEnd = other.length(); n < nEnd; n++ )
            for( uint i = 0, iEnd = other[ n ].Slots.length(); i < iEnd; i++ )
                Slots.insertLast( other[ n ].Slots[ i ] );
        Initialize();
        return this;
    }

    void Initialize() final
    {
        if( Slots.length() > 0 )
        {
            IsInit = 0;

            array< SlotBags@ > slotsNoPercent;
            int Percent = MaxPercent;
            for( uint i = 0, iEnd = Slots.length(); i < iEnd; i++ )
            {
                if( Slots[ i ].Percent == 0 )
                    slotsNoPercent.insertLast( Slots[ i ] );
                else
                    Percent -= Slots[ i ].Percent;
            }

            uint iEnd = slotsNoPercent.length();
            if( iEnd > 0 )
            {
                int percent = Percent / iEnd;

                if( Percent < percent )
                {
                    MaxPercent += percent - Percent;
                    Percent = percent;
                }

                for( uint i = 0; i < iEnd; i++ )
                {
                    slotsNoPercent[ i ].Percent = percent;
                    Percent -= percent;
                }
            }
            MaxPercent -= Percent;
        }
    }

    SlotBags@ getSlot() final
    {
		if( Slots is null )
			return null;
			
        int Percent = Random( 1, MaxPercent ), oldP = 0;
        uint iEnd = Slots.length();
        if( iEnd == 0 )
            return null;
        for( uint i = 0; i < iEnd; i++ )
        {
            if( Slots[ i ].Percent + oldP >= ( Percent ) )
                return Slots[ i ];

            oldP += Slots[ i ].Percent;
        }

        return Slots[ Random( 0, iEnd - 1 ) ];
    }

    array< SlotBags@ > Slots;
    string@ DefName;
    uint MaxPercent;


    bool IsInitialize() final
    {
        return ( IsInit != 1 );
    }

    private uint8 IsInit;
    Farm::Constant::E_ProtoType ProtoType;
    uint Id;
}

final class SlotBags
{
    SlotBags( const array< array< FarmItem@ > >&in its, const uint& in percent = 0 ) final
    {
        Items = its;
        Percent = percent;
    }

    int Percent;
    array< SlotBags@ > SubBags;
    array< array< FarmItem@ > > Items;
}

final class FarmItem
{
    FarmItem( const uint &in pid, string@ funcCreated, string@ funcIsCreated, uint keyId = 0, array< FarmItem@ >@ sub = null ) final
    {
        ItemPid = pid;
        Count.Min = 1;
        Count.Max = 1;
        ItemSlot = 0;
        Percent = 0;
        KeyId = keyId;
        IsBluePrint = false;
        BluePrint_Pid = 0;
        BluePrint_Count = 0;

        FuncCreatedId = 0;
        FuncIsCreatedId = 0;

        if( funcCreated !is null )
        {
            array< string@ > Createds = splitEx( funcCreated, "@" );
            if( Createds.length() == 2 )
                FuncCreatedId = BindFarmScript( Createds[ 0 ], Createds[ 1 ] );
        }
        if( funcIsCreated !is null )
        {
            array< string@ > IsCreateds = splitEx( funcIsCreated, "@" );
            if( IsCreateds.length() == 2 )
                FuncIsCreatedId = BindFarmScript( IsCreateds[ 0 ], "bool " + IsCreateds[ 1 ] + "(FarmItem& farmIt, int typeCreate, uint idCreate, uint16 hexX, uint16 hexY)" );
        }
        @SubItems = sub;
    }

    uint AddItem( Critter& inout cr, const uint& in flag, const bool& in isSub = false ) final
    {
        uint count = 0;
        if( Random( 1, 100 ) <= Percent || Percent == 0 )
        {
            Item@ it = null;
            if( IsBluePrint )
                @it = Farm::AddBlueprint( cr, BluePrint_Pid, BluePrint_Count );
            else
                @it = cr.AddItem( ItemPid, Random( Count.Min, Count.Max ) );

            if( it !is null )
            {
                GameVar@ var = GetLocalVar( LIVAR_IsFarmGenerated, it.Id );
                if( var !is null )
                    var = cr.GetMap().GetLocation().Id;

                it.LockerId = KeyId;

                count++;
                if( flag != FarmAddItemFlag::NoSlot )
				{
					cr.MoveItem( it.Id, it.GetCount(), ItemSlot );
#ifndef __NO_FAVORIT_ITEMS
					if( ItemSlot > SLOT_INV && ItemSlot < SLOT_GROUND )
						cr.SetFavoriteItem( ItemSlot, ItemPid );
#endif
				}
				if( SubItems !is null && !isSub )
					for( uint i = 0, iEnd = SubItems.length(); i < iEnd; i++ )
						count += SubItems[ i ].AddItem( cr, flag, true );
			}
        }
        return count;
    }

    uint AddItem( Item& inout cont, const uint& in countPlayer, const bool& in isSub = false  ) final
    {
        uint count = 0;
        int perc = Percent;
        Farm::FixValue( perc, countPlayer, 30 );

        if( Random( 1, 100 ) <= perc || Percent == 0 )
        {
            Item@ it = null;
            uint maxCount = Count.Max;
            if( maxCount > 1 )
				Farm::FixValue( maxCount, countPlayer, 30 );

            if( IsBluePrint )
				@ it = Farm::AddBlueprint( cont, BluePrint_Pid, BluePrint_Count );
			else
				@ it = cont.AddItem( ItemPid, Random( Count.Min, maxCount ), 0 );

			if( it !is null )
			{
				uint16 temp = 0;
				GameVar@ var = GetLocalVar( LIVAR_IsFarmGenerated, it.Id );
				if( var !is null )
					var = cont.GetMapPosition( temp, temp ).GetLocation().Id;
				it.LockerId = KeyId;

				count++;
				if( SubItems !is null && !isSub )
					for( uint i = 0, iEnd = SubItems.length(); i < iEnd; i++ )
						count += SubItems[ i ].AddItem( cont, countPlayer, true );
			}
        }
        return count;
    }

    uint AddItem( Map& inout map, const uint16& in hexX, const uint16& in hexY, const uint& in countPlayer, const bool& in isSub = false  ) final
    {
        uint count = 0;
        int perc = Percent;
        Farm::FixValue( perc, countPlayer, 30 );

        if( Random( 1, 100 ) <= perc || Percent == 0 )
        {
            Item@ it = null;
            uint maxCount = Count.Max;
            if( maxCount > 1 )
				Farm::FixValue( maxCount, countPlayer, 30 );

			if( IsBluePrint )
				@ it = Farm::AddBlueprint( map, hexX, hexY, BluePrint_Pid, BluePrint_Count );
			else
				@ it = map.AddItem( hexX, hexY, ItemPid, Random( Count.Min, maxCount ) );

			if( it !is null )
			{
				GameVar@ var = GetLocalVar( LIVAR_IsFarmGenerated, it.Id );
				if( var !is null )
					var = map.GetLocation().Id;
				it.LockerId = KeyId;
				count++;
				if( SubItems !is null && !isSub )
					for( uint i = 0, iEnd = SubItems.length(); i < iEnd; i++ )
						count += SubItems[ i ].AddItem( map, hexX, hexY, countPlayer, true );
			}
        }
        return count;
    }

    uint ItemPid;
    Farm::UintPoint Count;

    int Percent;
    uint ItemSlot;

    bool IsBluePrint;
    uint16 BluePrint_Pid;
    uint16 BluePrint_Count;

    uint FuncCreatedId;
    uint FuncIsCreatedId;

    uint KeyId;

    array< FarmItem@ >@ SubItems;
    dictionary Params;
}

final class FarmContainer // : Farm::CProto
{
    FarmContainer( const uint &in id ) final
    {
        ProtoType = Farm::Constant::E_ProtoType::EPT_Container;
        Id = id;
        EntireSpawn = 0;
        Chance.Min = 0;
        Chance.Max = 0;
        NoCreate = false;
        @ Script = null;
    }

    void Generate( Map& map, const uint& in countPlayer ) final
    {
        #ifdef __DEBUG
        if( NoCreate )
            DL( "Деббаг генерации вещей в существующем контейнере." );
        DL( " Генерация контейнера энтайри " + EntireSpawn + " Сумок " + BagId.length() + "Шансы " + Chance.Max + "\\" + Chance.Min );

        uint countGen = 0, cickle = 0;
        #endif

        uint16 hexX = 0, hexY = 0;
        Item@ cont = null;
        SlotBags@ slot = null;
        FarmItem@ fi = null;
        Item@ it = null;
        array< array< FarmItem@ > >@ Items = null;
        array< FarmItem@ >@ Its = null;

        const uint  countBags = BagId.length(),
                    countPids = ProtoId.length();

        int isModule = 0;

        if( countBags != countPids )
            isModule = ( countBags > countPids ) ? ( -1 ) : ( 1 );

        if( countPids == 0 || countBags == 0 )
            return;

        array< int > paramsSpawn;
        int OffX = 0,
            OffY = 0;

        for( uint i = 0, iEnd = GetFarmEntire( map, paramsSpawn, SPAWN_ENTIRE_PID_CONT, EntireSpawn ); i < iEnd; i++ )
        {
            #ifdef __DEBUG
            cickle++;
            #endif
            @ cont = null;
            hexX = paramsSpawn[ SE_FARM_COUNT_MASK_PARAM * i + SE_FARM_X ];
            hexY = paramsSpawn[ SE_FARM_COUNT_MASK_PARAM * i + SE_FARM_Y ];
            OffX = paramsSpawn[ SE_FARM_COUNT_MASK_PARAM * i + SE_FARM_OFFSET_X ];
            OffY = paramsSpawn[ SE_FARM_COUNT_MASK_PARAM * i + SE_FARM_OFFSET_Y ];
            if( ( map.IsHexPassed( hexX, hexY ) || NoCreate ) && ( Chance.Max == 0 || uint( Random( 0, Chance.Max ) ) <= Chance.Min ) )
            {
                uint indexPid = Random( 0, countPids - 1 );
                uint pid = ProtoId[ indexPid ];
                int bagId = -1;

                if( isModule == 0 )
                {
                    bagId = BagId[ indexPid ][ Random( 0, BagId[ indexPid ].length() - 1 ) ];
                }
                else if( isModule > 0 )
                {
                    array< uint >@ arr = BagId[ indexPid % countBags ];
                    bagId = arr[ Random( 0, arr.length() - 1 ) ];
                }
                else                 // ToDo
                {
                    bagId = BagId[ indexPid ][ Random( 0, BagId[ indexPid ].length() - 1 ) ];
                }

                if( bagId <= 0 || uint( bagId ) > Farm::AllBags.length() )
                {
                    #ifdef __DEBUG
                    if( NoCreate )
                        DL( "Айди сумки некорректен." );
                    #endif
                    continue;
                }

                FarmBags@ bag = ( Farm::AllBags[ bagId - 1 ] );
                if( bag is null )
                {
                    DL( "Сумка не созданна." );
                    continue;
                }
                bool isCont = false;


                if( NoCreate )
                {
                    DL( "No created container. Search cont." );
                    Item@[] its;
                    for( uint c = 0, cm = map.GetItems( hexX, hexY, its ); c < cm; c++ )
                    {
                        if( its[ c ] !is null && its[ c ].GetType() == ITEM_TYPE_CONTAINER )
                        {
                            @ cont  = its[ c ];
                            isCont = true;
                            break;
                        }
                    }
                    #ifdef __DEBUG
                    if( cont !is null )
                        DL( "Success." );
                    else
                        DL( "Fail." );
                    #endif
                }
                else
                {
                    @ cont = map.AddItem( hexX, hexY, pid, 0 );
                    isCont = true;
                }

                if( cont !is null && Script !is null )
                    cont.SetScript( Script );

                if( isCont )
                {
                    if( cont !is null )
                    {
                        cont.OffsetX = OffX;
                        cont.OffsetY = OffY;
                        @ slot = bag.getSlot();
                        if( slot is null )
                            continue;

                        @ Items = slot.Items;
                        if( Items !is null )
						{
                            for( uint item_index = 0, item_index_end = Items.length(); item_index < item_index_end; item_index++ )
                            {
                                @Its = Items[ item_index ];
                                DL( " item_index_end " + item_index_end + " Its.length( ) " + Its.length() );
                                if( Its !is null  && Its.length() > 0 )
                                {
                                    uint rand = Random( 0, Its.length() - 1 );
                                    @ fi = Its[ rand ];
                                    if( fi !is null )
                                    {
                                        #ifdef __DEBUG
                                        countGen +=
                                        #endif
                                        fi.AddItem( cont, countPlayer );
                                    }
                                }
                            }
						}
                    }
                }
                else
                {
                    @ slot = bag.getSlot();
                    if( slot is null )
                        continue;

                    @ Items = slot.Items;
                    if( Items !is null )
					{
                        for( uint item_index = 0, item_index_end = Items.length(); item_index < item_index_end; item_index++ )
                        {
                            @ Its = Items[ item_index ];
                            DL( " item_index_end " + item_index_end + " Its.length( ) " + Its.length() );
                            if( Its !is null  && Its.length() > 0 )
                            {
                                uint rand = Random( 0, Its.length() - 1 );
                                @ fi = Its[ rand ];
                                if( fi !is null )
                                {
                                    #ifdef __DEBUG
                                    countGen +=
                                    #endif
                                    fi.AddItem( map, hexX, hexY, countPlayer );
                                }
                            }
                        }
					}
				}
            }
            #ifdef __DEBUG
            else if( NoCreate )
                DL( "No Hex." );
            #endif
        }

        #ifdef __DEBUG
        if( NoCreate )
            DL( "Сгенерированно: " + countGen + " вещей. Энтайри найдено: " + cickle );
        #endif
    }

    void Initialize( const array< uint >& in data, const array< uint >& in pids, const array< array< uint > >& in bagIds, string@ script ) final
    {
        if( data.length() == uint( Farm::Constant::Container::Data::CountData ) )
        {
            ProtoId = pids;
            BagId = bagIds;
            EntireSpawn = data[ Farm::Constant::Container::Data::EntId ];
            Chance.Min = data[ Farm::Constant::Container::Data::RespawnChance ];
            Chance.Max = data[ Farm::Constant::Container::Data::RespawnBorderChance ];
            NoCreate = data[ Farm::Constant::Container::Data::NoCreate ] != 0;
            IsInit = 0;

            @ Script = script;
        }
    }

    bool NoCreate;

    Farm::UintPoint Chance;

    uint EntireSpawn;

    array< array< uint > > BagId;
    array< uint > ProtoId;


    bool IsInitialize() final
    {
        return ( IsInit != 1 );
    }

    private uint8 IsInit;
    Farm::Constant::E_ProtoType ProtoType;
    uint Id;
    string@ Script;
}

bool DefferedSpawn = true;

class FarmLocation
{
    FarmLocation( const uint &in id )
    {
        ProtoType = Farm::Constant::E_ProtoType::EPT_Location;
        Farm::AllLocs.insertLast( this );
        Id = id;
        TimeMin = 0;
        TimeMax = 0;
        Name = "FarmLoc_" + id;

        PrivateTimeouts = 0;
        GlobalTimeouts = 0;
        GlobalTimeouts_Timer = 0;
    }

    void Initialize( array< uint >& in pids, const array< uint >& in data, const array< uint >& in teamIds, const array< uint >& in conIds, const array< uint8 >& in protectMask ) final
    {
        if( pids.length() == 0 )
            return;

        if( data.length() == uint( Farm::Constant::FLocation::Data::CountData ) )
        {
            ProtoId = pids;
            Type = data[ Farm::Constant::FLocation::Data::Type ];
            IsInit = 0;
            TeamMobIds = teamIds;
            ContainerIds = conIds;
            ProtectMask = protectMask;
            CountPlayer.Min = data[ Farm::Constant::FLocation::Data::CountPlayerMin ];
            CountPlayer.Max = data[ Farm::Constant::FLocation::Data::CountPlayerMax ];
            PrivateTimeouts = data[ Farm::Constant::FLocation::Data::PrivateTimeouts ];
            GlobalTimeouts = data[ Farm::Constant::FLocation::Data::GlobalTimeouts ];
            PlayerLevel.Min = data[ Farm::Constant::FLocation::Data::PlayerLevelMin ];
            PlayerLevel.Max = data[ Farm::Constant::FLocation::Data::PlayerLevelMax ];

            TimeMin = data[ Farm::Constant::FLocation::Data::TimeDelete_Min ];
            TimeMax = data[ Farm::Constant::FLocation::Data::TimeDelete_Max ];
        }
    }

    void Refresh( const uint& in locId, const uint16& in worldX, const uint16& in worldY ) final
    {
        DeleteLocation( locId );
        Create( worldX, worldY );
    }

    Location@ CreateHideLoc( const uint& in worldX, const uint& in worldY ) final
    {
        Location@ loc = Create( worldX, worldY );
        if( loc !is null )
            loc.Visible = false;
        return loc;
    }

    Location@ Create( const uint& in worldX, const uint& in worldY, array< Critter@ >@ players = null ) final
    {
        if( IsInit != 1 )
        {
            array< uint > values;

            uint locPid = ProtoId[ Random( 0, ProtoId.length() - 1 ) ],
                 countPlayer = players !is null ? players.length() : 0,
                 locId = locPid != 0 ? CreateLocation( locPid, worldX, worldY, players ) : 0;

            Location@ loc = null;
            if( locId != 0 )
                @ loc = GetLocation( locId );
            if( loc !is null )
            {
                GlobalTimeouts_Timer = __FullSecond + REAL_MINUTE( GlobalTimeouts );
                loc.FarmLocPId = Id;
                if( players !is null )
                    loc.Visible = false;
                else
                    loc.Visible = true;
                array< Map@ > maps;
                int index = loc.GetMaps( maps ) - 1;

                {
                    Map@ m = null;
                    uint t = 0;
                    const uint countTeam = TeamMobIds.length(),
                               countContainer = ContainerIds.length();

                    bool isProtect = ( ProtectMask.length() > 0 && ProtectMask.length() == uint( index + 1 ) );
                    FarmContainer@ farmCont = null;
                    while( index >= 0 )
                    {
                        @ m = maps[ index ];

                        if( m !is null )
                        {
                            if( countPlayer < 0 )
                            {
                                m.SetData( Farm::Constant::RealMap::DefData::OffsetsAccess, countPlayer );
                                for( uint i = 0; i < countPlayer; i++ )
                                    m.SetData( Farm::Constant::RealMap::DefData::OffsetsAccess + 1 + i, players[ i ].Id );

                                m.SetEvent( MAP_EVENT_IN_CRITTER, "_FarmLocation_InPlayer" );
                            }
                            if( isProtect && ProtectMask[ index ] == 1 )
                                m.FarmMapIsProtect = true;
                            else
                                m.FarmMapIsProtect = false;
                            uint mapMobUID = 0;
                            for( t = 0; t < countTeam; t++ )
                            {
                                if( Farm::AllTeamMobs[ TeamMobIds[ t ] - 1 ] !is null )
                                    ( Farm::AllTeamMobs[ TeamMobIds[ t ] - 1 ] ).Generate( m, countPlayer, mapMobUID, values );
                                else
                                    ClearLog( "Не валидная фарм команда " + TeamMobIds[ t ] + " фармлокация " + Name );
                            }

                            for( t = 0; t < countContainer; t++ )
                            {
                                @ farmCont = ( Farm::AllFarmContainer[ ContainerIds[ t ] - 1 ] );
                                if( farmCont !is null )
                                    farmCont.Generate( m, countPlayer );
                            }

                            if( Type == uint( Farm::Constant::FLocation::E_Type::DeleteNoPlayer ) )
                                m.SetEvent( MAP_EVENT_OUT_CRITTER, "_FarmLocation_OutPlayerDelete" );
                        }
                        index--;
                    }
                }
                switch( Type )
                {
                case Farm::Constant::FLocation::E_Type::TimeDelete:
                {
                    if( Time != 0 )
                        loc.FarmLocTimeEventId = CreateTimeEvent( __FullSecond + REAL_MINUTE( Time ), "e_DeleteFarmLocation", loc.Id, true );
                } break;
                case Farm::Constant::FLocation::E_Type::TimeDeleteNoPlayer:
                {
                    if( Time != 0 )
                    {
                        array< uint > data = { loc.Id, Id };
                        loc.FarmLocTimeEventId = CreateTimeEvent( __FullSecond + REAL_MINUTE( Time ), "e_RefreshFarmLocation2", data, true );
                    }
                } break;
                case Farm::Constant::FLocation::E_Type::TimeRefresh:
                {
                    if( Time != 0 )
                    {
                        array< uint > data = { loc.Id, Id };
                        loc.FarmLocTimeEventId = CreateTimeEvent( __FullSecond + REAL_MINUTE( Time ), "e_RefreshFarmLocation", data, true );
                    }
                } break;
                default:
                    break;
                }

                if( values.length() > 0 )
				{
					if( DefferedSpawn )
						CreateTimeEvent( __FullSecond + 50, "e_AddMob", values, true );
					else SpawnMobs( values, 0 );
				}
            }
            // else Log("Фарм локация не создана.");
            return loc;
        }
        return null;
    }

    /*Farm::Constant::Dialog::Result::MinLevel
            {
                    LocCreate = 0,
                    MinTeam,
                    MaxTeam,
                    GlobalTimeouts,
                    PrivateTimeouts,
                    Else,
                    MinLevel,
                    MaxLevel,
                    CountResult
            }*/

    /*
       Farm::Constant::RealMap::DefData::OffsetsAccess
     */

    int isCreateLocation_Team( array< Critter@ >& in crs )
    {
        Critter@ cr;

        if( GlobalTimeouts != 0 && GlobalTimeouts_Timer > __FullSecond )
            return Farm::Constant::Dialog::Result::GlobalTimeouts;

        for( uint i = 0, iEnd = crs.length(); i < iEnd; i++ )
        {
            @ cr = crs[ i ];
            if( cr !is null )
            {
                if( PrivateTimeouts != 0 && PrivateTimeouts_Timer.exists( "" + cr.Id ) )
                {
                    int time = -1;
                    PrivateTimeouts_Timer.get( "" + cr.Id, time );
                    if( time != -1 && uint( time ) > __FullSecond )
                        return Farm::Constant::Dialog::Result::PrivateTimeouts;

                    PrivateTimeouts_Timer.delete( "" + cr.Id );
                }

                if( uint( cr.Stat[ ST_LEVEL ] ) < PlayerLevel.Min )
                    return Farm::Constant::Dialog::Result::MinLevel;
                if( uint( cr.Stat[ ST_LEVEL ] ) > PlayerLevel.Max && PlayerLevel.Max != 0 )
                    return Farm::Constant::Dialog::Result::MaxLevel;
            }
        }
        return Farm::Constant::Dialog::Result::LocCreate;
    }

    int isCreateLocation_Critter( Critter& cr )
    {
        if( GlobalTimeouts != 0 && GlobalTimeouts_Timer > __FullSecond )
            return Farm::Constant::Dialog::Result::GlobalTimeouts;

        if( PrivateTimeouts != 0 && PrivateTimeouts_Timer.exists( "" + cr.Id ) )
        {
            int time = -1;
            PrivateTimeouts_Timer.get( "" + cr.Id, time );
            if( time != -1 && uint( time ) > __FullSecond )
                return Farm::Constant::Dialog::Result::PrivateTimeouts;

            PrivateTimeouts_Timer.delete( "" + cr.Id );
        }

        return Farm::Constant::Dialog::Result::LocCreate;
    }

    void SetTimeouts( Critter@& inout cr )
    {
        if( cr !is null )
            PrivateTimeouts_Timer.set( "" + cr.Id, __FullSecond + REAL_MINUTE( PrivateTimeouts ) );
    }

    string Name;

    uint Type;
    uint TimeMin;
    uint TimeMax;

    const uint Time
    {
        get {
            return Random( TimeMin, TimeMax );
        }
    };

    uint PrivateTimeouts;
    dictionary PrivateTimeouts_Timer;

    uint GlobalTimeouts;
    uint GlobalTimeouts_Timer;

    array< uint > ProtoId;

    Farm::UintPoint CountPlayer;
    Farm::UintPoint PlayerLevel;

    array< uint8 > ProtectMask;
    array< uint > TeamMobIds;
    array< uint > ContainerIds;


    bool IsInitialize() final
    {
        return ( IsInit != 1 );
    }

    private uint8 IsInit;
    Farm::Constant::E_ProtoType ProtoType;
    uint Id;
}

void dlg_TeamNames( Critter& player, Critter@ npc, string@ lexems )
{
    if( IS_DIALOG_GENERATED( lexems ) )
    {
        lexems = "$myteam";
        array< Critter@ > crs;

        for( uint i = 0, l = player.GetFollowGroup( FIND_LIFE | FIND_ONLY_PLAYERS, crs ); i < l; i++ )
        {
            lexems += ( ( i == 0 ) ? "" : ", " ) + GetPlayerName( crs[ i ].Id );
        }
        if( crs.length() == 0 )
        {
            lexems += " ";
        }
    }
}

uint dlg_OutTeamPlayer( Critter& player, Critter@ npc, string@ lexems )
{
    if( IS_DIALOG_GENERATED( lexems ) )
    {
        lexems = "$myteam";
        array< Critter@ > crs;

        for( uint i = 0, l = player.GetFollowGroup( FIND_LIFE | FIND_ONLY_PLAYERS, crs ); i < l; i++ )
        {
            lexems += ( ( i == 0 ) ? "" : ", " ) + GetPlayerName( crs[ i ].Id );
        }
        if( crs.length() == 0 )
        {
            lexems += " ";
        }
    }
    else if( IS_DIALOG_SAY_MODE( lexems ) )
    {
        array< Critter@ > crs;
        Critter@ outCr = GetPlayer( lexems );
        if( outCr !is null )
        {
            const uint outId = outCr.Id,
                       id = player.Id;
            for( uint i = 0, l = player.GetFollowGroup( FIND_LIFE | FIND_ONLY_PLAYERS, crs ); i < l; i++ )
            {
                if( outId == crs[ i ].Id )
                {
                    if( id == uint( crs[ i ].Stat[ ST_FOLLOW_CRIT ] ) )
                        crs[ i ].StatBase[ ST_FOLLOW_CRIT ] = 0;
                    return 16;
                }
            }
        }
    }
    return 16;
}

uint e_DeleteFarmLocation( array< uint >@ values )
{
    if( values !is null )
    {
        Location@ loc = GetLocation( values[ 0 ] );
        if( validEngineObject( loc ) )
		{
            for( uint i = 0, iEnd = loc.GetMapCount(); i < iEnd; i++ )
            {
				if( loc.GetMapByIndex( i ).GetCritters( 0, FIND_ONLY_PLAYERS, null ) != 0 )
                {
                    for( uint imap = 0, imapEnd = loc.GetMapCount(); imap < imapEnd; imap++ )
                        loc.GetMapByIndex( imap ).SetEvent( MAP_EVENT_OUT_CRITTER, "_FarmLocation_OutPlayerDelete" );
                    return 0;
                }
		}	}
        DeleteLocation( values[ 0 ] );
    }
    return 0;
}

uint e_RefreshFarmLocation2( array< uint >@ values )
{
    if( values !is null )
    {
        Location@ loc = GetLocation( values[ 0 ] );
        if( validEngineObject( loc ) )
        {
            uint16  WorldX = loc.WorldX,
                    WorldY = loc.WorldY;

            for( uint i = 0, iEnd = loc.GetMapCount(); i < iEnd; i++ )
                if( loc.GetMapByIndex( i ).GetCritters( 0, FIND_ONLY_PLAYERS, null ) != 0 )
                {
                    for( uint imap = 0, imapEnd = loc.GetMapCount(); imap < imapEnd; imap++ )
                        loc.GetMapByIndex( imap ).SetEvent( MAP_EVENT_OUT_CRITTER, "_FarmLocation_OutPlayerRefresh" );
                    return 0;
                }

            ( Farm::AllLocs[ values[ 1 ] - 1 ] ).Refresh( values[ 0 ], WorldX, WorldY );
        }
        else
        {
            ( Farm::AllLocs[ values[ 1 ] - 1 ] ).Create( values[ 2 ], values[ 3 ] );
        }
    }
    return 0;
}

uint e_RefreshFarmLocation( array< uint >@ values )
{
    if( values !is null )
    {
        Location@ loc = GetLocation( values[ 0 ] );
        if( validEngineObject( loc ) )
        {
            uint16  WorldX = loc.WorldX,
                    WorldY = loc.WorldY;

            array< Critter@ > players;

            for( uint imap = 0, imapEnd = loc.GetMapCount(); imap < imapEnd; imap++ )
                for( uint icritter = 0, icritterEnd = loc.GetMapByIndex( imap ).GetCritters( 0, FIND_ONLY_PLAYERS, players ); icritter < icritterEnd; icritter++ )
                {
                    Map@ map = players[ icritter ].GetMap();
                    if( validEngineObject( map ) )
                        map.EventOutCritter( players[ icritter ] );
                    players[ icritter ].TransitToGlobal( false );
                }
            Farm::AllLocs[ values[ 1 ] - 1 ].Refresh( values[ 0 ], WorldX, WorldY );
        }
        else
        {
			if( values.length() != 4  )
			{
				Log( "Error create farmlocation: values incorrect <" + Farm::AllLocs[ values[ 1 ] - 1 ].Name + ">" );
				return 0;
			}
            Farm::AllLocs[ values[ 1 ] - 1 ].Create( values[ 2 ], values[ 3 ] );
        }
    }
    return 0;
}

void _FarmLocation_OutPlayerRefresh( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
    {
        Location@ loc = map.GetLocation();
        if( validEngineObject( loc ) )
            for( uint i = 0, iEnd = loc.GetMapCount(); i < iEnd; i++ )
                if( loc.GetMapByIndex( i ).GetCritters( 0, FIND_ONLY_PLAYERS, null ) != 0 )
                    return;

        uint16  WorldX = loc.WorldX,
                WorldY = loc.WorldY;

        int index = loc.FarmLocId;
        if( index > 0 )
            ( Farm::AllLocs[ index - 1 ] ).Refresh( loc.Id, WorldX, WorldY );
    }
}

void _FarmLocation_OutPlayerDelete( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
    {
        Location@ loc = map.GetLocation();
        if( validEngineObject( loc ) )
            for( uint i = 0, iEnd = loc.GetMapCount(); i < iEnd; i++ )
                if( loc.GetMapByIndex( i ).GetCritters( 0, FIND_ONLY_PLAYERS, null ) != 0 )
                    return;

        DeleteLocation( loc.Id );
    }
}

void _FarmLocation_InPlayer( Map& m, Critter& cr )
{
    if( cr.IsPlayer() )
    {
        uint countPlayer = m.GetData( Farm::Constant::RealMap::DefData::OffsetsAccess );
        for( uint i = 0; i < countPlayer; i++ )
            if( uint( m.GetData( Farm::Constant::RealMap::DefData::OffsetsAccess + 1 + i ) ) == cr.Id )
                return;

        cr.TransitToGlobal( false );
    }
}

void GenerateFarmLocation()
{
    DL( "Генерация фарм локаций" );

	DefferedSpawn = false;
    file f;
    if( f.open( "data\\farm_locations\\GlobalLocation.fofarmloc", "r" ) != -1 )
    {
        string str = "";
        f.readString( uint( f.getSize() ), str );
        f.close();
        int mem0 = 0, mem1 = 0, mem2 = 0;
        array< string@ > Data1 = splitEx( str, "\n" ), temp, temp1;
        for( uint i = 0, iEnd = Data1.length(); i < iEnd; i++ )
        {
            temp = splitEx( Data1[ i ], "@" );
            for( uint itemp = 0, itempEnd = temp.length(); itemp < itempEnd; itemp++ )
            {
                temp1 = splitEx( temp[ itemp ], "#" );
                if( temp1.length() > 0 && temp1[ 0 ] !is null && temp1[ 0 ].length() > 0 )
                {
                    temp1 = splitEx( temp1[ 0 ], " " );
                    if( temp1.length() >= 3 && StrToInt( temp1[ 0 ], mem0 ) && StrToInt( temp1[ 1 ], mem1 ) && StrToInt( temp1[ 2 ], mem2 ) )
                        ( Farm::AllLocs[ mem0 - 1 ] ).Create( mem1, mem2 );
                }
            }
        }
    }
	DefferedSpawn = true;
}

void CreateFarmLocationOneCritter( Critter& cr, uint farmLocId, uint x, uint y )
{
    array< Critter@ > crs = { cr };
    ( Farm::AllLocs[ farmLocId - 1 ] ).Create( x, y, crs );
}

void CreateFarmLocationTeamCritter( Critter& cr, uint farmLocId, uint x, uint y )
{
    FarmLocation@ fl = ( Farm::AllLocs[ farmLocId - 1 ] );
    if( fl !is null )
    {
        array< Critter@ > crs = { cr };
        uint count = cr.GetFollowGroup( FIND_LIFE | FIND_ONLY_PLAYERS, crs );
        if( fl.CountPlayer.Min > count )
            return;
        if( fl.CountPlayer.Max <= count && fl.CountPlayer.Max != 0 )
            return;
        fl.Create( x, y, crs );
    }
}

void r_CreateFarmLocationOneCritter( Critter& master, Critter@ slave, int x, int y, int farmLocPid )
{
    CreateFarmLocationOneCritter( master, farmLocPid, x, y );
}

void r_CreateFarmLocationTeamCritter( Critter& master, Critter@ slave, int x, int y, int farmLocPid )
{
    CreateFarmLocationTeamCritter( master, farmLocPid, x, y );
}

void r_CreateFarmLocation( Critter&, Critter@, int x, int y, int farmLocPid )
{
    ( Farm::AllLocs[ farmLocPid - 1 ] ).Create( x, y );
}

uint r_CreateFarmLocationTeamCritter( Critter& master, Critter@ slave, int pid, int x, int y, int rad, int res )
{
    FarmLocation@ fl = ( Farm::AllLocs[ pid - 1 ] );
    if( fl !is null )
    {
        array< Critter@ > crs = { master };
        uint count = master.GetFollowGroup( FIND_LIFE | FIND_ONLY_PLAYERS, crs );
        if( fl.CountPlayer.Min > count )
            return res + Farm::Constant::Dialog::Result::MinTeam;
        if( fl.CountPlayer.Max < count && fl.CountPlayer.Max != 0 )
            return res + Farm::Constant::Dialog::Result::MaxTeam;
        int var = fl.isCreateLocation_Team( crs );
        if( var != Farm::Constant::Dialog::Result::LocCreate )
            return res + var;
        var = 0;

        int worldX = Random( x - rad, x + rad );
        int worldY = Random( y - rad, y + rad );

        while( var++ < 10 )
        {
            if( ( GetImageColor( IMAGE_RELIEF, worldX, worldY ) & 0xF ) != 0 )
            {
                Location@[] locations;
                bool isFree = true;
                const uint countLoc = GetLocations( worldX, worldY, 9, locations );
                for( uint i = 0; i < countLoc; i++ )
                    if( master.IsKnownLoc( true, locations[ i ].Id ) )
                    {
                        isFree = false;
                        break;
                    }

                if( isFree && fl.Create( worldX, worldY, crs ) !is null )
                {
                    for( uint i = 0, iEnd = crs.length(); i < iEnd; i++ )
                        fl.SetTimeouts( crs[ i ] );

                    return res + Farm::Constant::Dialog::Result::LocCreate;
                }

                worldX = Random( x - rad, x + rad );
                worldY = Random( y - rad, y + rad );
            }
        }
    }
    return res + Farm::Constant::Dialog::Result::Else;
}

/*Farm::Constant::Dialog::Result
                        {
                                LocCreate = 0,
                                MinTeam,
                                MaxTeam,
                                GlobalTimeouts,
                                PrivateTimeouts,
                                Else,
                                CountResult
                        }*/

bool ItemIsFarmGenerated( Item& it, uint& out locId ) // Export
{
    GameVar@ var = GetLocalVar( LIVAR_IsFarmGenerated, it.Id );
    if( var !is null )
    {
        locId = var.GetValue();
        return locId != 0;
    }
    return false;
}

bool ItemIsFarmGenerated( Item& it, uint& out locId, uint& out farmId, array< uint >& out info ) // Export
{
    GameVar@ var = GetLocalVar( LIVAR_IsFarmGenerated, it.Id );
    if( var !is null )
    {
        locId = var.GetValue();

        return locId != 0;
    }
    return false;
}

// ~run farm_location CheckGlobalFarmLocation 0 0 0
void CheckGlobalFarmLocation( Critter& cr, int p0, int, int )
{
    CheckGlobalFarmLocation();
}

void CheckGlobalFarmLocation()
{
    DL( "Генерация фарм локаций" );
    file f;
    if( f.open( "data\\farm_locations\\GlobalLocation.fofarmloc", "r" ) != -1 )
    {
        string str = "";
        f.readString( uint( f.getSize() ), str );
        f.close();
        int id = 0, x = 0, y = 0, time = 0;
        array< string@ > Data1 = splitEx( str, "\n" ), temp, temp1;
        for( uint i = 0, iEnd = Data1.length(); i < iEnd; i++ )
        {
            temp = splitEx( Data1[ i ], "@" );
            for( uint itemp = 0, itempEnd = temp.length(); itemp < itempEnd; itemp++ )
            {
                temp1 = splitEx( temp[ itemp ], "#" );
                if( temp1.length() > 0 && temp1[ 0 ] !is null && temp1[ 0 ].length() > 0 )
                {
                    id = x = y = time = 0;
                    temp1 = splitEx( temp1[ 0 ], " " );
                    if( temp1.length() >= 3 && StrToInt( temp1[ 0 ], id ) && StrToInt( temp1[ 1 ], x ) && StrToInt( temp1[ 2 ], y ) )
                    {
                        if( temp1.length() >= 4 )
                            StrToInt( temp1[ 3 ], time );
                        Location@[] locations;
                        bool Free = true;
                        const uint countLoc = GetLocations( x, y, 50, locations );
                        for( uint iloc = 0; iloc < countLoc; iloc++ )
                        {
                            uint16 pidLoc =  locations[ iloc ].GetProtoId();
                            for( uint p = 0, pMax = ( Farm::AllLocs[ id - 1 ] ).ProtoId.length(); p < pMax; p++ )
                            {
                                if( pidLoc == ( Farm::AllLocs[ id - 1 ] ).ProtoId[ p ] )
                                {
                                    Free = false;
                                    break;
                                }
                            }
                            if( not Free )
                                break;
                        }
                        if( Free )
                        {
                            if( time == 0 )
                                ( Farm::AllLocs[ id - 1 ] ).Create( x, y );
                            else
                            {
                                array< uint > values = { id, x, y };
                                CreateTimeEvent( __FullSecond + REAL_MINUTE( time ), "e_CreateFarmLocation", values, true );
                            }
                        }
                    }
                }
            }
        }
    }
}

bool TestIsCreated( FarmItem& farmIt, int typeCreate, uint idCreate, uint16 hexX, uint16 hexY )
{
    // Log("IsCreated");
    return true;
}


/*
   MapId	0
   MobId	1
   MobTeamId	2
   HexX	3
   HexY	4
   CountPlayer	5
 */

#define COUNT_ADD_MOB_VALUES    6

uint e_CreateFarmLocation( array< uint >@ values )
{
    if( values.length() == 3 )
        ( Farm::AllLocs[ values[ 0 ] - 1 ] ).Create( values[ 1 ], values[ 2 ] );
    return 0;
}

bool SpawnMobs( array< uint >@ values, uint tick )
{
	if( values !is null && values.length() >= COUNT_ADD_MOB_VALUES && values.length() % COUNT_ADD_MOB_VALUES == 0 )
    {
        uint currentPos = values.length() / COUNT_ADD_MOB_VALUES,
			mapId = 0,
			ui1 = 0,
			countplayer = 0,
			countparams = 0,
			paramsize = 6,
			paramneedsize = 6;

        uint16 HexX = 0, HexY = 0, dir = 0, baseHx = 0, baseHy = 0;

        FarmTeamMob@ teamMobs = null;
        FarmMob@ mob = null;

        int[] params = { ST_IS_FARM_CRITTER, 0, ST_REPLICATION_TIME, -1, ST_ROLE_CITY, CITY_NONE_PROTECT };
		Map@ map = null;		
		
        while( currentPos-- != 0 )
        {
            @ mob = ( Farm::AllMobs[ values[ currentPos * COUNT_ADD_MOB_VALUES + 1 ] ] );
            if( mob !is null )
            {
				countplayer = values[ currentPos * COUNT_ADD_MOB_VALUES + 5 ];
                params[1] = mob.Id;
				paramneedsize = 6;
				
				countparams = mob.Param.length();
				if( paramneedsize + countparams * 2 > paramsize )
				{
					paramsize = paramneedsize + countparams * 2;
					params.resize( paramsize );
				}
                for( ui1 = 0; ui1 < countparams; ui1++ )
                {
                    params[paramneedsize++] = mob.Param[ ui1 ].Index;
                    params[paramneedsize++] = mob.Param[ ui1 ].GetValue( countplayer );
                }
                @ teamMobs = Farm::AllTeamMobs[ values[ currentPos * COUNT_ADD_MOB_VALUES + 2 ] - 1 ];
                if( teamMobs !is null )
				{
					countparams = teamMobs.GeneralParamsLength;
					if( paramneedsize + countparams * 2 != paramsize )
					{
						paramsize = paramneedsize + countparams * 2;
						params.resize( paramsize );
					}
                    for( ui1 = 0; ui1 < countparams; ui1++ )
                    {
                        params[paramneedsize++] = teamMobs.GeneralParams[ ui1 ].Index;
                        params[paramneedsize++] = teamMobs.GeneralParams[ ui1 ].GetValue( countplayer );
                    }
				}
				if( mapId != values[ currentPos * COUNT_ADD_MOB_VALUES ] )
				{
					@map = GetMap( values[ currentPos * COUNT_ADD_MOB_VALUES ] );
					if( !validEngineObject( map ) )
					{
						Log( "Карта не валидна." );
						continue;
					}
					mapId = map.Id;
				}
				
				baseHx = values[ currentPos * COUNT_ADD_MOB_VALUES + 3 ];
                baseHy = values[ currentPos * COUNT_ADD_MOB_VALUES + 4 ];

				if( !map.IsHexPassed( baseHx, baseHy ) )
				{
					dir = 0;
                    while( dir < 6 )
                    {
                        HexX = baseHx;
                        HexY = baseHy;
                        map.MoveHexByDir( HexX, HexY, dir++, 1 );
                        if( map.IsHexPassed( HexX, HexY ) )
                        {
							mob.InitCritter( map.AddNpc( mob.ProtoId, HexX, HexY, 0, params, null, mob.AiScript ) );
                            break;
                        }
                    }
				}
                else mob.InitCritter( map.AddNpc( mob.ProtoId, baseHx, baseHy, 0, params, null, mob.AiScript ) );
            }
			
            if( tick != 0 && GetTick() - tick >= 250 )
            {
                values.resize( ( currentPos ) * COUNT_ADD_MOB_VALUES );
                return false;
            }
        }
    }
    return true;
}

uint e_AddMob( array< uint >@ values )
{
    if( SpawnMobs( values, GetTick() ) )
		return 0;
	return 50;
}

void SetFarmItem( Item& it, bool isSet )
{
    if( isSet )
    {
        GameVar@ var = GetLocalVar( LIVAR_IsFarmGenerated, it.Id );
        if( var !is null )
        {
            uint16 temp = 0;
            var = it.GetMapPosition( temp, temp ).GetLocation().Id;
        }
    }
}

// ~run farm_location GetLocationTime 0 0 0
void GetLocationTime( Critter& cr, int, int, int )
{
    uint duration = 0;
    uint[] values;
    if( GetTimeEvent( cr.GetMap().GetLocation().FarmLocTimeEventId, duration, values ) )
    {
        duration /= __TimeMultiplier;
        string say = "Событие на обновление локации произойдет через: ";
        if( duration > 31536000 )
        {
            say += "" + ( duration / 31536000 ) + " Лет ";
            duration = duration % 31536000;
        }
        if( duration > 2592000 )
        {
            say += "" + ( duration / 2592000 ) + " Месяцев ";
            duration = duration % 2592000;
        }
        if( duration > 86400 )
        {
            say += "" + ( duration / 86400 ) + " Дней ";
            duration = duration % 86400;
        }
        if( duration > 3600 )
        {
            say += "" + ( duration / 3600 ) + " Часов ";
            duration = duration % 3600;
        }
        if( duration > 60 )
        {
            say += "" + ( duration / 60 ) + " Минут ";
            duration = duration % 60;
        }
        if( duration > 0 )
        {
            say += "" + ( duration ) + " Секунд ";
        }
        cr.Say( SAY_NETMSG, say );
    }
    else
        cr.Say( SAY_NETMSG, "Не найдено событие на обновление локации" );
}
// ~run farm_location SetLocationRefreshTime 0 0 0
// ~run farm_location SetLocationRefreshTime realMinute 0 0

void SetLocationRefreshTime( Critter& cr, int time, int, int )
{
    uint duration = 0;
    uint[] values;
    if( GetTimeEvent( cr.GetMap().GetLocation().FarmLocTimeEventId, duration, values ) && SetTimeEvent( cr.GetMap().GetLocation().FarmLocTimeEventId, REAL_MINUTE( time ), values ) )
    {
        duration = time * 60;
        string say = "Событие на обновление локации произойдет через: ";
        if( duration > 31536000 )
        {
            say += "" + ( duration / 31536000 ) + " Лет ";
            duration = duration % 31536000;
        }
        if( duration > 2592000 )
        {
            say += "" + ( duration / 2592000 ) + " Месяцев ";
            duration = duration % 2592000;
        }
        if( duration > 86400 )
        {
            say += "" + ( duration / 86400 ) + " Дней ";
            duration = duration % 86400;
        }
        if( duration > 3600 )
        {
            say += "" + ( duration / 3600 ) + " Часов ";
            duration = duration % 3600;
        }
        if( duration > 60 )
        {
            say += "" + ( duration / 60 ) + " Минут ";
            duration = duration % 60;
        }
        if( duration > 0 )
        {
            say += "" + ( duration ) + " Секунд ";
        }
        cr.Say( SAY_NETMSG, say );
    }
    else
        cr.Say( SAY_NETMSG, "Не найдено событие на обновление локации" );
}

void create( Critter& cr, int id, int x, int y )
{
	( Farm::AllLocs[ id - 1 ] ).Create( x, y );
}
