// Author: rifleman17
// Скрипты для квестовой линии "Гвардеец Города-Убежища"
#include "_macros.fos"
#include "squad_march.fos"

import void SetDeterioration(Item& item, int deteriorationProcent)  from "repair";
import int GetDeteriorationProcent(Item& item) from "repair";

// Квест "Самоделкин":
//  Тренировка по надлежащему уходу за оружием
//  Выдача двух сломанных Штурмовых винтовок
void r_GiveWearItems(Critter& player, Critter@ npc, int pid, int count, int deteriorationPercent)
{
	Item@ item;
	for(int i=0; i<count; i++)
	{
		@item=player.AddItem(pid, 1);
		if (!valid(item))
			continue;
		SetDeterioration(item, deteriorationPercent);
	}
}

bool d_CheckWear(Critter& player, Critter@ npc, int pid, int count, int deteriorationPercent)
{
	if(count==0)
		return false;
	Item@ item;
	Item@[] items;
	if(player.GetItems(-1, items)==0)
		return false;
	int num=0;
	for(uint i=0, iMax=items.length(); i<iMax; i++)
	{
		@item=items[i];
		if (!valid(item) || item.GetProtoId() !=pid)
			continue;
		if(GetDeteriorationProcent(item)<=deteriorationPercent)
			num++;
	}
	return (num >=count);
}

// Квест "Строевая подготовка":
//  Персонаж должен встать в одну линию с НПЦ-гвардейцами и повторять их движения по команде капитана Хартманна
#define ROLE_MARCH                    (91)   // Номер роли НПЦ, которые принимают участие в марше
#define ROLE_COMMANDER                (92)   // Хартманн
#define STR_RIGHT_POSITION            (5915) // Вы в правильной позиции. Оставайтесь на месте до первой команды. Равнение на середину!
#define STR_WRONG_POSITION            (5916) // Да сколько можно? Стать в строй, черт тебя дери! Иначе отправлю к мамочке!
#define STR_MARCH_FAILED              (9)    // Это чучело безнадеждно. Я так и думал.
#define STR_MARCH_COMPLETED           (10)   // Неплохо... Неплохо. Не ожидал.
#define STR_LOOSE                     (5917) // Вы что-то сделали не так. Задание провалено.
#define POS_X                         (65)   // Позиция игрока в начале квеста
#define POS_Y                         (132)
#define LAST_ORDER                    (7)    // Последний приказ

// Обработка наступания игроком на триггер перед началом тренировки
// Служит сигналом к началу
void t_Enter(Critter& player, Scenery& trigger, bool entered, uint8 dir)
{
	if (!player.IsPlayer() || !entered)
		return;
	GameVar@ qVar=GetLocalVar(LVAR_q_vc_hartman_march, player.Id);
	GameVar@ status=GetGlobalVar(GVAR_vc_hartman_march_status);
	if (!valid(qVar) || !valid(status))
		return;
	if(qVar.GetValue() !=1 || status !=0)
		return;
	player.Wait(0);
	player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_RIGHT_POSITION);
	Map@ map=player.GetMap();
	Critter@ cr=map.GetNpc(ROLE_COMMANDER, FIND_LIFE|FIND_ONLY_NPC, 0);
	if (!valid(cr) || cr.Stat[ST_VAR9] > 0)
		return;
	uint[] values={cr.Id, player.Id, 0};
	cr.StatBase[ST_VAR9]=player.Id;  // Сохранение кода игрока, чтобы нпц не спамил свои реплики при многократных входах-выходах на гекс
	qVar=2;
	CreateTimeEvent(__FullSecond + REAL_SECOND(3), "e_TimeToStart", values, false);
	CreateTimeEvent(__FullSecond + REAL_MINUTE(15), "e_ResetCommander", values, true);

}

// Контрольная очистка переменных через 15 реальных минут, если что-то пошло не так, и все данные не удалились
uint e_ResetCommander(uint[]@ values)
{
	Critter@ cr=GetCritter(values[0]);
	uint idPlayer=values[1];
	if (!valid(cr) || uint(cr.Stat[ST_VAR9]) !=idPlayer)
		return 0; // Если уже другой персонаж занимается строевой подготовкой, для него будет персональный эвент
	SquadCommander@ cmdr=SquadCommander(cr);
	if(valid(cmdr))
	{
		cmdr.Load();
		cmdr.Erase();
	}
	ResetCommander(cr);
	return 0;
}

// Сброс глобальной переменной и переменных командира
void ResetCommander(Critter& cr)
{
	cr.StatBase[ST_VAR9]=0;
	GameVar@ status=GetGlobalVar(GVAR_vc_hartman_march_status);
	if(valid(status))
		status=0;
}

// Проверка, что игрок в нужной позиции и запуск очереди приказов
uint e_TimeToStart(uint[]@ values)
{
	Critter@ npc =GetCritter(values[0]);
	Critter@ player=GetCritter(values[1]);
	if (!valid(npc) || !valid(player))
		return 0;
	if(player.HexX !=POS_X || player.HexY !=POS_Y) // Игрок не находится в нужной позиции
	{
		if(values[2] > 5) // Максимум 5 проверок, потом заново
		{
			ResetCommander(npc);
			return 0;
		}
		values[2]++;
		npc.SayMsg(SAY_SHOUT_ON_HEAD, TEXTMSG_TEXT, STR_WRONG_POSITION);
		return REAL_SECOND(5);
	}
	GameVar@ status=GetGlobalVar(GVAR_vc_hartman_march_status);
	if (!valid(status) || status !=0)
	{
		ResetCommander(npc);
		return 0;
	}
	status=1;
	Map@ map=npc.GetMap(); // Поиск нпц-гвардейцев
	Critter@[] critters;
	uint num=map.GetNpcCount(ROLE_MARCH, FIND_LIFE|FIND_ONLY_NPC);
	uint[] values_new={0, npc.Id, player.Id};
	SquadCommander@ cmdr=SquadCommander(npc);
	cmdr.Squad.insertLast(player.Id);
	for(uint i=0; i<num; i++)
	{
		Critter@ cr=map.GetNpc(ROLE_MARCH, FIND_LIFE|FIND_ONLY_NPC, i);
		if(valid(cr))
		{
			MarchQueue@ q=MarchQueue(cr);
			q.Erase();
			q.AddOrder(DefineDirection(5, 0, 0));
			q.AddOrder(DefineMove(3, 5, false, 0, 0));
			q.AddOrder(DefineDirection(2, 0, 0));
			q.AddOrder(DefineArmWeapon(true, 0, 0));
			q.AddOrder(DefineArmWeapon(false, 0, 0));
			q.AddOrder(DefineMove(5, 2, true, 0, 0));
			q.AddOrder(DefineDirection(5, 0, 0));
			q.AddOrder(DefineMove(2, 5, false, 0, 0));
			q.Save();
			cmdr.Squad.insertLast(cr.Id);
		}
	}
	cmdr.Save();
	MarchQueue@ q=MarchQueue(player);
	q.Erase();
	q.AddOrder(DefineDirection(5, 0, 0));
	q.AddOrder(DefineMove(3, 5, false, 0, 0));
	q.AddOrder(DefineDirection(2, 0, 0));
	q.AddOrder(DefineArmWeapon(true, 0, 0));
	q.AddOrder(DefineArmWeapon(false, 0, 0));
	q.AddOrder(DefineMove(5, 2, true, 0, 0));
	q.AddOrder(DefineDirection(5, 0, 0));
	q.AddOrder(DefineMove(2, 5, false, 0, 0));
	q.Save();
	CreateTimeEvent(__FullSecond + REAL_SECOND(3), "e_NextGuardOrder", values_new, false);
	return 0;
}

// Время отдавать новый приказ
uint e_NextGuardOrder(uint[]@ values)
{
	Critter@ cr=GetCritter(values[1]);
	if (!valid(cr))
		return 0;
	SquadCommander@ cmdr=SquadCommander(cr);
	cmdr.Load();
	if(cmdr.CheckCommandExecuted())
	{
		cmdr.Command(values[0]);
		values[0]++;
	}
	else
	{
		cr.SayMsg(SAY_NORM, TEXTMSG_DLG, DLGSTR(cr.Stat[ST_DIALOG_ID], STR_MARCH_FAILED));
		ResetCommander(cr);
		cmdr.Erase();
		return 0;
	}
	if(values[0]==LAST_ORDER)
	{
		cr.SayMsg(SAY_NORM, TEXTMSG_DLG, DLGSTR(cr.Stat[ST_DIALOG_ID], STR_MARCH_COMPLETED));
		ResetCommander(cr);
		cmdr.Erase();
		GameVar @qVar=GetLocalVar(LVAR_q_vc_hartman_march, values[2]);
		if(valid(qVar) && qVar.GetValue()==2) qVar=3;
		return 0;
	}
	return REAL_SECOND(6);
}

// Бонусы Гвардии для игроков
#define CTE_ID_SALARY             (224)
#define GAME_DAY #(days)(days*24*60*60)
#define PRIVATE_MONEY             (68)  // Жалование рядового
#define JSERGEANT_MONEY           (98)  // Жалование младшего сержанта
#define SSERGEANT_MONEY           (151) // Жалование старшего сержанта
#define LEUTENANT_MONEY           (360) // Жалование лейтенанта
#define RANK_NONE                 (0)
#define RANK_PRIVATE              (1)
#define RANK_JUN_SERGEANT         (2)
#define RANK_SEN_SERGEANT         (3)
#define RANK_LEUTENANT            (4)

// Ежедневное жалование
void r_SetGuardSalary(Critter& player, Critter@ npc)
{
	player.AddTimeEvent("cte_GuardsmanSalary", GAME_DAY(1), CTE_ID_SALARY);
}

uint8 GetRank(Critter& cr)
{
	GameVar @ rank=GetLocalVar(LVAR_vc_guard_rank, cr.Id);
	if (!valid(rank))
		return RANK_NONE;
	return rank.GetValue();
}

uint cte_GuardsmanSalary(Critter& cr, int identifier, uint& rate)
{
	uint8 rank=GetRank(cr);
	uint money=0;
	switch (rank)
	{
		case RANK_PRIVATE:
			money=PRIVATE_MONEY;
			break;
		case RANK_JUN_SERGEANT:
			money=JSERGEANT_MONEY;
			break;
		case RANK_SEN_SERGEANT:
			money=SSERGEANT_MONEY;
			break;
		case RANK_LEUTENANT:
			money=LEUTENANT_MONEY;
			break;
		default:
			break;
	}
	cr.StatBase[ST_REPLICATION_MONEY] +=money;
	return GAME_DAY(1);
}

// Квест Пойди туда - не знаю куда
void _MutantsCaveInit(Map& map, bool firstTime)
{
	map.SetEvent(MAP_EVENT_IN_CRITTER, "_CaveInCritter");
}

void _CaveInCritter(Map& map, Critter& cr)
{
	Location@ loc=map.GetLocation();
	if(valid(loc))
		loc.AutoGarbage=true;
	Critter@[] mutants;
	if(map.GetCritters(0, FIND_LIFE_AND_KO|FIND_ONLY_NPC, mutants)>0)
	{
		for(uint i=0, iMax=mutants.length(); i<iMax; i++)
		{
			Critter@ npc=mutants[i];
			if (!valid(npc))
				continue;
			if (!npc.CheckEnemyInStack(cr.Id))
				npc.AddEnemyInStack(cr.Id);
		}
	}
	GameVar@ qVar=GetLocalVar(LVAR_q_vc_hartmann_recon, cr.Id);
	if(valid(qVar) && qVar.GetValue()==2) qVar=3;
}

void _MutantsOutGroundInit(Map& map, bool firstTime)
{
	map.SetEvent(MAP_EVENT_IN_CRITTER, "_OutGroundInCritter");
	Location@ loc=map.GetLocation();
	if(valid(loc))
		CreateTimeEvent(__FullSecond+REAL_DAY(3), "e_DeleteQuestLocation", loc.Id, true);
}

uint e_DeleteQuestLocation(uint[]@ values)
{
	Location@ loc=GetLocation(values[0]);
	if(valid(loc))
		loc.AutoGarbage=true;
	return 0;
}

void _OutGroundInCritter(Map& map, Critter& cr)
{
	if (!cr.IsPlayer())
		return;
	GameVar@ qVar=GetLocalVar(LVAR_q_vc_hartmann_recon, cr.Id);
	GameVar@ idLoc=GetLocalVar(LVAR_vc_recon_cave_id, cr.Id);
	if (!valid(qVar) || !valid(idLoc) || qVar.GetValue() !=2)
		return;
	Location@ loc=map.GetLocation();
	if(valid(loc) && idLoc.GetValue()==0)
	{
		idLoc=loc.Id;
		loc.AutoGarbage=false;
		cr.SetKnownLoc(true,loc.Id);

	}
}

// Опасная Охота

import void r_ShowLocation(Critter& player, Critter@ npc, int qVar, int counterVar, int locPid, int locX, int locY) from "hostile_location_quest";
import void r_ShowLocation2(Critter& player, Critter@ npc, int qVar, int counterVar, int locPid, int locX, int locY) from "hostile_location_quest";

void r_ShowCave(Critter& player, Critter@ npc)
{
	GameVar@ locId=GetLocalVar(LVAR_vc_recon_cave_id, player.Id);
	if (!valid(locId) || locId.GetValue()==0)
		return;
	Location@ loc=GetLocation(locId.GetValue());
	uint16 x=1168;
	uint16 y=418;
	if(valid(loc) && loc.GetProtoId()==LOCATION_Quest_VCity_Recon_Cave)
	{
		uint16 x=loc.WorldX;
		uint16 y=loc.WorldY;
		DeleteLocation(loc.Id);
		r_ShowLocation(player, npc, LVAR_q_vc_hartmann_clear_cave, LVAR_vc_dead_ally_counter, LOCATION_Quest_VCity_Attack_Cave, x, y);
	}
	else
	{
		r_ShowLocation2(player, npc, LVAR_q_vc_hartmann_clear_cave, LVAR_vc_dead_ally_counter, LOCATION_Quest_VCity_Attack_Cave, x, y);
	}
}


// Нанимаемый мутант

void _CharleyInit(Critter& cr, bool firstTime)
{
	cr.StatBase[ST_MAX_LIFE]=600;
	cr.StatBase[ST_CURRENT_HP]=cr.Stat[ST_MAX_LIFE];
	cr.SkillBase[SK_BARTER]=1;
	cr.StatBase[ST_ACTION_POINTS]=12;
	cr.SkillBase[SK_BIG_GUNS]=250;
}