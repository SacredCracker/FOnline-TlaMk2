// Authors: cvet, Atom
#include "_macros.fos"
#include "_npc_pids.fos"
#include "npc_ai.fos"
#include "linetracer_h.fos"

#define _PLANE_
#include "GrupPatrol_h.fos"

import void  SetDeterioration( Item& item, int deteriorationProcent ) from "Mk2";
import bool  AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";
import bool  AddMiscPlane( Critter& npc, uint priority, uint waitSecond, string@ funcName ) from "npc_planes";
import bool  IsKeyAviable( Critter& cr, uint lockerId, Item& locker ) from "Mk2";
import uint  GetKeyId( Critter& cr, uint lockerId ) from "Mk2";
import int   RawToHit( Critter& cr, Critter& target, ProtoItem@ weapon, uint8 weaponUse, ProtoItem@ ammo ) from "combat";
import bool  AddGoToHealPlane( Critter& npc, Critter& target, bool run ) from "npc_planes";
import uint8 GetDir( Critter& cr0, Critter& cr1 ) from "merc";
import void  UseDrugOn( Critter& cr, Critter& onCr, Item& drug ) from "Mk2";

import void UseDoctor( Critter& cr, Critter@ targetCr, uint16 activePid ) from "healing"; // Export
import void Healing( Critter& cr, Critter& tr, uint16 activePid ) from "healing";         // Export

import bool critter_stealing( Critter& cr, Critter& thief, Item& item, uint count ) from "Mk2";

import bool Zone_Attack( Critter& cr, uint16 hexX, uint16 hexY, int slot ) from "combat";
import void critter_attack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo ) from "main";

bool AddPlaneChild( Critter& npc, NpcPlane& plane, NpcPlane& child )
{
    NpcPlane@ checkPlane = child;
    uint      countChild = 0;
    while( valid( checkPlane.ChildPlane ) )
    {
        @ checkPlane = checkPlane.ChildPlane;
        countChild++;
    }
    if( countChild > 2 )
        Log( "CountPlaneChild " + countChild );
    if( child.Type == plane.Type && plane.Attack_TargId == child.Attack_TargId && AI_PLANE_ATTACK == plane.Type )
        return false;
    plane.SetChild( child );
    return false;
    // return npc.AddPlane(plane);
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some plane added.
// Return true to allow plane, false to disallow.
// REASON_GO_HOME
// REASON_FOUND_IN_ENEMY_STACK   someCr as Enemy
// REASON_FROM_DIALOG            someCr as Player
// REASON_FROM_SCRIPT
// REASON_RUN_AWAY
bool MainPlane_NpcPlaneBegin( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
	
    if( REASON_FROM_SCRIPT != reason && REASON_FOUND_IN_ENEMY_STACK != reason && npc.GetPlanes( null ) > 0 )
        return false;

    if( IsGrup( npc ) )
    {
        int GrupValue = _GrupPlaneBegin( npc, plane, reason, someCr, someItem );
        if( GrupValue > 0 )
        {
            return ( GrupValue == 1 );
        }
    }

    if( plane.Type == AI_PLANE_WALK && !npc.IsCanWalk() )
        return false;

    if( plane.Type == AI_PLANE_PROSECUTION && valid( npc.GetMap() ) )
    {
        //npc.Say( SAY_NORM, "npc_plane_begin "+reason + " " + npc.Id );
        Critter@ target = GetCritter( plane.Prosecution_TargetId );
        if( valid( target ) && !target.IsDead() )
        {
            if( valid( target.GetMap() ) && target.GetMap().Id == npc.GetMap().Id )
            {
                // return AddWalkPlane(npc, plane.Priority+1, target.HexX, target.HexY, 0, plane.Run,1);
                NpcPlane@ planWalk = CreatePlane();
                planWalk.Type = AI_PLANE_WALK;
                planWalk.Priority = plane.Priority;
                planWalk.Walk_HexX = target.HexX;
                planWalk.Walk_HexY = target.HexY;
                planWalk.Walk_Dir = ::GetDirection( npc.HexX, npc.HexY, target.HexX, target.HexX );
                planWalk.Run = plane.Prosecution_Run;
                planWalk.Walk_Cut = 3;
                planWalk.Walk_Var0 = AI_PLANE_PROSECUTION;
                planWalk.Walk_Var1 = plane.Prosecution_TargetId;
                plane.SetChild( planWalk );
                return true;
            }
        }
    }

    if( reason == REASON_FROM_DIALOG && plane.Type == AI_PLANE_ATTACK )
        npc.StatBase[ ST_NPC_ATTACK_PLAYER_ID ] = plane.Attack_TargId;

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some plane added.
// Return true to erase plane, false to wait (set this plane to next priority of planes sequence).
// REASON_SUCCESS
// REASON_HEX_TOO_FAR
// REASON_HEX_BUSY
// REASON_HEX_BUSY_RING
// REASON_DEADLOCK
// REASON_TRACE_FAIL
// REASON_POSITION_NOT_FOUND
// REASON_FIND_PATH_ERROR
// REASON_CANT_WALK
// REASON_TARGET_DISAPPEARED     someCr as Enemy
// REASON_USE_ITEM_NOT_FOUND
// REASON_GAG_CRITTER            someCr as Enemy
// REASON_GAG_ITEM               someItem as Item
// REASON_NO_UNARMED

bool MainPlane_NpcPlaneEnd( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
    if( plane.Type == AI_PLANE_ATTACK )
        return npc_plane_end_attack( npc,  plane, reason, someCr,  someItem );

    if( !npc.IsCanWalk() )
    {
        npc.Wait( Random( 750, 1500 ) );
        return true;
    }

    if( plane.Type == AI_PLANE_WALK && npc_plane_end_walk( npc,  plane, reason, someCr,  someItem ) )
        return true;


    if( reason == REASON_CANT_WALK && npc.IsNoPlanes() )
        npc.Wait( Random( 1000, 2000 ) );
    else if( reason == REASON_HEX_BUSY || reason == REASON_HEX_BUSY_RING || reason == REASON_POSITION_NOT_FOUND )
        npc.Wait( Random( 1000, 2000 ) );
    else if( reason == REASON_FIND_PATH_ERROR || reason == REASON_HEX_TOO_FAR )
        npc.Wait( 20000 );
    else if( reason == REASON_GAG_CRITTER )
    {
        if( valid( someCr ) )
        {
            if( someCr.IsPlayer() && int(someCr.Id) != npc.Merc[ MERC_MASTER_ID ] )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_ATTACK;
                child.Priority = plane.Priority * 2;
                child.Attack_TargId = someCr.Id;
                child.Attack_MinHp = __DeadHitPoints;
                child.Attack_IsGag = true;
                child.Attack_GagHexX = someCr.HexX;
                child.Attack_GagHexY = someCr.HexY;
                child.Attack_LastHexX = someCr.HexX;
                child.Attack_LastHexY = someCr.HexY;
                child.Run = plane.Run;

                return AddPlaneChild( npc, plane, child );
            }
            else if( ( npc.CityRole_IsGuard ||  ( someCr.Stat[ ST_TEAM_ID ] != 0  && someCr.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) ) && someCr.StatBase[ ST_CURRENT_HP ] < someCr.StatBase[ ST_MAX_LIFE ] )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_WALK;
                child.Priority = plane.Priority * 2;
                child.Identifier = 0;
                child.IdentifierExt = 0;
                child.Walk_HexX = someCr.HexX;
                child.Walk_HexY = someCr.HexY;
                child.Run = plane.Run;
                child.Walk_Cut = 1;
                child.Walk_Reason_CritterId = someCr.Id;
                child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

                return AddPlaneChild( npc, plane, child );
            }
        }

        return true;
    }
    else if( reason == REASON_GAG_ITEM )
    {
        if( valid( someItem ) )
        {
            if( someItem.GetType() == ITEM_TYPE_DOOR && !FLAG( someItem.LockerCondition, LOCKER_ISOPEN ) && !FLAG( someItem.LockerCondition, LOCKER_NOOPEN ) &&
                AI_CAN_OPEN_DOORS( npc.Stat[ ST_AI_ID ] ) && ( IsKeyAviable( npc, someItem.LockerId, someItem ) || npc.CityRole_IsGuard ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_PICK;
                child.Priority = plane.Priority * 2;
                child.Pick_HexX = someItem.HexX;
                child.Pick_HexY = someItem.HexY;
                child.Pick_Pid = someItem.GetProtoId();
                child.Pick_UseItemId = GetKeyId( npc, someItem.LockerId );
                child.Pick_ToOpen = true;
                child.Run = plane.Run;

                return AddPlaneChild( npc, plane, child );               // Cancel deleting
            }
            else if( someItem.GetType() != ITEM_TYPE_DOOR &&
                     ( FLAG( someItem.Proto.Flags, ITEM_CAN_PICKUP ) ||
                       FLAG( someItem.Flags, ITEM_CAN_PICKUP ) ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_PICK;
                child.Priority = plane.Priority * 2;
                child.Pick_HexX = someItem.HexX;
                child.Pick_HexY = someItem.HexY;
                child.Pick_Pid = someItem.GetProtoId();
                child.Run = plane.Run;

                return AddPlaneChild( npc, plane, child );               // Cancel deleting
            }
            else
            {
                // if(npc.CityRole_IsGuard )
                {
                    if( not valid( someCr ) )
                        @someCr = npc.GetMap().GetCritter( someItem.HexX, someItem.HexY );  // Если криттер стоит на двери, то тут все стопорнет
                    if( valid( someCr ) )
                    {
                        if( someCr.IsPlayer() && int(someCr.Id) != npc.Merc[ MERC_MASTER_ID ] )
                        {
                            NpcPlane@ child = CreatePlane();
                            child.Type = AI_PLANE_ATTACK;
                            child.Priority = plane.Priority * 2;
                            child.Attack_TargId = someCr.Id;
                            child.Attack_MinHp = __DeadHitPoints;
                            child.Attack_IsGag = true;
                            child.Attack_GagHexX = someCr.HexX;
                            child.Attack_GagHexY = someCr.HexY;
                            child.Attack_LastHexX = someCr.HexX;
                            child.Attack_LastHexY = someCr.HexY;
                            child.Run = plane.Run;

                            return AddPlaneChild( npc, plane, child );
                        }
                        else if( someCr.Stat[ ST_CURRENT_HP ] <= 0 && !someCr.IsDead() && ( someCr.Stat[ ST_TEAM_ID ] != 0  && someCr.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) )
                        {
                            NpcPlane@ child = CreatePlane();
                            child.Type = AI_PLANE_WALK;
                            child.Priority = plane.Priority * 2;
                            child.Identifier = 0;
                            child.IdentifierExt = 0;
                            child.Walk_HexX = someCr.HexX;
                            child.Walk_HexY = someCr.HexY;
                            child.Run = plane.Run;
                            child.Walk_Cut = 1;
                            child.Walk_Reason_CritterId = someCr.Id;
                            child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

                            return AddPlaneChild( npc, plane, child );
                        }
                    }
                }
                // TabaK. Спидорить план, если на пути неоткрываемая дверь или нелутаемый предмет.
                return true;
            }
        }
    }
    else if( reason == REASON_RUN_AWAY && npc.IsCanWalk() )
    {
        Map@     map = npc.GetMap();
        Critter@ cr = GetCritter( plane.Attack_TargId );
        if( valid( map ) && valid( cr ) )
        {
            int    awayDir = ::GetDirection( cr.HexX, cr.HexY, npc.HexX, npc.HexY );
            uint   awayDist = Random( 30, 50 );      // Todo: resolve correct distantion
            uint16 baseHx = npc.HexX;
            uint16 baseHy = npc.HexY;
            map.MoveHexByDir( baseHx, baseHy, awayDir, 1 );

            float angle = 0.0f;
            uint  reverse = Random( 0, 1 );
            for( uint i = 0; i < 5; i++ )
            {
                uint16 hx = baseHx, hy = baseHy;
                map.GetHexCoord( npc.HexX, npc.HexY, hx, hy, angle, awayDist );
                if( GetDistantion( npc.HexX, npc.HexY, hx, hy ) > 1 )
                {
                    AddWalkPlane( npc, 100, hx, hy, 6, true, 0 );
                    break;
                }
                angle += float(i + 1) * 45.0f * ( ( i % 2 ) == reverse ? 1.0f : -1.0f );
            }
            AI_TrySayCombatText( npc, COMBAT_TEXT_RUN_AWAY );
        }

        int npcTimeout = BATTLE_TIMEOUT( npc );
        if( npc.Timeout[ TO_BATTLE ] < npcTimeout - __FullSecond )
            npc.TimeoutBase[ TO_BATTLE ] = npcTimeout;
    }
    else if( reason == REASON_NO_UNARMED )
    {
        // Repair first broken weapon
        Item@[] items;
        uint count = npc.GetItemsByType( ITEM_TYPE_WEAPON, items );
        for( uint i = 0; i < count; i++ )
        {
            Item@ item = items[ i ];
            if( _ItemIsBroken( item ) )
            {
                SetDeterioration( item, 0 );
                break;
            }
        }
    }

    if( IsGrup( npc ) )
        return ( _GrupPlaneEnd( npc, plane, reason, someCr, someItem ) == 2 );

    return true;
}

uint LastCheckChamberId = 0;
uint LastCheckChamberTick = 0;

bool npc_plane_end_attack( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
    Critter@ target = GetCritter( plane.Attack_TargId );

    if( reason == REASON_SUCCESS || !valid( target ) || npc.IsDead() || target.IsDead() || !valid( target.GetMap() ) || !valid( npc.GetMap() ) || npc.GetMap().Id != target.GetMap().Id )
    {
        if( valid( target ) )
        {
            if( uint( npc.Stat[ ST_NPC_ATTACK_PLAYER_ID ] ) == target.Id )
            {
                npc.StatBase[ ST_NPC_ATTACK_PLAYER_ID ] = 0;
            }
        }
        npc.Wait( Random( 750, 1500 ) );
        return true;
    }


    if( reason == REASON_TARGET_DISAPPEARED )
    {
        NpcPlane@ child = CreatePlane();
        child.Type = AI_PLANE_WALK;
        child.Priority = plane.Priority * 2;
        child.Walk_HexX = plane.Attack_LastHexX;
        child.Walk_HexY = plane.Attack_LastHexY;
        child.Walk_Dir = 0;
        child.Run = plane.Run;
        child.Walk_Cut = target.Mode[ MODE_HIDE ] == 0 ? npc.Stat[ ST_VISIBLE_DIST ] - 1 : 1;

        return AddPlaneChild( npc, plane, child );
    }

    uint8            mode = 0;
    const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode );
    int              use = _WeaponModeUse( mode );
    int              wpnDist = 0;
    if( valid( weapon ) )
    {
        wpnDist = _WeaponMaxDist( weapon, use );
    }
    const ProtoItem@ ammo = ( valid( weapon ) && weapon.Weapon_MaxAmmoCount > 0 && weapon.Weapon_Caliber != 0 ? GetProtoItem( _CritGetItemHand( npc ).AmmoPid ) : null );

    // if( plane.Type == AI_PLANE_ATTACK)// Че время терять, лучше пальнуть если можно
    {
        if( Zone_Attack( npc, target.HexX, target.HexY, SLOT_HAND1 ) )
        {
            Item@ item = npc.GetItem( 0, SLOT_HAND1 );         // _CritGetItemHand(cr);
            if( valid( item ) && !_ItemIsBroken( item ) )
            {
                ProtoItem@ proto = npc.GetSlotProto( SLOT_HAND1, item.Mode );
                if( valid( proto ) && npc.IsLife() && npc.IsAnim1( proto.Weapon_Anim1 ) )
                {
                    ProtoItem@ myAmmo = ( _WeaponRound( proto, item.Mode ) > 0 ) ? GetProtoItem( item.AmmoPid ) : null;
                    int        skillNum = _WeaponSkill( proto, item.Mode );
                    uint8      weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );
                    uint16     apCost = MAX( 1, ( ( _WeaponApCost( proto, item.Mode ) - item.WeaponBonus_AP - npc.Perk[ PE_BONUS_RATE_OF_FIRE ] ) - ( weaponSubtype == WS_GUN ? npc.Trait[ TRAIT_FAST_SHOT ] : 0 ) ) );

                    if( npc.StatBase[ ST_CURRENT_AP ] < int( apCost ) )
                    {
                        // npc.Say( SAY_NORM_ON_HEAD, " ST_CURRENT_AP " + npc.StatBase[ST_CURRENT_AP] + " apCost " + apCost + " wait " + (((apCost*__ApRegeneration)/npc.Stat[ST_ACTION_POINTS])-100) );
                        npc.Wait( Random( ( ( apCost * __ApRegeneration ) / npc.Stat[ ST_ACTION_POINTS ] ) - 100, ( ( apCost * __ApRegeneration ) / npc.Stat[ ST_ACTION_POINTS ] ) + 100 ) );
                        return false;
                    }

                    if( ( item.AmmoCount > 0 || !valid( myAmmo ) )  && npc.StatBase[ ST_CURRENT_HP ] >= 0 )         // Может, стреляем.
                    {
                        // if(npc.IsFree())
                        {
                            critter_attack( npc,  target, proto, item.Mode, myAmmo );
                            npc.StatBase[ ST_CURRENT_AP ] -= apCost;
                            npc.Wait( Random( 1000, 2000 ) );
                            return false;
                        }
                    }
                }
            }
        }
    }

    if( !npc.IsCanWalk() )
    {
        npc.Wait( Random( 750, 1500 ) );
        return true;
    }

    if( LastCheckChamberId == npc.Id || ( GetTick() - LastCheckChamberTick ) > 100 )
    {
        LastCheckChamberTick = GetTick();
        LastCheckChamberId = npc.Id;

        if( ( GetTick() % ( ( 16 - npc.Stat[ ST_INTELLECT ] ) * 20 ) ) <= 10 || plane.Chamber != 0 )
        {
            uint   tick = GetTick();
            uint16 bestLen = 0, hx = 0, hy = 0,

                   MapWidth = npc.GetMap().GetWidth(),
                   MapHeight = npc.GetMap().GetHeight(),
                   thx = target.HexX, thy = target.HexY;

            Map@ map = npc.GetMap();

            if( plane.ChamberBestY != 0 && plane.ChamberBestX != 0 )
                bestLen = map.GetPathLength( npc, plane.ChamberBestX, plane.ChamberBestY, 0 );

            uint idist = 0;

            if( plane.Chamber == 0 )
                plane.Chamber = Random( 0, wpnDist * 4 );
           
            for( ; plane.Chamber < uint( wpnDist * 4 );)
            {
                uint16 yMax = thy + plane.Chamber / 4,
                       yMin = thy - plane.Chamber / 4,

                       xMax = thx + plane.Chamber / 4,
                       xMin = thx - plane.Chamber / 4;


                if( MapWidth <  xMax )
                    xMax = MapWidth;
                if( xMin < 0 )
                    xMin = 0;
                if( MapHeight <  yMax )
                    yMax = MapHeight;
                if( yMin < 0 )
                    yMin = 0;

                if( plane.Chamber % 4 == 0 )
                {
                    for( int hexX = xMin, xEnd = xMax; hexX <= xEnd; hexX++ )
                    {
                        hx = hexX;
                        hy = yMin;
                        if( hx > 0 && MapWidth > hx )
                        {
                            map.GetHexCoord( thx, thy, hx, hy, 0, plane.Chamber / 4 );
                            idist = map.GetPathLength( npc, hx, hy, 0 );
                            if( hx != 0 && idist != 0 && hy != 0 && ( idist < bestLen  || bestLen == 0 ) )
                            {
                                plane.ChamberBestX = hx;
                                plane.ChamberBestY = hy;
                                bestLen = idist;
                            }
                        }
                    }
                    plane.Chamber++;
                }
                // //Log( "" + (GetTick() - tick) );
                if( bestLen != 0 )
                    break;

                if( GetTick() - tick > 100 )
                {
                    npc.Wait( Random( 25, 40 ) * ( 16 - npc.Stat[ ST_INTELLECT ] ) );
                    return npc.AddPlane( plane );
                }

                if( plane.Chamber % 4 == 1 )
                {
                    for( int hexY = yMin, yEnd = yMax; hexY <= yEnd; hexY++ )
                    {
                        hx = xMax;
                        hy = hexY;
                        if( hx > 0 && MapWidth > hx )
                        {
                            map.GetHexCoord( thx, thy, hx, hy, 0, plane.Chamber / 4 );
                            idist = map.GetPathLength( npc, hx, hy, 0 );
                            if( hx != 0 && idist != 0 && hy != 0 && ( idist < bestLen  || bestLen == 0 ) )
                            {
                                plane.ChamberBestX = hx;
                                plane.ChamberBestY = hy;
                                bestLen = idist;
                            }
                        }
                    }
                    plane.Chamber++;
                }

                if( bestLen != 0 )
                    break;

                if( GetTick() - tick > 100 )
                {
                    npc.Wait( Random( 25, 40 ) * ( 16 - npc.Stat[ ST_INTELLECT ] ) );
                    return npc.AddPlane( plane );
                }

                if( plane.Chamber % 4 == 2 )
                {
                    for( int hexX = xMax, xEnd = xMin; hexX >= xEnd; hexX-- )
                    {
                        hx = hexX;
                        hy = yMax;
                        if( hx > 0 && MapWidth > hx )
                        {
                            map.GetHexCoord( thx, thy, hx, hy, 0, plane.Chamber / 4 );
                            idist = map.GetPathLength( npc, hx, hy, 0 );
                            if( hx != 0 && idist != 0 && hy != 0 && ( idist < bestLen  || bestLen == 0 ) )
                            {
                                plane.ChamberBestX = hx;
                                plane.ChamberBestY = hy;
                                bestLen = idist;
                            }
                        }
                    }
                    plane.Chamber++;
                }

                if( bestLen != 0 )
                    break;

                if( GetTick() - tick > 100 )
                {
                    npc.Wait( Random( 25, 40 ) * ( 16 - npc.Stat[ ST_INTELLECT ] ) );
                    return npc.AddPlane( plane );
                }

                if( plane.Chamber % 4 == 3 )
                {
                    for( int hexY = yMax, yEnd = yMin; hexY >= yEnd; hexY-- )
                    {
                        hx = xMin;
                        hy = hexY;
                        if( hx > 0 && MapWidth > hx )
                        {
                            map.GetHexCoord( thx, thy, hx, hy, 0, plane.Chamber / 4 );
                            idist = map.GetPathLength( npc, hx, hy, 0 );
                            if( hx != 0 && idist != 0 && hy != 0 && ( idist < bestLen  || bestLen == 0 ) )
                            {
                                plane.ChamberBestX = hx;
                                plane.ChamberBestY = hy;
                                bestLen = idist;
                            }
                        }
                    }
                    plane.Chamber++;
                }

                if( bestLen != 0 )
                    break;
                // //Log( "" + (GetTick() - tick) );
                if( GetTick() - tick > 100 )
                {
                    npc.Wait( Random( 40, 60 ) * ( 16 - npc.Stat[ ST_INTELLECT ] ) );
                    return npc.AddPlane( plane );
                }
            }

            if( bestLen != 0 )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_WALK;
                child.Priority = plane.Priority * 2;
                child.Walk_HexX = plane.ChamberBestX;
                child.Walk_HexY = plane.ChamberBestY;
                child.Walk_Dir = 0;
                child.Run = plane.Run;
                child.Walk_Cut = 0;

                plane.ChamberBestX = 0;
                plane.ChamberBestY = 0;
                plane.Chamber = 0;

                npc.Wait( Random( 40, 60 ) * ( 16 - npc.Stat[ ST_INTELLECT ] ) );
                return AddPlaneChild( npc, plane, child );
            }

            plane.ChamberBestX = 0;
            plane.ChamberBestY = 0;
            plane.Chamber = 0;
        }
    }

    if( reason == REASON_GAG_CRITTER )
    {
        if( valid( someCr ) )
        {
            if( someCr.IsPlayer() && someCr.Id != uint( npc.Merc[ MERC_MASTER_ID ] ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_ATTACK;
                child.Priority = plane.Priority * 2;
                child.Attack_TargId = someCr.Id;
                child.Attack_MinHp = __DeadHitPoints;
                child.Attack_IsGag = true;
                child.Attack_GagHexX = someCr.HexX;
                child.Attack_GagHexY = someCr.HexY;
                child.Attack_LastHexX = someCr.HexX;
                child.Attack_LastHexY = someCr.HexY;
                child.Run = plane.Run;

                npc.Wait( Random( 750, 1500 ) );
                return AddPlaneChild( npc, plane, child );
            }
            else if( npc.IsCanWalk() && ( ( npc.CityRole_IsGuard  || ( someCr.Stat[ ST_TEAM_ID ] != 0  && someCr.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) ) && someCr.StatBase[ ST_CURRENT_HP ] < 0 && !someCr.IsDead() ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_WALK;
                child.Priority = plane.Priority * 2;
                child.Identifier = 0;
                child.IdentifierExt = 0;
                child.Walk_HexX = someCr.HexX;
                child.Walk_HexY = someCr.HexY;
                child.Run = plane.Run;
                child.Walk_Cut = 1;
                child.Walk_Reason_CritterId = someCr.Id;
                child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

                npc.Wait( Random( 750, 1500 ) );
                return AddPlaneChild( npc, plane, child );
            }
        }
    }
    else if( reason == REASON_GAG_ITEM )
    {
        if( valid( someItem ) )
        {
            if( someItem.GetType() == ITEM_TYPE_DOOR && !FLAG( someItem.LockerCondition, LOCKER_ISOPEN ) && !FLAG( someItem.LockerCondition, LOCKER_NOOPEN ) &&
                AI_CAN_OPEN_DOORS( npc.Stat[ ST_AI_ID ] ) && ( IsKeyAviable( npc, someItem.LockerId, someItem ) || npc.CityRole_IsGuard ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_PICK;
                child.Priority = plane.Priority * 2;
                child.Pick_HexX = someItem.HexX;
                child.Pick_HexY = someItem.HexY;
                child.Pick_Pid = someItem.GetProtoId();
                child.Pick_UseItemId = GetKeyId( npc, someItem.LockerId );
                child.Pick_ToOpen = true;
                child.Run = plane.Run;

                npc.Wait( Random( 750, 1500 ) );
                return AddPlaneChild( npc, plane, child );               // Cancel deleting
            }
            else if( someItem.GetType() != ITEM_TYPE_DOOR &&
                     ( FLAG( someItem.Proto.Flags, ITEM_CAN_PICKUP ) ||
                       FLAG( someItem.Flags, ITEM_CAN_PICKUP ) ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_PICK;
                child.Priority = plane.Priority * 2;
                child.Pick_HexX = someItem.HexX;
                child.Pick_HexY = someItem.HexY;
                child.Pick_Pid = someItem.GetProtoId();
                child.Run = plane.Run;

                npc.Wait( Random( 750, 1500 ) );
                return AddPlaneChild( npc, plane, child );               // Cancel deleting
            }
            else
            {
                if( not valid( someCr ) )
                {
                    @someCr = npc.GetMap().GetCritter( someItem.HexX, someItem.HexY );                    // Если криттер стоит на двери, то тут все стопорнет
                    if( valid( someCr ) )
                    {
                        if( someCr.IsPlayer() && int(someCr.Id) != npc.Merc[ MERC_MASTER_ID ] )
                        {
                            NpcPlane@ child = CreatePlane();
                            child.Type = AI_PLANE_ATTACK;
                            child.Priority = plane.Priority * 2;
                            child.Attack_TargId = someCr.Id;
                            child.Attack_MinHp = __DeadHitPoints;
                            child.Attack_IsGag = npc.CityRole_IsGuard;
                            child.Attack_GagHexX = someCr.HexX;
                            child.Attack_GagHexY = someCr.HexY;
                            child.Attack_LastHexX = someCr.HexX;
                            child.Attack_LastHexY = someCr.HexY;
                            child.Run = plane.Run;

                            npc.Wait( Random( 750, 1500 ) );
                            return AddPlaneChild( npc, plane, child );
                        }
                        else if( npc.IsCanWalk() && ( ( npc.CityRole_IsGuard || ( someCr.Stat[ ST_TEAM_ID ] != 0  && someCr.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) ) && someCr.Stat[ ST_CURRENT_HP ] <= 0 && !someCr.IsDead() ) )
                        {
                            NpcPlane@ child = CreatePlane();
                            child.Type = AI_PLANE_WALK;
                            child.Priority = plane.Priority * 2;
                            child.Identifier = 0;
                            child.IdentifierExt = 0;
                            child.Walk_HexX = someCr.HexX;
                            child.Walk_HexY = someCr.HexY;
                            child.Run = plane.Run;
                            child.Walk_Cut = 1;
                            child.Walk_Reason_CritterId = someCr.Id;
                            child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

                            npc.Wait( Random( 750, 1500 ) );
                            return AddPlaneChild( npc, plane, child );
                        }
                    }
                }
            }
        }
    }
    else if( reason == REASON_RUN_AWAY && npc.IsCanWalk() )
    {
        Map@     map = npc.GetMap();
        Critter@ cr = GetCritter( plane.Attack_TargId );
        if( valid( map ) && valid( cr ) )
        {
            int    awayDir = ::GetDirection( cr.HexX, cr.HexY, npc.HexX, npc.HexY );
            uint   awayDist = Random( 30, 50 );      // Todo: resolve correct distantion
            uint16 baseHx = npc.HexX;
            uint16 baseHy = npc.HexY;
            map.MoveHexByDir( baseHx, baseHy, awayDir, 1 );

            float angle = 0.0f;
            uint  reverse = Random( 0, 1 );
            for( uint i = 0; i < 5; i++ )
            {
                uint16 hx = baseHx, hy = baseHy;
                map.GetHexCoord( npc.HexX, npc.HexY, hx, hy, angle, awayDist );
                if( GetDistantion( npc.HexX, npc.HexY, hx, hy ) > 1 )
                {
                    AddWalkPlane( npc, 10000, hx, hy, 6, true, 0 );
                    break;
                }
                angle += float(i + 1) * 45.0f * ( ( i % 2 ) == reverse ? 1.0f : -1.0f );
            }
            AI_TrySayCombatText( npc, COMBAT_TEXT_RUN_AWAY );
        }
        int npcTimeout = BATTLE_TIMEOUT( npc );
        if( npc.Timeout[ TO_BATTLE ] < npcTimeout - __FullSecond )
            npc.TimeoutBase[ TO_BATTLE ] = npcTimeout;
    }
    else if( reason == REASON_NO_UNARMED )
    {
        // Repair first broken weapon
        Item@[] items;
        uint count = npc.GetItemsByType( ITEM_TYPE_WEAPON, items );
        for( uint i = 0; i < count; i++ )
        {
            Item@ item = items[ i ];
            if( _ItemIsBroken( item ) )
            {
                SetDeterioration( item, 0 );
                break;
            }
        }
    }

    // npc.Say( SAY_NORM_ON_HEAD, "npc_plane_end "+reason);

    npc.Wait( 1000 );
    return false;
}

bool npc_plane_end_walk( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
    if( IsGrup( npc ) )
        return ( _GrupPlaneEnd( npc, plane, reason, someCr, someItem ) == 2 );

    if( reason == REASON_GAG_CRITTER )
    {
        if( valid( someCr ) )
        {
            if( someCr.IsPlayer() && int(someCr.Id) != npc.Merc[ MERC_MASTER_ID ] )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_ATTACK;
                child.Priority = plane.Priority * 2;
                child.Attack_TargId = someCr.Id;
                child.Attack_MinHp = __DeadHitPoints;
                child.Attack_IsGag = true;
                child.Attack_GagHexX = someCr.HexX;
                child.Attack_GagHexY = someCr.HexY;
                child.Attack_LastHexX = someCr.HexX;
                child.Attack_LastHexY = someCr.HexY;
                child.Run = plane.Run;

                return AddPlaneChild( npc, plane, child );
            }
            else if( ( npc.CityRole_IsGuard ||  ( someCr.Stat[ ST_TEAM_ID ] != 0  && someCr.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) ) && someCr.StatBase[ ST_CURRENT_HP ] < someCr.StatBase[ ST_MAX_LIFE ] )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_WALK;
                child.Priority = plane.Priority * 2;
                child.Identifier = 0;
                child.IdentifierExt = 0;
                child.Walk_HexX = someCr.HexX;
                child.Walk_HexY = someCr.HexY;
                child.Run = plane.Run;
                child.Walk_Cut = 1;
                child.Walk_Reason_CritterId = someCr.Id;
                child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

                return AddPlaneChild( npc, plane, child );
            }
        }

        return true;
    }
    else if( reason == REASON_GAG_ITEM )
    {
        if( valid( someItem ) )
        {
            if( someItem.GetType() == ITEM_TYPE_DOOR && !FLAG( someItem.LockerCondition, LOCKER_ISOPEN ) && !FLAG( someItem.LockerCondition, LOCKER_NOOPEN ) &&
                AI_CAN_OPEN_DOORS( npc.Stat[ ST_AI_ID ] ) && ( IsKeyAviable( npc, someItem.LockerId, someItem ) || npc.CityRole_IsGuard ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_PICK;
                child.Priority = plane.Priority * 2;
                child.Pick_HexX = someItem.HexX;
                child.Pick_HexY = someItem.HexY;
                child.Pick_Pid = someItem.GetProtoId();
                child.Pick_UseItemId = GetKeyId( npc, someItem.LockerId );
                child.Pick_ToOpen = true;
                child.Run = plane.Run;

                return AddPlaneChild( npc, plane, child );               // Cancel deleting
            }
            else if( someItem.GetType() != ITEM_TYPE_DOOR &&
                     ( FLAG( someItem.Proto.Flags, ITEM_CAN_PICKUP ) ||
                       FLAG( someItem.Flags, ITEM_CAN_PICKUP ) ) )
            {
                NpcPlane@ child = CreatePlane();
                child.Type = AI_PLANE_PICK;
                child.Priority = plane.Priority * 2;
                child.Pick_HexX = someItem.HexX;
                child.Pick_HexY = someItem.HexY;
                child.Pick_Pid = someItem.GetProtoId();
                child.Run = plane.Run;

                return AddPlaneChild( npc, plane, child );               // Cancel deleting
            }
            else
            {
                // if(npc.CityRole_IsGuard )
                {
                    if( not valid( someCr ) )
                        @someCr = npc.GetMap().GetCritter( someItem.HexX, someItem.HexY );                        // Если криттер стоит на двери, то тут все стопорнет
                    if( valid( someCr ) )
                    {
                        if( someCr.IsPlayer() && int(someCr.Id) != npc.Merc[ MERC_MASTER_ID ] )
                        {
                            NpcPlane@ child = CreatePlane();
                            child.Type = AI_PLANE_ATTACK;
                            child.Priority = plane.Priority * 2;
                            child.Attack_TargId = someCr.Id;
                            child.Attack_MinHp = __DeadHitPoints;
                            child.Attack_IsGag = true;
                            child.Attack_GagHexX = someCr.HexX;
                            child.Attack_GagHexY = someCr.HexY;
                            child.Attack_LastHexX = someCr.HexX;
                            child.Attack_LastHexY = someCr.HexY;
                            child.Run = plane.Run;

                            return AddPlaneChild( npc, plane, child );
                        }
                        else if( someCr.Stat[ ST_CURRENT_HP ] <= 0 && !someCr.IsDead() && ( someCr.Stat[ ST_TEAM_ID ] != 0  && someCr.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] ) )
                        {
                            NpcPlane@ child = CreatePlane();
                            child.Type = AI_PLANE_WALK;
                            child.Priority = plane.Priority * 2;
                            child.Identifier = 0;
                            child.IdentifierExt = 0;
                            child.Walk_HexX = someCr.HexX;
                            child.Walk_HexY = someCr.HexY;
                            child.Run = plane.Run;
                            child.Walk_Cut = 1;
                            child.Walk_Reason_CritterId = someCr.Id;
                            child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;

                            return AddPlaneChild( npc, plane, child );
                        }
                    }
                }
                // TabaK. Спидорить план, если на пути неоткрываемая дверь или нелутаемый предмет.
                return true;
            }
        }
    }

    if( reason == REASON_SUCCESS )
    {
        switch( plane.Walk_TypeWalkReason )
        {
        case AI_PLANE_WALK_TRANSIT_NONE:
            break;
        case AI_PLANE_WALK_TRANSIT_ENTIRE:
        {
            if( not npc.TransitToMap( plane.Walk_Reason_MapId, plane.Walk_Reason_EntireId ) )
                Log( "Error №0 transit!" );
            return true;
        }
        case AI_PLANE_WALK_TRANSIT_HEX:
        {
            if( not npc.TransitToMap( plane.Walk_Reason_MapId, plane.Walk_Reason_HexX, plane.Walk_Reason_HexY, npc.Dir ) )
                Log( "Error №1 transit!" );
            return true;
        }
        case AI_PLANE_WALK_TRANSIT_GM:
        {
            if( not npc.TransitToGlobal( false ) )
                Log( "Error №2 transit!" );
            return true;
        }
        case AI_PLANE_WALK_TRANSIT_GM_GROUP:
        {
            if( not npc.TransitToGlobalGroup( plane.Walk_Reason_CritterId ) )
                Log( "Error №3 transit!" );
            return true;
        }
        case AI_PLANE_WALK_HEAL:
        {
            Critter@ target = GetCritter( plane.Walk_Reason_CritterId );
            if( valid( target ) )
            {
                if( target.IsDead() )
                    return true;
                uint dist = GetCrittersDistantion( npc, target );
                if( dist < 2 )                     // Расстояние до напарника 1 или 0 гексов - можно лечить.
                {

                    uint stimsPid = plane.Walk_Var0 == 0 ? PID_SUPER_STIMPAK : plane.Walk_Var0, stims = npc.CountItem( stimsPid );

                    if( stims == 0 )
                    {
                        stims = npc.CountItem( PID_STIMPAK );
                        if( stims != 0 )
                            stimsPid = PID_STIMPAK;
                    }

                    bool needHeal = target.Stat[ ST_CURRENT_HP ] != target.Stat[ ST_MAX_LIFE ];
                    bool needDoctor = false;
                    bool isSelf = target.Id == npc.Id;

                    for( uint i = DAMAGE_BEGIN; i <= DAMAGE_END; i++ )
                    {
                        if( target.Damage[ i ] > 0 )
                        {
                            needDoctor = true;
                            break;
                        }
                    }

                    bool useStim = stims > 0;

                    if( needDoctor && npc.Timeout[ TO_SK_DOCTOR ] == 0 )
                    {
                        if( !isSelf )
                            npc.SetDir( GetDir( npc, target ) );
                        _CritAnimateUse( npc );
                        UseDoctor( npc, target, 0 );
                        npc.Wait( 500 );
                        return true;
                    }
                    else if( needHeal )
                    {
                        if( stims > 0 )
                        {
                            Item @ stim = npc.GetItem( stimsPid, -1 );
                            if( valid( stim ) )
                            {
                                if( !isSelf )
                                    npc.SetDir( GetDir( npc, target ) );
                                _CritAnimateUse( npc );
                                UseDrugOn( npc, target, stim );
                                npc.Wait( 500 );
                                return true;
                            }
                        }
                        else if( npc.Timeout[ TO_SK_FIRST_AID ] == 0 )
                        {

                            if( !isSelf )
                                npc.SetDir( GetDir( npc, target ) );
                            _CritAnimateUse( npc );
                            Healing( npc, target, 0 );
                            npc.Wait( 500 );
                            return true;
                        }
                    }
                    return true;
                }
                return true;
            }
        }
        break;

        case AI_PLANE_WALK_STEAL:
        {
            Critter@ target = GetCritter( plane.Walk_Reason_CritterId );
            if( valid( target ) )
            {
                uint dist = GetCrittersDistantion( npc, target );
                if( dist < 2 )
                {
                    Item@ item = GetItem( plane.Walk_Var0 );
                    // item
                    if( valid( item ) && critter_stealing( target, npc, item, item.GetCount() ) )
                    {
                        if( item.CritId == target.Id )
                        {
                            MoveItem( item, item.GetCount(), npc );
                        }
                        else
                        {
                            MoveItem( item, item.GetCount(), target );
                        }
                    }
                }

                return true;
            }
        }
        break;

        case AI_PLANE_PROSECUTION:
        {
            if( plane.Walk_Var1 != 0 )
            {
                Critter@ target = GetCritter( plane.Walk_Var1 );
                if( valid( target ) && !target.IsDead() )
                {
                    if( valid( target.GetMap() ) && target.GetMap().Id == npc.GetMap().Id )
                    {
                        NpcPlane@ planWalk = CreatePlane();
                        planWalk.Type = AI_PLANE_WALK;
                        planWalk.Priority = plane.Priority;
                        planWalk.Walk_HexX = target.HexX;
                        planWalk.Walk_HexY = target.HexY;
                        planWalk.Walk_Dir = ::GetDirection( npc.HexX, npc.HexY, target.HexX, target.HexX );
                        planWalk.Run = plane.Run;
                        planWalk.Walk_Cut = 3;
                        planWalk.Walk_Var0 = AI_PLANE_PROSECUTION;
                        planWalk.Walk_Var1 = plane.Walk_Var1;

                        npc.Wait( 1500 );
                        return AddPlaneChild( npc, plane, planWalk );
                    }
                }
            }
        }
        break;
        }
    }

    return true;
}

void plane_Sandbad( Critter& cr )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some plane runs, to manuality some steps.
// REASON_ATTACK_WEAPON
//  In: r0 target id, r1 0, r2 0
//  Out: r0 weapon id, r1 use index, r2 proto id of unarmed attack (if r0==0)
// REASON_ATTACK_DISTANTION
//  In: r0 target id, r1 0, r2 0
//  Out: r0 best dist, r1 min dist, r2 max dist (if==0 than run away)
// REASON_ATTACK_USE_AIM
//  In: r0 target id, r1 0, r2 0
//  Out: r0 use, r1 aim, r2 disable attack and wait this time (in ms)

bool MainPlane_NpcPlaneRun( Critter& npc, NpcPlane& plane, int reason, uint& r0, uint& r1, uint& r2 )
{
    // npc.Say( SAY_NORM_ON_HEAD, "reason " + reason + " r0 " + r0 + " r1 " + r1 + " r2 " + r2 );
    if( reason == REASON_ATTACK_WEAPON )
    {
        // Special weapons
        uint16 npcPid = npc.GetProtoId();
        if( npcPid == NPC_PID_FireGecko || npcPid == NPC_PID_ToughFireGecko )
        {
            Item@ weap = npc.GetItem( PID_FIRE_GECKO_FLAME_WEAPON, -1 );
            if( valid( weap ) && weap.AmmoCount > 0 )
            {
                r0 = weap.Id;
                r1 = 0;
                return true;
            }
        }
        else if( npcPid == NPC_PID_SporePlant || npcPid == NPC_PID_SporePlant2 )
        {
            Critter@ target = GetCritter( r0 );
            if( GetCrittersDistantion( npc, target ) > 2 )
            {
                Item@ weap = npc.GetItem( PID_PLANT_SPIKE, -1 );
                if( valid( weap ) )
                {
                    r0 = weap.Id;
                    r1 = 0;
                    return true;
                }
            }
        }

        // Default weapons
        r0 = 0;       // Use unarmed by default
        r1 = 0;
        r2 = 0;

        // Damaged two arms
        if( npc.Damage[ DAMAGE_LEFT_ARM ] != 0 && npc.Damage[ DAMAGE_RIGHT_ARM ] != 0 )
        {
            return true;
        }
		
        r2 = ( Random( 0, 4 ) == 0 ? 1000 : 1020 );

        // No use weapon
        uint aiId = npc.Stat[ ST_AI_ID ];
        int  bestWeapon = AI_BEST_WEAPON( aiId );
        if( bestWeapon == BW_Never )
            return true;
        // Get last battle weapon
        if( npc.Stat[ ST_LAST_WEAPON_ID ] == -1 )   // Previous seek not give result
        {
            r0 = 0;
            return true;
        }

        r0 = npc.Stat[ ST_LAST_WEAPON_ID ];
        r1 = npc.Stat[ ST_LAST_WEAPON_USE ];
        Item@ weapon = null;
        if( r0 != 0 )
            @weapon = npc.GetItemById( uint( r0 ) );
        if( valid( weapon ) && CheckBattleWeapon( npc, weapon ) )
		{
			Item@ currentWeapon = npc.GetItem( 0, SLOT_HAND1 );
			if( currentWeapon !is null && currentWeapon !is weapon && currentWeapon.GetProtoId() == weapon.GetProtoId() )
				npc.StatBase[ ST_LAST_WEAPON_ID ] = r0 = currentWeapon.Id;
            return true;
		}
        // Find new battle weapon
        npc.StatBase[ ST_LAST_WEAPON_ID ] = -1;
        npc.StatBase[ ST_LAST_WEAPON_USE ] = 0;
        r0 = 0;
        r1 = 0;

        // Sort skills
        int[] skillsNum = { SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_THROWING };
        uint skillsCount = skillsNum.length();
        SkillsSort( npc, skillsNum, 0, skillsCount );

        // Advanced sort
        switch( bestWeapon )
        {
        case BW_NoPref:
            break;
        case BW_Random:
            for( uint i = 0; i < skillsCount; i++ )
            {
                int i0 = Random( 0, skillsCount - 1 );
                int i1 = Random( 0, skillsCount - 1 );
                if( i0 != i1 )
                {
                    int tmp = skillsNum[ i0 ];
                    skillsNum[ i0 ] = skillsNum[ i1 ];
                    skillsNum[ i1 ] = tmp;
                }
            }
            break;
        case BW_Unarmed:
            SkillToBegin( skillsNum, SK_UNARMED );
            break;
        case BW_RangedOvMelee:
            SkillToBegin( skillsNum, SK_UNARMED );        // 4
            SkillToBegin( skillsNum, SK_THROWING );       // 3
            SkillToBegin( skillsNum, SK_ENERGY_WEAPONS ); // 2
            SkillToBegin( skillsNum, SK_BIG_GUNS );       // 1
            SkillToBegin( skillsNum, SK_SMALL_GUNS );     // 0
            SkillsSort( npc, skillsNum, 0, 4 );           // Sort 0, 1, 2, 3
            break;
        case BW_MeleeOvRanged:
            SkillToBegin( skillsNum, SK_THROWING );       // 4
            SkillToBegin( skillsNum, SK_ENERGY_WEAPONS ); // 3
            SkillToBegin( skillsNum, SK_BIG_GUNS );       // 2
            SkillToBegin( skillsNum, SK_SMALL_GUNS );     // 1
            SkillToBegin( skillsNum, SK_UNARMED );        // 0
            SkillsSort( npc, skillsNum, 1, 4 );           // Sort 2, 3, 4, 5
            break;
        case BW_UnarmOvThrown:
            SkillToBegin( skillsNum, SK_THROWING );       // 1
            SkillToBegin( skillsNum, SK_UNARMED );        // 0
            break;
        default:
            break;
        }

        // Get all weapons and check it
        Item@[] allWeapons;
        npc.GetItemsByType( ITEM_TYPE_WEAPON, allWeapons );
        for( uint i = 0, j = allWeapons.length(); i < j; i++ )
            if( not CheckBattleWeapon( npc, allWeapons[ i ] ) )
                @allWeapons[ i ] = null;

        bool isWeapon = false;

        // Choose one weapon
        for( uint i = 0; i < skillsCount; i++ )
        {
            int skill = skillsNum[ i ];

            for( uint k = 0, l = allWeapons.length(); k < l; k++ )
            {
                @weapon = allWeapons[ k ];
                if( not valid( weapon ) )
                    continue;

                for( int u = 0; u < 3; u++ )
                {
                    if( ( u == 0 && not _WeaponIsPrimaryAviable( weapon.Proto ) ) ||
                        ( u == 1 && not _WeaponIsSecondaryAviable( weapon.Proto ) ) ||
                        ( u == 2 && not _WeaponIsThirdAviable( weapon.Proto ) ) )
                        continue;

                    if( _WeaponSkill( weapon.Proto, u ) == skill )
                    {
                        npc.StatBase[ ST_LAST_WEAPON_ID ] = weapon.Id;
                        npc.StatBase[ ST_LAST_WEAPON_USE ] = u;
                        r0 = weapon.Id;
                        r1 = u;
                        return true;                         // Done, weapon founded
                    }
                }
            }
        }
        // Not found, hands used
        return true;
    }
    else if( reason == REASON_ATTACK_DISTANTION )
    {
        Critter@         target = GetCritter( r0 );
        uint8            mode = 0;
        const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode );
        int              use = _WeaponModeUse( mode );
        const ProtoItem@ ammo = ( valid( weapon ) && weapon.Weapon_MaxAmmoCount > 0 && weapon.Weapon_Caliber != 0 ? GetProtoItem( _CritGetItemHand( npc ).AmmoPid ) : null );
        int              wpnDist = valid( weapon ) ? _WeaponMaxDist( weapon, use ) : 1;
        int              multihex = npc.GetMultihex() + target.GetMultihex();

        if( not npc.IsCanWalk() )
        {
            int dist = GetDistantion( npc.HexX, npc.HexY, target.HexX, target.HexY );
            if( wpnDist < dist )
                dist = wpnDist;
            dist += multihex;
            r0 = r1 = r2 = dist;
            return true;
        }

        // non-ranged weapons:
        int skill = valid( weapon ) ? _WeaponSkill( weapon, use ) : SK_UNARMED;
        if( skill == SK_UNARMED )
        {
            int base =
                npc.Skill[ skill ] +
                ( target.IsKnockout() ? 40 : 0 ) -
                ( npc.Damage[ DAMAGE_EYE ] != 0 ? 25 : 0 );

            if( valid( weapon ) && !weapon.Weapon_IsUnarmed )
            {
                base += weapon.Weapon_BonusToHit;
                int strength = npc.Stat[ ST_STRENGTH ] + ( npc.Perk[ PE_WEAPON_HANDLING ] != 0 ? 3 : 0 );
                if( strength < weapon.Weapon_MinStrength )
                    base -= 20 * ( weapon.Weapon_MinStrength - strength );
                if( npc.Trait[ TRAIT_ONE_HANDER ] != 0 )
                    base += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );
            }
            int ai_min = AI_MIN_TO_HIT( npc.Stat[ ST_AI_ID ] );
            if( base < ai_min )
            {
                r0 = 0;
                r1 = 0;
                r2 = 0;
            }
            else
            {
                r0 = 1 + multihex;
                r1 = 1 + multihex;
                r2 = wpnDist + multihex;
            }
            return true;
        }
        else if( valid( weapon ) )
        // ranged weapons:
        {
            // set the minimum safe distance, 3 for grenades, 4 for rockets:
            r1 = 0;
            if( skill == SK_THROWING )
            {
                if( npc.Stat[ ST_STRENGTH ] * 3 < wpnDist )
                    wpnDist = npc.Stat[ ST_STRENGTH ] * 3;
                uint dmgType = _WeaponDmgType( weapon, use );
                if( dmgType == DAMAGE_PLASMA || dmgType == DAMAGE_EMP || dmgType == DAMAGE_EXPLODE )
                    r0 = 3;
            }
            else if( valid( ammo ) )
            {
                switch( ammo.ProtoId )
                {
                case PID_EXPLOSIVE_ROCKET:
                case PID_ROCKET_AP:
                case PID_ROBO_ROCKET_AMMO:
                    r1 = 4;
                default:
                    break;
                }
            }

            if( ( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_SCOPE_RANGE ) ) && ( r1 < 8 ) )
                r1 = 8;

            if( int(r1) > wpnDist )
            {
                r1 = 0;
                r0 = 0;
                r2 = 0;
                return true;
            }

            int base = npc.Skill[ skill ] +
                       ( target.IsKnockout() ? 40 : 0 ) -
                       ( npc.Damage[ DAMAGE_EYE ] != 0 ? 25 : 0 ) + weapon.Weapon_BonusToHit;

            int strength = npc.Stat[ ST_STRENGTH ] + ( npc.Perk[ PE_WEAPON_HANDLING ] != 0 ? 3 : 0 );
            if( strength < weapon.Weapon_MinStrength )
                base -= 20 * ( weapon.Weapon_MinStrength - strength );
            if( npc.Trait[ TRAIT_ONE_HANDER ] != 0 )
                base += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

            int ai_min = AI_MIN_TO_HIT( npc.Stat[ ST_AI_ID ] );
            int perception = npc.Stat[ ST_PERCEPTION ];
            int sharpshooter = 8 * npc.Perk[ PE_SHARPSHOOTER ];

            int mod = ( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_SCOPE_RANGE ) ? 5 : ( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_LONG_RANGE ) ? 4 : 2 ) );

            if( base + 8 * perception + sharpshooter < 95 )
            {
                if( base + 8 * perception + sharpshooter < ai_min )
                {
                    r1 = 0;
                    r0 = 0;
                    r2 = 0;
                    return true;
                }
                else
                    r0 = ( mod - 2 ) * perception;
            }
            else
            {
                if( base < 95 )
                    r0 = ( base + sharpshooter + 4 * mod * perception - 95 ) / 4;
                else
                {
                    if( npc.Damage[ DAMAGE_EYE ] != 0 )
                        r0 = ( base + 3 * sharpshooter + 12 * mod * perception - 95 ) / 12;
                    else
                        r0 = ( base + sharpshooter + 4 * mod * perception - 95 ) / 4;
                }
            }

            if( base < ai_min )
                r2 = ( base + sharpshooter + 4 * mod * perception - ai_min ) / 4;
            else
            {
                if( npc.Damage[ DAMAGE_EYE ] != 0 )
                    r2 = ( base + 3 * sharpshooter + 12 * mod * perception - ai_min ) / 12;
                else
                    r2 = ( base + sharpshooter + 4 * mod * perception - ai_min ) / 4;
            }

            if( npc.IsCanAim() )
            {
                if( weapon.Weapon_Aim_0 )
                {
                    uint reduction = ( r0 * 3 * npc.Stat[ ST_INTELLECT ] ) / 100;
                    reduction = MIN( 15, reduction );
                    r0 -= reduction;
                }
            }

            // left clamp:
            if( r0 < r1 )
                r0 = r1;
            if( r2 < r0 )
                r2 = r0;                 // this can be deleted under assumption that ai_min is always<=95, which should be true

            // right clamp
            if( wpnDist < int(r2) )
            {
                r2 = _WeaponMaxDist( weapon, use );
                if( r0 > r2 )
                    r0 = r2;
            }

            // Multihex
            r0 += multihex;
            r1 += multihex;
            r2 += multihex;
            return true;
        }
        Log( "Error get distantion" );
        return false;
    }


// REASON_ATTACK_USE_AIM
//  In: r0 target id, r1 0, r2 0
//  Out: r0 use, r1 aim, r2 disable attack and wait this time (in ms)

    else if( reason == REASON_ATTACK_USE_AIM )
    {
        if( !CogitateFiring( npc, r0, r1 ) )
        {
            r0 = 0;           // Primary attack
            r1 = 0;
            if( npc.IsCanAim() )
                r1 = Random( 0, 5 ) == 0 ? ( Random( 0, 1 ) == 0 ? HIT_LOCATION_GROIN : HIT_LOCATION_HEAD ) : HIT_LOCATION_EYES;
        }

        uint8            mode = 0;
        const ProtoItem@ weapon = npc.GetSlotProto( SLOT_HAND1, mode );
        int              ap = valid( weapon ) ? _WeaponApCost( weapon, r0 ) : 3;
        switch( r1 )
        {
        case HIT_LOCATION_EYES:
            ap += __ApCostAimEyes;
            break;
        case HIT_LOCATION_GROIN:
            ap += __ApCostAimGroin;
            break;
        case HIT_LOCATION_HEAD:
            ap += __ApCostAimHead;
            break;
        case HIT_LOCATION_LEFT_ARM:
        case HIT_LOCATION_RIGHT_ARM:
            ap += __ApCostAimArms;
            break;
        case HIT_LOCATION_LEFT_LEG:
        case HIT_LOCATION_RIGHT_LEG:
            ap += __ApCostAimLegs;
            break;
        default:
            break;
        }

        if( ap > npc.Stat[ ST_ACTION_POINTS ] )
        {
            if( npc.CountItem( PID_JET ) > 0 )
            {
                int countDrugs = npc.StatBase[ ST_COUNT_DRUGS ] + npc.StatBase[ ST_COUNT_DRUGS_EXT ];
                if( countDrugs <= npc.Trait[ TRAIT_CHEM_RESISTANT ] + 1 )
                {
                    NpcPlane@ child = CreatePlane();
                    child.Type = AI_PLANE_WALK;
                    child.Priority = AI_PLANE_HEAL_PRIORITY * 2;
                    child.Identifier = 0;
                    child.IdentifierExt = 0;
                    child.Walk_HexX = npc.HexX;
                    child.Walk_HexY = npc.HexY;
                    child.Run = false;
                    child.Walk_Cut = 0;
                    child.Walk_Var0 = PID_JET;
                    child.Walk_Dir = npc.Dir;
                    child.Walk_Reason_CritterId = npc.Id;
                    child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;
                    AddPlaneChild( npc, plane, child );
                }
            }
            r1 = 0;
            r2 = ( ap * __ApRegeneration ) / npc.Stat[ ST_ACTION_POINTS ] + 50;
        }
        else
        {
            ap -= npc.Stat[ ST_CURRENT_AP ];
            if( ap > 0 )
            {
                r2 = ( ap * __ApRegeneration ) / npc.Stat[ ST_ACTION_POINTS ] + 50;

                if( npc.CountItem( PID_JET ) > 0 )
                {
                    int countDrugs = npc.StatBase[ ST_COUNT_DRUGS ] + npc.StatBase[ ST_COUNT_DRUGS_EXT ];
                    if( countDrugs <= npc.Trait[ TRAIT_CHEM_RESISTANT ] + 1 )
                    {
                        NpcPlane@ child = CreatePlane();
                        child.Type = AI_PLANE_WALK;
                        child.Priority = AI_PLANE_HEAL_PRIORITY * 2;
                        child.Identifier = 0;
                        child.IdentifierExt = 0;
                        child.Walk_HexX = npc.HexX;
                        child.Walk_HexY = npc.HexY;
                        child.Run = false;
                        child.Walk_Cut = 0;
                        child.Walk_Var0 = PID_JET;
                        child.Walk_Dir = npc.Dir;
                        child.Walk_Reason_CritterId = npc.Id;
                        child.Walk_TypeWalkReason = AI_PLANE_WALK_HEAL;
                        AddPlaneChild( npc, plane, child );
                    }
                }
            }
        }
        return true;
    }

    return false;
}

bool CogitateFiring( Critter& critter, uint& mode, uint& aim ) // in: targetId, 0; out: mode, aim
{
    if(Random(1,10) > critter.Stat[ST_INTELLECT]) return false; // too stupid to think about this

    Critter@ target = GetCritter( mode );
    if( !valid( target ) )
        return false;
    Item@ weapon = critter.GetItem( 0, SLOT_HAND1 );

    if( !valid( weapon ) ) // true unarmed
    {
        mode = 0;
        if( critter.IsCanAim() )
		{
			uint8 mode_unarmed = 0;
			ProtoItem@ proto_unarmed = critter.GetSlotProto( SLOT_HAND1, mode_unarmed );
            aim = ChooseAim( critter, target, proto_unarmed, mode_unarmed, null );
			mode = mode_unarmed;
		}
        else
            aim = HIT_LOCATION_TORSO;

        return true;
    }

    if( weapon.GetType() != ITEM_TYPE_WEAPON )
        return false;
    ProtoItem@ protoWeapon = GetProtoItem( weapon.GetProtoId() );
    ProtoItem@ protoAmmo = ( weapon.AmmoPid != 0 ) ? GetProtoItem( weapon.AmmoPid ) : null;
    if( protoWeapon.Weapon_Skill_0 == SK_UNARMED ) // assuming all modes melee
    {
        if( _WeaponSkill( protoWeapon, 1 ) == SK_THROWING )
            mode = 1;
        else
            mode = 0;
    }
    else // assuming all modes ranged
    {
        if( protoWeapon.Weapon_Round_0 > 2 )
        {
            // cr.Say(SAY_NORM, "Burst is the only mode");
            mode = 0;
        }
        else
        {
            if( protoWeapon.Weapon_DmgType_1 == DAMAGE_UNCALLED )
            {
                // cr.Say(SAY_NORM, "Single shot is the only mode");
                mode = 0;
            }
            else
            {
                // cr.Say(SAY_NORM, "Second mode available");
                if( ValidateBurst( critter, target, protoWeapon, mode ) )
                {
                    // cr.Say(SAY_NORM, "Burst forced by check");
                    mode = 1;
                }
                else
                {
                    // cr.Say(SAY_NORM, "Single shot forced by check");
                    mode = 0;
                }
            }
        }
    }

    if( !critter.IsCanAim() || !_WeaponAim( protoWeapon, mode ) )
    {
        aim = HIT_LOCATION_TORSO;
        return true;
    }
    aim = ChooseAim( critter, target, protoWeapon, mode, protoAmmo );
    return true;
}

enum enum_aim
{
	none,
	eyes, 
	groin, 
	head, 
	arms, 
	legs,
	count
}

int ChooseAim( Critter& cr, Critter& target, ProtoItem@ weapon, uint8 mode, ProtoItem@ ammo )
{
    int tohit = RawToHit( cr, target, weapon, mode, ammo );
    // cr.Say(SAY_NORM, "choose aim, tohit="+tohit+", ap: "+cr.Stat[ST_CURRENT_AP]+" of "+cr.Stat[ST_ACTION_POINTS]);
    if( tohit < 26 )
        return HIT_LOCATION_NONE;

    int  ap = valid( weapon ) ? _WeaponApCost( weapon, mode ) : 3;
    uint skill = valid( weapon ) ? _WeaponSkill( weapon, mode ) : 0;
    int  penalty = valid( weapon ) ? ( skill == SK_UNARMED ? 2 : 1 ) : 2;
    int  maxap = cr.Stat[ ST_ACTION_POINTS ];

    int[] val( enum_aim::count );

    ProtoItem@ targetWeapon = target.GetSlotProto( SLOT_HAND1, mode );

    int              th = tohit;
    val[ 0 ] = 1000 * CLAMP( th, 5, 95 );

    int aps = ap + __ApCostAimEyes;
    th = tohit - __HitAimEyes / penalty;
    val[ 1 ] = aps <= maxap && ( ( cr.Dir + 3 ) % 6 == target.Dir ) ? 2500 * CLAMP( th, 5, 95 ) : 0;
    if( target.Damage[ DAMAGE_EYE ] == 0 )
        val[ 1 ] *= 2;

    th = tohit - __HitAimGroin / penalty;
    aps = ap + __ApCostAimGroin;
    val[ 2 ] = aps <= maxap ? 2000 * CLAMP( th, 5, 95 ) : 0;

    th = tohit - __HitAimHead / penalty;
    aps = ap + __ApCostAimHead;
    val[ 3 ] = aps <= maxap ? 2000 * CLAMP( th, 5, 95 ) : 0;

    th = tohit - __HitAimArms / penalty;
    aps = ap + __ApCostAimArms;
    val[ 4 ] = aps <= maxap ? 1600 * CLAMP( th, 5, 95 ) : 0;
    if( target.Damage[ DAMAGE_RIGHT_ARM ] == 0 || target.Damage[ DAMAGE_LEFT_ARM ] == 0 )
        val[ 4 ] *= 2;
    if( valid( targetWeapon ) && FLAG( targetWeapon.Flags, ITEM_TWO_HANDS ) && target.Damage[ DAMAGE_RIGHT_ARM ] == 0 && target.Damage[ DAMAGE_LEFT_ARM ] == 0 )
        val[ 4 ] *= 2;


    th = tohit - __HitAimLegs / penalty;
    aps = ap + __ApCostAimLegs;
    val[ 5 ] = aps <= maxap ? 1300 * CLAMP( th, 5, 95 ) : 0;
    if( target.Damage[ DAMAGE_LEFT_LEG ] == 0 || target.Damage[ DAMAGE_RIGHT_LEG ] == 0 )
        val[ 5 ] *= 2;

    // find best shot, with 1/3 chance for taking second-best shot
    int max = 0;
    for( int i = 1; i < 6; i++ )
        if( val[ i ] > val[ max ] || ( val[ i ] == val[ max ] && Random( 0, 1 ) == 0 ) )
            max = i;

    // cr.Say(SAY_NORM, "Aimed shot: "+max);

    switch( max )
    {
		case 1:
			return HIT_LOCATION_EYES;
		case 2:
			return HIT_LOCATION_GROIN;
		case 3:
			return HIT_LOCATION_HEAD;
		case 4:
		{
			if( target.Damage[ DAMAGE_RIGHT_ARM ] == 0 && target.Damage[ DAMAGE_LEFT_ARM ] == 0 )
			{
				if( Random( 0, 1 ) == 1 )
					return HIT_LOCATION_LEFT_ARM;
				else
					return HIT_LOCATION_RIGHT_ARM;
			}
			if( target.Damage[ DAMAGE_RIGHT_ARM ] == 0 )
				return HIT_LOCATION_LEFT_ARM;
			return HIT_LOCATION_RIGHT_ARM;
		}
		case 5:
		{
			if( target.Damage[ DAMAGE_RIGHT_LEG ] == 0 && target.Damage[ DAMAGE_LEFT_LEG ] == 0 )
			{
				if( Random( 0, 1 ) == 1 )
					return HIT_LOCATION_LEFT_LEG;
				else
					return HIT_LOCATION_RIGHT_LEG;
			}
			if( target.Damage[ DAMAGE_RIGHT_LEG ] == 0 )
				return HIT_LOCATION_LEFT_LEG;
			return HIT_LOCATION_RIGHT_LEG;
		}
		case 0:
		
		default: break;
    };
    return HIT_LOCATION_UNCALLED;
}

class CTraceFirstCritter : ITraceContext
{
    Critter@ Cr;
    uint     Mindist;
    uint16   Gx;
    uint16   Gy;
    CTraceFirstCritter( uint16 gx, uint16 gy, uint16 mindist )
    {
        this.Gx = gx;
        this.Gy = gy;
        @this.Cr = null;
        this.Mindist = mindist;
    }
    bool Exec( Map& map, uint16 hx, uint16 hy )
    {
        if( !map.IsHexRaked( hx, hy ) )
            return true;
        @Cr = map.GetCritter( hx, hy );
        return valid( Cr ) && Cr.Cond == COND_LIFE && GetDistantion( Gx, Gy, Cr.HexX, Cr.HexY ) >= Mindist;
    }
}

Critter@ TraceFirstCritter( uint16 hx, uint16 hy, uint16 tx, uint16 ty, Map& map, int dist, uint16 gx, uint16 gy, uint mindist )
{
    CTraceFirstCritter Tracer( gx, gy, mindist );
    LineTracerHex( hx, hy, tx, ty, map, dist, Tracer );
    return Tracer.Cr;
}

bool IsCurrentEnemy( Critter& cr, uint targetId )
{
    if( cr.CheckEnemyInStack( targetId ) )
        return true;
    array< NpcPlane@ > plans;
    cr.GetPlanes( plans );   // cr.GetPlanesByType(AI_PLANE_ATTACK, plans);
    for( uint i = 0, j = plans.length(); i < j; i++ )
        if( plans[ i ].Type == AI_PLANE_ATTACK && plans[ i ].Attack_TargId == targetId )
            return true;
    return false;
}

bool IsFrendly( Critter& critter, Critter& target )
{
	if( critter.Stat[ ST_TEAM_ID ] == 0 )
		return true;
    return target.Stat[ ST_TEAM_ID ] == critter.Stat[ ST_TEAM_ID ];
}

bool ValidateTarget( Critter& critter, Critter@ target )
{
	if( target is null )
		return false;
	if( !IsCurrentEnemy( critter, target.Id ) )
		return false;
	if( IsFrendly( critter, target ) )
		return false;
	return true;
}

bool ValidateBurst( Critter& critter, Critter& target, const ProtoItem@ weapon, uint mode )
{
// ToDo: Обновить под новые очереди
    // cr.Say(SAY_NORM, "validating burst, ap: "+cr.Stat[ST_CURRENT_AP]+" of "+cr.Stat[ST_ACTION_POINTS]+", needed "+weapon.Weapon_ApCost);
    // if(Random(0,2)==0) return false; // force normal shot, for a little diversity
    Map@ map = critter.GetMap();
    if( !valid( weapon ) )
        return true;
    uint round = _WeaponRound( weapon, mode );
    if( round < 3 )
        return true;
    uint     maxDist = _WeaponMaxDist( weapon, mode );

    uint16   hx = critter.HexX;
    uint16   hy = critter.HexY;
    uint16   tx = target.HexX;
    uint16   ty = target.HexY;
    if( !ValidateTarget( critter, TraceFirstCritter( hx, hy, tx, ty, map, maxDist, hx, hy, 0 ) ) )
    {
        /*blocker.Say(SAY_NORM, "I blocked the burst check");*/
        return false;
    }

    uint16 sx = hx;
    uint16 sy = hy;
    uint16 ex = tx;
    uint16 ey = hy;
    uint8  dir = GetOffsetDir( hx, hy, tx, ty, 89.0f );
    map.MoveHexByDir( sx, sy, dir, 1 );
    map.MoveHexByDir( ex, ey, dir, 1 );
    if( !ValidateTarget( critter, TraceFirstCritter( sx, sy, ex, ey, map, maxDist, hx, hy, 3 ) ) )
    {
        /*blocker.Say(SAY_NORM, "I blocked the burst check");*/
        return false;
    }

    sx = hx;
    sy = hy;
    ex = tx;
    ey = hy;
    dir = GetOffsetDir( hx, hy, tx, ty, -89.0f );
    map.MoveHexByDir( sx, sy, dir, 1 );
    map.MoveHexByDir( ex, ey, dir, 1 );
    if( !ValidateTarget( critter, TraceFirstCritter( sx, sy, ex, ey, map, maxDist, hx, hy, 3 ) )  )
    {
        /*blocker.Say(SAY_NORM, "I blocked the burst check");*/
        return false;
    }

    return true;
}

void SkillsSort( Critter& npc, array< int >& inout skills, const uint& in first, const uint& in count )
{
    const uint skillsLen = skills.length();
    uint       max = 0;
    int        tmp = 0;
    for( uint i = first, j = first + count; i < j; i++ )
    {
        max = i;
        for( uint k = i + 1, l = first + count; k < l; k++ )
        {
            if( skillsLen > k && skills[ k ] <= int(SKILL_END) && skills[ k ] >= int(SKILL_BEGIN) )
            {
                if( npc.Skill[ skills[ k ] ] > npc.Skill[ skills[ max ] ] )
                    max = k;
                if( max != i )
                {
                    tmp = skills[ max ];
                    skills[ max ] = skills[ i ];
                    skills[ i ] = tmp;
                }
            }
        }
    }
}

void SkillToBegin( int[]& skills, int skill )
{
    for( uint i = 1, j = skills.length(); i < j; i++ )
    {
        if( skills[ i ] == skill )
        {
            for( uint k = i; k > 0; k-- )
                skills[ k ] = skills[ k - 1 ];
            skills[ 0 ] = skill;
            break;
        }
    }
}

bool CheckBattleWeapon( Critter& npc, Item& weapon )
{
    if( weapon.GetType() != ITEM_TYPE_WEAPON )
        return false;
    if( !npc.IsAnim1( weapon.Proto.Weapon_Anim1 ) )
        return false;
    if( _ItemIsBroken( weapon ) )
        return false;
    if( FLAG( weapon.Flags, ITEM_TWO_HANDS ) && ( npc.Damage[ DAMAGE_LEFT_ARM ] != 0 || npc.Damage[ DAMAGE_RIGHT_ARM ] != 0 ) )
        return false;
    if( npc.Mode[ MODE_UNLIMITED_AMMO ] == 0 && weapon.Proto.Weapon_MaxAmmoCount > 0 && weapon.AmmoCount == 0 && !IsAmmoForWeapon( npc, weapon ) )
        return false;
    return true;
}

bool IsAmmoForWeapon( Critter& npc, Item& weapon )
{
    if( npc.CountItem( weapon.AmmoPid ) > 0 )
        return true;
    if( npc.CountItem( weapon.Proto.Weapon_DefaultAmmoPid ) > 0 )
        return true;
    Item@[] ammo;
    for( uint i = 0, j = npc.GetItemsByType( ITEM_TYPE_AMMO, ammo ); i < j; i++ )
    {
        Item@ a = ammo[ i ];
        if( a.Proto.Ammo_Caliber == weapon.Proto.Weapon_Caliber )
            return true;
    }
    return false;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
