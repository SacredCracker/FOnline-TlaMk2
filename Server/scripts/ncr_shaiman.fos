#include "_macros.fos"
#include "_msgstr.fos"

#define NOP_INFO 								(2) // смещение, по которому хранится описание и заголовок предмета "нота протеста"
#define BOSA_INFO								(2) // смещение, по которому хранится описание предемета "кейс с ответом братства"

#define LOCKPICK_NEEDED							(150) // скил отмычек, необходимый чтобы открыть сейф
#define MAX_RANDOM								(15) // верхний предел рандомайзера при определении шанса "открыл нет"

#define STR_FAIL_LOCKPICK						(2960) // текст для чата при провале взлома
#define STR_SUCC_LOCKPICK						(2961) // текст для чата при успешном взломе кейса

#define HOLO_INFO_NUM							(54) // номер записи в FOHOLO для сохранения в архив игроку текста "письма паладинов" при взломе сейфа.

#define BOS_SEARCH_RADIUS						(20) // радиус поиска дружественных нпц, которые подключаются к разговору

#define STR_FIRST_CONF							(6) // первая строка разговора Братьев стали при написании письма
#define STR_LAST_CONF							(22) // последняя строка

#define BOS_COME_PRIORITY						(41)// приоритет плана "подойти к главному"
#define BOS_WAIT_PRIORITY						(40)// приоритет плана "подождать у главного к главному"
// NoteOfProtest - игроку выдается нота протеста, которую нужно отнести в убежище 15


import bool GetFreeHex(Map& map, uint radius, uint16& hx, uint16& hy) from "caravan";
import bool AddMiscPlane(Critter& npc, uint priority, uint waitSecond, string@ funcName) from "npc_planes";
import bool AddWalkPlane(Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut) from "npc_planes";

void r_GiveNoP(Critter& player, Critter@ npc)
{
	Item @item=player.AddItem(PID_ELRON_FIELD_REP, 1);
	if (!valid(item)) return;
	item.Info=NOP_INFO;
	item.Update();
}

void r_GiveBOSAnswer(Critter& player, Critter@ npc)
{
	Item @item=player.AddItem(PID_RAMIREZ_BOX_CLOSED, 1);
	if (!valid(item)) return;
	item.SetScript("_BOSAnswerInit");
}

void _BOSAnswerInit(Item & item, bool firstTime)
{
	item.Info=BOSA_INFO;
	item.SetEvent(ITEM_EVENT_SKILL,"e_BOSAnswerSkill");
	item.Update();
}
// комментарий одного из рядом стоящих НПЦ
// strNum - номер строки с текстом
// radius - радиус поиска нпц, который скажет реплику
// sayType - тип разговора, которым будет сказана реплика
// maxTalkers - максимальное число говорящих нпц
 void r_NpcCommentT(Critter& player, Critter@ npc, int strNum, int radius, int sayType, int maxTalkers)
 {
	if (!valid(npc)) return;

	if(sayType==0) { sayType=Random(1,3); }

	Map @map=npc.GetMap();
	if (!valid(map)){return;}
	Critter@[] critters;
	map.GetCrittersHex(npc.HexX, npc.HexY, uint(radius), FIND_LIFE|FIND_ONLY_NPC, critters);

	if(critters.length()==0) return;

	uint talkers=Random(1,maxTalkers);
	if(talkers==1)
	{
		critters[Random(0,critters.length()-1)].SayMsg(uint(sayType), TEXTMSG_DLG,DLGSTR(npc.StatBase[ST_DIALOG_ID], strNum));
	}else{
		for(uint i=0, iMax=critters.length(); i<iMax; i++)
		{
			if(critters[i].Id==npc.Id) continue;
			critters[i].SayMsg(uint(sayType), TEXTMSG_DLG,DLGSTR(npc.StatBase[ST_DIALOG_ID], strNum));

			if(i==talkers) break;
		}
	}

 }
void  r_NpcComment(Critter& player, Critter@ npc, int strNum, int radius, int sayType)
{
	r_NpcCommentT(player, npc, strNum, radius, sayType, 3);
}

void r_BeginConference(Critter& player, Critter@ npc)
{
	if (!valid(npc)) return;

	npc.StatBase[ST_VAR1]=STR_FIRST_CONF;

	Map @map=npc.GetMap();
	if (!valid(map)){return;}
	Critter@[] critters;
	// собираем всех соседних братьев стали
	map.GetCrittersHex(npc.HexX, npc.HexY, BOS_SEARCH_RADIUS, FIND_LIFE|FIND_ONLY_NPC, critters);
	uint16 hX=npc.HexX;
	uint16 hY=npc.HexY;

	for(uint i=0, iMax=critters.length(); i<iMax; i++)
	{
		if(critters[i].Id==npc.Id) continue;
		if (!GetFreeHex(npc.GetMap(),2, hX, hY)) continue;
		AddWalkPlane(critters[i], BOS_COME_PRIORITY, hX, hY, GetDirection(hX,hY,npc.HexX,npc.HexY), false,0);
		AddMiscPlane(critters[i], BOS_WAIT_PRIORITY,__FullSecond+(STR_LAST_CONF*2)*60,"ncr_shaiman@plane_Misc");
	}

	AddMiscPlane(npc, BOS_WAIT_PRIORITY,__FullSecond+4*60,"ncr_shaiman@plane_NextWisp");

}
// говорим следующую фразу
void plane_NextWisp(Critter & cr)
{
	r_NpcCommentT(cr, cr, cr.StatBase[ST_VAR1] ,BOS_SEARCH_RADIUS, SAY_WHISP_ON_HEAD, 1);
	if(cr.StatBase[ST_VAR1]<STR_LAST_CONF)
	{
		AddMiscPlane(cr, BOS_WAIT_PRIORITY,__FullSecond+60,"ncr_shaiman@plane_NextWisp");
		cr.StatBase[ST_VAR1]++;
	}else{
		cr.StatBase[ST_VAR1]=0;
	}
}

bool d_CruzBusy(Critter& player, Critter@ cr)
{
	if (!valid(cr)) return false;
	return cr.StatBase[ST_VAR1] !=0;
}
bool d_NotCruzBusy(Critter& player, Critter@ cr)
{
	if (!valid(cr)) return true;
	return cr.StatBase[ST_VAR1]==0;
}
void plane_Misc(Critter& cr)
{
	// nothing
}

// ~setvar 4269 0 1 0 3
bool e_BOSAnswerSkill(Item& item, Critter& cr, int skill)
{
	if (!cr.IsPlayer()) return false;

	if(skill!=SK_LOCKPICK) return false;

	GameVar @qVar=GetLocalVar(LVAR_q_ncr_shaiman_protest, cr.Id);
	if (!valid(qVar)) return false;

	if(qVar.GetValue()!=4) return false;

	if(cr.Timeout[TO_SK_LOCKPICK]>0)
	{
		cr.SayMsg(SAY_NETMSG,TEXTMSG_GAME,STR_SKILL_WEARINESS);
		return true;
	}

	cr.TimeoutBase[TO_SK_LOCKPICK]=LOCKPICK_TIMEOUT(cr);

	if(cr.SkillBase[SK_LOCKPICK]>=LOCKPICK_NEEDED&&cr.StatBase[ST_LUCK]>Random(2,MAX_RANDOM))
	{

		qVar=5;
		DeleteItem(item);
		cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_SUCC_LOCKPICK);
		Item @ item1=cr.AddItem(PID_RAMIREZ_BOX_OPEN, 1);
		item1.Info=BOSA_INFO;
		item1.Update();
		cr.AddHolodiskInfo(HOLO_INFO_NUM);
		cr.StatBase[ST_EXPERIENCE]+=5000;
		return true;
	}else{

		return false;// без подсказок) cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_FAIL_LOCKPICK);
	}

}