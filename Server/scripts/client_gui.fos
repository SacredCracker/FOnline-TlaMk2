// Author: cvet
// Client GUI

#define CLIENT_GUI
#include "client_gui_h.fos"
#include "_defines.fos"
#include "_client_defines.fos"
#include "sprite.fos"
#include "_colors.fos"
#include "_macros.fos"

#define IS_COLLISION    # ( x1, y1, x2, y2, w, h )( ( x1 ) >= ( x2 ) && ( x1 ) <= ( x2 ) + ( w ) && ( y1 ) >= ( y2 ) && ( y1 ) <= ( y2 ) + ( h ) )

GUIScreen@[]@ AllScreens = array<GUIScreen@>( 0 );
GUIScreen@[]@ ActiveScreens = array<GUIScreen@>( 0 );
InputSpaceInstance@ InputSpace = InputSpaceInstance();

GUIScreen@ MouseMoveScreen = null;

IGUIScreenOpt@  LastScreenOpt = null;
IGUIElementOpt@ LastElementOpt = null;

IGUIHiddenCursorInfo@[] HiddensCursor;

class InputSpaceInstance
{
	InputSpaceInstance( )
	{
		AllDevice.resize( 2 );
		@AllDevice[0] = @KeyboardInstance( );
		@AllDevice[1] = @MouseInstance( );
	}
	
	void Lose( )
	{
		uint i = AllDevice.length();
		while( i-- > 0 )
		{
			if( AllDevice[i] !is null )
				AllDevice[i].Lose( );
		}
	}
	
	InputDevice@ get_Keyboard(){ return AllDevice[0]; }
	InputDevice@ get_Mouse(){ return AllDevice[1]; }
	
	InputDevice@[] AllDevice;
}

interface InputEvent{}

interface InputElement
{
	bool Jamming { get; set; }
	bool Pressed { get; set; }
	string get_Letter( uint char );
	uint get_PressTick( );
	void Lose();
}

class InputElementBasic : InputElement
{
	InputElementBasic( )
	{
		Name.resize( 4 );
		Name[0] = "";
		Name[1] = "";
		Name[2] = "";
		Name[3] = "";
		
		Lose();
	}

	InputElementBasic( string&in r, string&in rs, string&in e, string&in es )
    {
		Name.resize( 4 );
		Name[0] = r;
		Name[1] = rs;
		Name[2] = e;
		Name[3] = es;
		
		Lose();
    }
	
	bool Pressed
	{
		set override
		{
			if( PrivatePressed != value )
			{
				PrivatePressed = value;
				PrivatePressTick = value ? GetTick() : uint( -1 );
			}
		}
		
		get override{ return PrivatePressed; }
	}
	
	bool Jamming
	{
		set override{ PrivateJamming = value; }
		get override{ return PrivateJamming; }
	}
	
	string get_Letter( uint key ) override
	{
		return Name[key];
	}
	
	uint get_PressTick( ) override
	{
		if( PrivatePressTick == uint( -1 ) ) return PrivatePressTick;
		return GetTick() - PrivatePressTick;
	}
	
	void Lose()
	{
		Pressed = false;
		Jamming = false;
	}
	
    string[] Name;
	private bool PrivatePressed;
	private bool PrivateJamming;
	private uint PrivatePressTick;
}

class InputDevice
{
	InputDevice( string name )
	{
		Name = name;
	}

	bool Down( )
	{
		return true;
	}
	
	bool Up( )
	{
		return true;
	}
	
	void Lose( )
	{
		uint i = Elements.length();
		while( i-- > 0 )
		{
			if( Elements[i] !is null )
				Elements[i].Lose( );
		}
	}
	
	string Name;
	InputElement@[] Elements;
}

class MouseInstance : InputDevice
{
	MouseInstance( )
	{
		super( "Mouse" );
		Elements.resize( 10 );
		
		@Elements[ MOUSE_CLICK_LEFT ] = InputElementBasic( "lkm","LKM", "lkm","LKM" );
		@Elements[ MOUSE_CLICK_RIGHT ] = InputElementBasic( "rkm","RKM", "rkm","RKM" );
		@Elements[ MOUSE_CLICK_MIDDLE ] = InputElementBasic( "mkm","MKM", "mkm","MKM" );
		@Elements[ MOUSE_CLICK_WHEEL_UP ] = InputElementBasic( "wum","WUM", "wum","WUM" );
		@Elements[ MOUSE_CLICK_WHEEL_DOWN ] = InputElementBasic( "wdm","WDM", "wdm","WDM" );
		@Elements[ MOUSE_CLICK_EXT0 ] = InputElementBasic( "e0m","E0M", "e0m","E0M" );
		@Elements[ MOUSE_CLICK_EXT1 ] = InputElementBasic( "e1m","E1M", "e1m","E1M" );
		@Elements[ MOUSE_CLICK_EXT2 ] = InputElementBasic( "e2m","E2M", "e2m","E2M" );
		@Elements[ MOUSE_CLICK_EXT3 ] = InputElementBasic( "e3m","E3M", "e3m","E3M" );
		@Elements[ MOUSE_CLICK_EXT4 ] = InputElementBasic( "e4m","E4M", "e4m","E4M" );
	}
}

class KeyboardInstance : InputDevice
{
	KeyboardInstance( )
	{
		super( "Keyboard" );
		Elements.resize( 0x100 );
		for( uint i = 0; i < 0x100; i++ )
			@Elements[ i ] = InputElementBasic(); 
		@Elements[ DIK_1 ] =					InputElementBasic( "1", "!", "1", "!" );
		@Elements[ DIK_2 ] =                         InputElementBasic( "2", "\"", "2", "@" ); // "
		@Elements[ DIK_3 ] =                         InputElementBasic( "3", "№", "3", "#" );
		@Elements[ DIK_4 ] =                         InputElementBasic( "4", ";", "4", "$" );
		@Elements[ DIK_5 ] =                         InputElementBasic( "5", "%", "5", "%" );
		@Elements[ DIK_6 ] =                         InputElementBasic( "6", ":", "6", "^" );
		@Elements[ DIK_7 ] =                         InputElementBasic( "7", "?", "7", "&" );
		@Elements[ DIK_8 ] =                         InputElementBasic( "8", "*", "8", "*" );
		@Elements[ DIK_9 ] =                         InputElementBasic( "9", "(", "9", "(" );
		@Elements[ DIK_0 ] =                         InputElementBasic( "0", ")", "0", ")" );
		@Elements[ DIK_MINUS ] =                   InputElementBasic( "-", "_", "-", "_" );
		@Elements[ DIK_EQUALS ] =            	  InputElementBasic( "=", "+", "=", "+" );
		@Elements[ DIK_Q ] =                         InputElementBasic( "й", "Й", "q", "Q" );
		@Elements[ DIK_W ] =                         InputElementBasic( "ц", "Ц", "w", "W" );
		@Elements[ DIK_E ] =                         InputElementBasic( "у", "У", "e", "E" );
		@Elements[ DIK_R ] =                         InputElementBasic( "к", "К", "r", "R" );
		@Elements[ DIK_T ] =                         InputElementBasic( "е", "Е", "t", "T" );
		@Elements[ DIK_Y ] =                         InputElementBasic( "н", "Н", "y", "Y" );
		@Elements[ DIK_U ] =                         InputElementBasic( "г", "Г", "u", "U" );
		@Elements[ DIK_I ] =                         InputElementBasic( "ш", "Ш", "i", "I" );
		@Elements[ DIK_O ] =                         InputElementBasic( "щ", "Щ", "o", "O" );
		@Elements[ DIK_P ] =                         InputElementBasic( "з", "З", "p", "P" );
		@Elements[ DIK_LBRACKET ] =          	 InputElementBasic( "х", "Х", "[", "{" );
		@Elements[ DIK_RBRACKET ] =          	 InputElementBasic( "ъ", "Ъ", "]", "}" );
		@Elements[ DIK_A ] =                         InputElementBasic( "ф", "Ф", "a", "A" );
		@Elements[ DIK_S ] =                         InputElementBasic( "ы", "Ы", "s", "S" );
		@Elements[ DIK_D ] =                         InputElementBasic( "в", "В", "d", "D" );
		@Elements[ DIK_F ] =                         InputElementBasic( "а", "А", "f", "F" );
		@Elements[ DIK_G ] =                         InputElementBasic( "п", "П", "g", "G" );
		@Elements[ DIK_H ] =                         InputElementBasic( "р", "Р", "h", "H" );
		@Elements[ DIK_J ] =                         InputElementBasic( "о", "О", "j", "J" );
		@Elements[ DIK_K ] =					InputElementBasic( "л", "Л", "k", "K" );
		@Elements[ DIK_L ] =					InputElementBasic( "д", "Д", "l", "L" );
		@Elements[ DIK_SEMICOLON ] =			InputElementBasic( "ж", "Ж", ";", ":" );
		@Elements[ DIK_APOSTROPHE ] =		InputElementBasic( "э", "Э", "'", "'" );
		@Elements[ DIK_Z ] =					InputElementBasic( "я", "Я", "z", "Z" );
		@Elements[ DIK_X ] =					InputElementBasic( "ч", "Ч", "x", "X" );
		@Elements[ DIK_C ] =					InputElementBasic( "с", "С", "c", "C" );
		@Elements[ DIK_V ] =					InputElementBasic( "м", "М", "v", "V" );
		@Elements[ DIK_B ] =					InputElementBasic( "и", "И", "b", "B" );
		@Elements[ DIK_N ] =					InputElementBasic( "т", "Т", "n", "N" );
		@Elements[ DIK_M ] =					InputElementBasic( "ь", "Ь", "m", "M" );
		@Elements[ DIK_COMMA ] =				InputElementBasic( "б", "Б", ",", "<" );
		@Elements[ DIK_PERIOD ] =				InputElementBasic( "ю", "Ю", ".", ">" );
		@Elements[ DIK_SLASH ] =				InputElementBasic( ".", ",", "/", "?" );
		@Elements[ DIK_MULTIPLY ] =          InputElementBasic( "*", "*", "*", "*" );
		@Elements[ DIK_SPACE ] =				InputElementBasic( " ", " ", " ", " " );
		@Elements[ DIK_GRAVE ] =				InputElementBasic( "ё", "Ё", "`", "~" );
		@Elements[ DIK_NUMPAD1 ] =           InputElementBasic( "1", "1", "1", "1" );
		@Elements[ DIK_NUMPAD2 ] =           InputElementBasic( "2", "2", "2", "2" );
		@Elements[ DIK_NUMPAD3 ] =           InputElementBasic( "3", "3", "3", "3" );
		@Elements[ DIK_NUMPAD4 ] =           InputElementBasic( "4", "4", "4", "4" );
		@Elements[ DIK_NUMPAD5 ] =           InputElementBasic( "5", "5", "5", "5" );
		@Elements[ DIK_NUMPAD6 ] =           InputElementBasic( "6", "6", "6", "6" );
		@Elements[ DIK_NUMPAD7 ] =           InputElementBasic( "7", "7", "7", "7" );
		@Elements[ DIK_NUMPAD8 ] =           InputElementBasic( "8", "8", "8", "8" );
		@Elements[ DIK_NUMPAD9 ] =           InputElementBasic( "9", "9", "9", "9" );
		@Elements[ DIK_NUMPAD0 ] =           InputElementBasic( "0", "0", "0", "0" );
		@Elements[ DIK_SUBTRACT ] =          InputElementBasic( "-", "-", "-", "-" );
		@Elements[ DIK_ADD ] =				InputElementBasic( "+", "+", "+", "+" );
		@Elements[ DIK_DECIMAL ] =			InputElementBasic( ".", ".", ".", "." );
		@Elements[ DIK_DIVIDE ] =				InputElementBasic( "/", "/", "/", "/" );
		@Elements[ DIK_RETURN ] =				InputElementBasic( "\n", "\n", "\n", "\n" );
		@Elements[ DIK_NUMPADENTER ] =		InputElementBasic( "\n", "\n", "\n", "\n" );
		@Elements[ DIK_TAB ] =				InputElementBasic( "\t", "\t", "\t", "\t" );
	}
}

IGUIListingElement@ GUI_GetFocusListingElement( )
{
	GUIElement@ guielement = GetFocusElement( );
	if( guielement is null )
		return null;
		
	Listing@ listing = guielement.RefListing;
	if( listing !is null )
	{
		IGUIListingElement@ element = listing.GetElementNoDad( __MouseX, __MouseY );
		return element;
	}
	return null;
}

class Listing
{
	bool MouseChecked;
	IGUIListingElement@[]@ 	List;
	IGUIListingElement@     LastFocus;
	
    int			Width;	
    int			Height;
	
	int 			Shift;
	int 			ShiftLine;
	uint 			ShiftStep;
	int 			Offset;
	
	uint			Color;
	uint			ColorFocus;
	uint			ColorDown;
	
	int			HashPosX;
	int			HashPosY;
	
	int 			ScreenIndex;
	
	IGUIDragAndDropOpt@ DadOption;
	IGUI::ListingElementOpt@ Option;
	
	Listing( IGUIListingElement@[]@ list, int w, int h, int screenIndex )
	{
		ScreenIndex = screenIndex;
		Width = w;
		Height = h;
		Shift = 0;
		ShiftLine = 0;
		Offset = 5;
		ShiftStep = 1;
		SetColor( COLOR_GREEN, COLOR_LEMON, COLOR_WHITE );
		SetOption( null );
		opAssign( @list );
		@LastFocus = null;
		MouseChecked = true;
	}
	
	void SetColor( uint color, uint focus, uint down )
	{
		Color = color;
		ColorFocus = focus;
		ColorDown = down;
	}
	
	void SetOption( IGUI::ListingElementOpt@ opt ){ @Option = @opt; }
	
	uint NextLineIndex( uint beginIndex )
	{
		int w = 0;
		IGUIListingElement@ element = null;
		for( uint index = beginIndex, len = List.length(); index < len; index++ )
		{			
			@ element = @List[index];
			if( @element !is null && !Option.Hide[@element] )
			{			
				if( w + Option.Width[@element] > Width )
					return index;
					
				w += Option.Width[@element] + Offset;
				
				if( beginIndex != index && w > Width )
					return index;
			}
		}
		return beginIndex;
	}
	
	uint CountDraw( uint beginIndex )
	{
		uint ret = 0;
		
		int h = 0, w = 0;
		IGUIListingElement@ element = null;
		IGUIListingElement@[] lineElement = {};
		
		for( uint index = beginIndex, len = List.length(); index < len; index++ )
		{
			@ element = @List[index];
			if( @element !is null && !Option.Hide[@element] )
			{
				if( w + Option.Width[@element] > Width )
				{
					int hMax = 0;
					for( uint i = 0, ilen = lineElement.length(); i < ilen; i++ )
					{
						if( Option.Height[lineElement[i]] > hMax )
							hMax = Option.Height[lineElement[i]];
					}
					h += hMax + Offset;
					lineElement.resize( 0 );
					w = 0;
				}
				
				if( Option.Height[@element] + h > Height )
					break;
				
				ret++;
				
				w += Option.Width[@element] + Offset;
				lineElement.insertLast( @element );
			}			
		}
		return ret;
	}
	
	uint LastDrawIndex( uint beginIndex )
	{
		uint ret = 0;
		int h = 0, w = 0;
		IGUIListingElement@ element = null;
		IGUIListingElement@[] lineElement = {};
		
		for( uint index = beginIndex, len = List.length(); index < len; index++ )
		{
			@ element = @List[index];
			if( @element !is null && !Option.Hide[@element] )
			{
				if( w + Option.Width[@element] > Width )
				{
					int hMax = 0;
					for( uint i = 0, ilen = lineElement.length(); i < ilen; i++ )
					{
						if( Option.Height[@lineElement[i]] > hMax )
							hMax = Option.Height[@lineElement[i]];
					}
					h += hMax + Offset;
					lineElement.resize( 0 );
					w = 0;
				}
				
				if( Option.Height[@element] + h > Height )
					break;
				
				ret = index;
				
				w += Option.Width[@element] + Offset;
				lineElement.insertLast( @element );
			}			
		}
		return ret;
	}
	
	void SetShift( bool absolute, int shift )
	{	
		Shift = 0;
		if( !absolute )
			shift = ShiftLine + shift;
		
		ShiftLine = 0;
		
		if( shift > 0 )
		{
			const uint lastIndex = List.length() - 1;
			while( shift-- != 0 && LastDrawIndex( Shift ) != lastIndex )
			{
				Shift = NextLineIndex( Shift );
				ShiftLine++;
			}
		}
		
		if( @Option !is null )
			Option.Shift( Shift );
	}
	
	void MouseClickUp( int click, int x, int y )
	{
		if( @Option is null || GUI_GetMonitorScreenIndex( x, y ) != ScreenIndex || GUI_GetActiveScreen() != ScreenIndex )
			return;
		if( @CurrentDAD !is null )
		{
			if( click == MOUSE_CLICK_LEFT )
			{
				if( @DadOption !is null )
				{
					@CurrentDAD = DadOption.Drop( @CurrentDAD );
					if( @CurrentDAD !is null )
					{
						IGUIListingElement@ elem = cast<IGUIListingElement>(@CurrentDAD); 
						if( @elem !is null )
							List.insertLast( @elem );
					}
				}
				@CurrentDAD = null;
			}
			return;
		}
		
		IGUIListingElement@ element = @this.GetElement( x, y );
		if( @element !is null )
			element.ClickUp( click );
	}
	
	void MouseClickDown( int click, int x, int y )
	{			
		IGUIListingElement@ element = @this.GetElement( x, y );
		if( @element !is null )
			element.ClickDown( click );
	}
	
	void MouseMove( int x, int y )
	{
		IGUIListingElement@ element = @GetElement( x, y );
			
		if( @LastFocus !is @element )
		{
			if( @LastFocus !is null )
				LastFocus.LoseFocus( );
			if( @element !is null )
				element.Focus( );
				
			@LastFocus = @element;
		}
		
		if( @element !is null )
			element.MouseMove( x, y );
	}
	
	void InputLost( )
	{
		if( @LastFocus !is null )
		{
			LastFocus.LoseFocus( );
			@LastFocus = null;
		}
	}
	
	IGUIListingElement@ GetElement( int x, int y )
	{
		if( @CurrentDAD !is null )
			return null;
		return GetElementNoDad( x, y );
	}
	
	IGUIListingElement@ GetElementNoDad( int x, int y )
	{
		const bool isCheckCollision = ( GUI_GetMonitorScreenIndex( x, y ) == ScreenIndex && GUI_GetActiveScreen() == ScreenIndex );
		if( !isCheckCollision )
			return null;
			
		int h = 0, w = 0;
		IGUIListingElement@ element = null;
		IGUIListingElement@[] lineElement = {};
		
		for( uint index = Shift, len = List.length(); index < len; index++ )
		{
			@ element = @List[index];
			if( @element !is null && !Option.Hide[@element] )
			{
				if( w + Option.Width[@element] > Width )
				{
					int hMax = 0;
					for( uint i = 0, ilen = lineElement.length(); i < ilen; i++ )
					{
						if( Option.Height[lineElement[i]] > hMax )
							hMax = Option.Height[lineElement[i]];
					}
					h += hMax + Offset;
					lineElement.resize( 0 );
					w = 0;
				}
				
				if( Option.Height[@element] + h > Height )
					break;
				
				if( IS_COLLISION( x, y, HashPosX + w, HashPosY + h, Option.Width[@element], Option.Height[@element] ) )
					return @element;
				
				w += Option.Width[@element] + Offset;
				lineElement.insertLast( @element );
			}			
		}
		return null;
	}
	
	void Draw( int elementX, int elementY, bool isMouseDown )
	{
		HashPosX = elementX;
		HashPosY = elementY;
		if( @Option is null )
			return;
			
		int h = 0, w = 0;
		uint color;
		const bool isCheckCollision = ( GUI_GetMouseScreenIndex( ) == ScreenIndex && GUI_GetActiveScreen() == ScreenIndex && @CurrentDAD is null );
		IGUIListingElement@ element = null;
		IGUIListingElement@[] lineElement = {};
		
		for( uint index = Shift, len = List.length(); index < len; index++ )
		{
			@ element = @List[index];
			if( @element !is null && !Option.Hide[@element] )
			{
				if( w + Option.Width[@element] > Width )
				{
					int hMax = 0;
					for( uint i = 0, ilen = lineElement.length(); i < ilen; i++ )
					{
						if( Option.Height[@lineElement[i]] > hMax )
							hMax = Option.Height[@lineElement[i]];
					}
					h += hMax + Offset;
					lineElement.resize( 0 );
					w = 0;
				}
				
				if( Option.Height[@element] + h > Height )
					break;
				
				if( isCheckCollision && IS_COLLISION( __MouseX, __MouseY, HashPosX + w, HashPosY + h, Option.Width[@element], Option.Height[@element] ) )
					color = isMouseDown ? ColorDown : ColorFocus;
				else color = Color;
				
				// Use
				element.Draw( HashPosX + w, HashPosY + h, Option.Width[@element], Option.Height[@element], color );
				//
				
				w += Option.Width[@element] + Offset;
				lineElement.insertLast( @element );
			}
		}
	}
	
	IGUIListingElement@[]@ opAssign( IGUIListingElement@[]@ list )
	{ 
		@List = @list;
		return @List; 
	}
}

class GUIElement : IGUIElementOpt
{
    GUIElement( string@ sprName, int path, int screenIndex )
    {
        if( @sprName != null )
            @Surface = Sprite( sprName, path );
        DefaultPath = path;
		ScreenIndex = screenIndex;
        Init();
    }
	
    GUIElement( Sprite@ spr, int screenIndex  )
    {
        @Surface = spr;
        if( @spr != null )
			DefaultPath = spr.Path;
		else DefaultPath = PT_ART_INTRFACE;
		ScreenIndex = screenIndex;
		Init();
    }
	
	void Init( )
	{
	    PosX = 0;
        PosY = 0;
        Width = 0;
        Height = 0;
        SpriteWidth = 0;
        SpriteHeight = 0;
        IsTextInput = false;
        IgnoreFocus = false;
        DigitsOnly = false;
        InputMaxLen = 0;
        LastInput = 0;
        TextColorFocused = 0;
        TextColorDown = 0;
        @TextMultiColor = null;
        IsFocused = false;
        listBoxFocused = true;
        txtFrameX = 0;
        txtFrameY = 0;
        MousePressed.resize( MOUSE_CLICK_EXT4 + 1 );
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
            MousePressed[ i ] = false;
        SwitchEnabled = false;
		Jamming = false;
		IsJamming = false;
        isHidden = false;
        clickable = true;
        scale = false;
        isScrollableText = false;
        MultiSpriteFrameDX = 0;
        MultiSpriteFrameDY = 0;
        isScrollBar = false;
        sbInitialized = false;
        sbReversed = false;
        isListBox = false;
        autoCursor = false;
        isAutoCursor = false;
        NoFocusedKeyPress = false;
        textOffset = 0;
        SoundClick = "";
        @InitCallback = null;
        @DrawCallback = null;
        @MouseClickCallback = null;
        @MouseDownCallback = null;
        @MouseMoveCallback = null;
        @KeyPressCallback = null;
		@ListActiveCallback = null;
        GroupIndex = 0;
		@InputBlockLetters = null;
		@InputBlockKeys = null;
		CallbackHideChecker( null );
		InputCarriage = 0;
		InputCarriageTick = 0;
		NoCollision = false;
	}

    void Draw( int screenX, int screenY )
    {
        if( IsHidden( ) )
            return;
        scrX = screenX;
        scrY = screenY;
        int16 dx = MultiSpriteFrameDX,
              dy = MultiSpriteFrameDY;
        uint  index = 0;

        for( uint i = 0, iMax = MultiSprite.length(); i < iMax; i++ )
        {
            MultiSprite[ i ].Draw( screenX + PosX + dx, screenY + PosY + dy, MultiWidth, MultiHeight, 0, 0, MultiColor );
            // Смещение
            index++;
            dx += MultiSpriteDX + MultiWidth;
            if( index == MultiSpriteCountOfLine )
            {
                index = 0;
                dy += MultiSpriteDY + MultiHeight;
                dx = MultiSpriteFrameDX;
            }
        }

        index = 0;
        dx = 0;
        dy = 0;
        for( uint i = 0, iMax = multiText.length(); i < iMax; i++ )
        {
            DrawText( multiText[ i ], screenX + PosX + dx + MultiTextStartDx, screenY + PosY + dy + MultiTextStartDy, 200, 200, MultiTextColor, MultiTextFont, MultiTextFlag );

            // Смещение
            index++;
            dx += MultiTextDX;
            if( index == MultiTextCountOfLine )
            {
                index = 0;
                dy += MultiTextDY;
                dx = 0;
            }
        }

        bool isDown = ( ( MousePressed[ MOUSE_CLICK_LEFT ] || SwitchEnabled || ( IsJamming && Jamming ) ) && DownSpr !is null );
        if( isDown ) DownSpr.Draw( screenX + PosX, screenY + PosY );
		else if( Surface !is null )
        {
            if( SpriteWidth == 0 || SpriteHeight == 0 )
				Surface.Draw( screenX + PosX, screenY + PosY );
            else
				Surface.Draw( screenX + PosX, screenY + PosY, SpriteWidth, SpriteHeight, scale ? VISUAL_FLAG_ZOOM : 0, Surface.Color );
        }
        if( isScrollableText && !isListBox )
        {
            text = "";
            uint lines;
            /*if((scrollText.length()-textOffset)>maxTextLines) lines=maxTextLines+textOffset;
               else lines=scrollText.length();*/
            // TabaK. Перепилил во избежание ошибки с несуществующим индексом.
            for( uint n = textOffset; n < uint( maxTextLines + textOffset ) && n < scrollText.length(); n++ )
                text += scrollText[ n ] + "\n";
        }

        if( isScrollBar && sbInitialized )
        {
            int curPos = 0;
            if( sbReversed )
                curPos = int( ( sbRange - sbCurrentValue ) * sbStep );
            else
                curPos = int( sbCurrentValue * sbStep );
			Scroll.Draw( screenX + PosX, int( ( screenY + PosY + curPos ) - Scroll.Height * 0.5 ), Scroll.Width, Scroll.Height, 0, 0, Scroll.Color );
        }
        if( !isListBox )
        {
            // Width=1;
            //if( text != "" )
            {
                string renderText = text;
                if( IsTextInput )
                {
					if( font == FONT_BIG_NUM )
					{
						if( LastInput + REAL_MS( 150 ) > __FullSecond )
							renderText[ renderText.length() - 1 ] = ';';
						else if( LastInput + REAL_MS( 300 ) > __FullSecond && LastInput + REAL_MS( 450 ) < __FullSecond )
							renderText[ renderText.length() - 1 ] = ':';
					}
					else
						if( ( ( IsFocused || IgnoreFocus ) && ( IsTextInput || KeyPressCallback !is null ) ) || NoFocusedKeyPress )
						{
							if( font == FONT_FALLOUT )
							{
								if( GetTick() - InputCarriageTick  > 150 )
								{
									if( InputCarriage == '!' )
										InputCarriage = '.';
									else
										InputCarriage = '!';
									InputCarriageTick = GetTick();
								}
								if( InputCarriage != 0 )
								{
									renderText.resize( renderText.length() + 1 );
									renderText[ renderText.length() - 1 ] = InputCarriage;
								}
							}
						}
                }
                if( Height != 0 || Width != 0 )
                {
                    DrawText( renderText, screenX + PosX + txtFrameX, screenY + PosY + txtFrameY,
                              Width != 0 ? Width - txtFrameX : __ScreenWidth - txtFrameX, Height != 0 ? Height - txtFrameY : ( __ScreenHeight - txtFrameY ) - ( isDown ? 2 : 0 ),
                              IsTextInput && IsFocused ? TextColorFocused : ( isDown && TextColorDown != 0 ? TextColorDown : TextColor ), font, TextFlags );
                }
                else
                {
                    DrawText( renderText, screenX + PosX + txtFrameX, screenY + PosY + txtFrameY,
                              ( @Surface !is null && Surface.Width != 0 ) ? Surface.Width - txtFrameX : __ScreenWidth - txtFrameX, ( ( @Surface !is null && Surface.Height != 0 ) ? Surface.Height - txtFrameY : __ScreenHeight - txtFrameY ) - ( isDown ? 2 : 0 ),
                              IsTextInput && IsFocused ? TextColorFocused : ( isDown && TextColorDown != 0 ? TextColorDown : TextColor ), font, TextFlags );
                }
            }
        }
        else
        {
            if( scrollText.length() > 0 )
            {
                uint8 m = 0;
                if( textOffset + maxTextLines <= int( scrollText.length() ) )
                    m = uint( maxTextLines - 1 );
                else
                    m = uint( maxTextLines - textOffset );
                uint color;
                for( uint n = 0; n <= m; n++ )
                {
                    if( lbIndex >= 0 && lbIndex == textOffset + n && listBoxFocused )
                    {
                        if( MousePressed[ MOUSE_CLICK_LEFT ] )
                            color = TextColorDown;
                        else
                            color = TextColorFocused;
                    }
                    else if( @TextMultiColor !is null && TextMultiColor.length() > uint( n + textOffset ) )
                        color = TextMultiColor[ n + textOffset ];
                    else
                        color = TextColor;
                    if( int( scrollText.length() ) - 1 >= n + textOffset )
                        DrawText( scrollText[ n + textOffset ], screenX + PosX + txtFrameX, screenY + PosY + n * fontHeight + txtFrameY, ( @Surface !is null && Surface.Width != 0 ) ? Surface.Width - txtFrameX : __ScreenWidth - txtFrameX,
                                  ( @Surface !is null && Surface.Height != 0 ) ? Surface.Height - txtFrameY : __ScreenHeight - txtFrameY, color, font, TextFlags );
                }
            }
        }

		if( @RefListing !is null )
			RefListing.Draw( screenX + PosX, screenY + PosY, MousePressed[ MOUSE_CLICK_LEFT ] );
        
		if( @DrawCallback !is null )
            DrawCallback.OnDraw();
        if( @DrawPosCallback !is null )
            DrawPosCallback.OnDraw( screenX, screenY, PosX, PosY );
    }

    bool MouseDown( int click )
    {
        if( isHidden || !clickable )
            return false;
        if( SoundClick != "" && click == MOUSE_CLICK_LEFT )
            PlaySound( SoundClick );
		if( isScrollableText )
		{
			if( click == MOUSE_CLICK_WHEEL_DOWN )
			{	
				if( maxTextLines + textOffset < int( scrollText.length() ) )
					textOffset += 1;
			}
			else if( click == MOUSE_CLICK_WHEEL_UP && textOffset > 0 )
				textOffset -= 1;
		}
        if( click == MOUSE_CLICK_LEFT && isScrollBar && sbInitialized && sbRange > 0 )
        {
            if( mouseY < 0 )
                sbCurrentValue = sbReversed ? sbRange : 0;
            else if( mouseY > Surface.Height && sbReversed )
                sbCurrentValue = 0;
            else
            {
                float x = float(mouseY) / sbStep;
                if( fraction( x ) * 10 > 5 )
                    sbCurrentValue = sbReversed ? uint( floor( x ) ) : uint( ceil( x ) );
                else
                    sbCurrentValue = sbReversed ? uint( ceil( x ) ) : uint( floor( x ) );
                if( sbReversed )
                    sbCurrentValue = sbRange - sbCurrentValue;
            }
            if( sbCurrentValue > sbRange )
                sbCurrentValue = sbRange;
        }
		
		if( @RefListing !is null )
		{
			if( MOUSE_CLICK_WHEEL_DOWN == click )
				RefListing.SetShift( false, RefListing.ShiftStep );
			else if( MOUSE_CLICK_WHEEL_UP == click )
				RefListing.SetShift( false, 0 - RefListing.ShiftStep );
			
			RefListing.MouseClickDown( click, __MouseX, __MouseY );
		}
		
        if( @MouseDownCallback !is null )
            MouseDownCallback.OnMouseDown( click );

        if( @DownSpr !is null || @MouseClickCallback !is null || IsTextInput || isScrollBar || @RefListing !is null || @MouseMoveCallback !is null || isListBox )
        {
            MousePressed[ click ] = true;
			if( click == MOUSE_CLICK_LEFT )
				Jamming = !Jamming;
            return true;
        }
        return false;
    }

    void MouseUp( int click, bool isCollision )
    {
        if( isHidden || !clickable )
            return;
			
		int w = Width, h = Height;
		if( @Surface !is null )
		{
			w = Surface.Width;
			h = Surface.Height;
		}
		else
		{
			if(SpriteWidth != 0)
				w = SpriteWidth;
			if(SpriteHeight != 0)
				h = SpriteHeight;
		}
		
        if( MousePressed[ click ] )
        {
			if( isCollision )
			{
				if( @MouseClickCallback !is null )
					MouseClickCallback.OnMouseClick( click );
				if( isListBox && fontHeight > 0 && @ListActiveCallback !is null && lbIndex >= 0 )
				{
					if( ( mouseY - txtFrameY ) / fontHeight < maxTextLines && mouseY >= 0 + txtFrameY && mouseX >= 0 + txtFrameX && mouseX <= w - txtFrameX )
					{
						lbIndex = ( mouseY - txtFrameY ) / fontHeight + textOffset;
					}
					else
						lbIndex = -1;
					if( scrollText.length() > uint( lbIndex ) )
						ListActiveCallback.OnListActive( lbIndex, @scrollText[lbIndex], click );
				}	
				
				if( @RefListing !is null )
					RefListing.MouseClickUp( click, __MouseX, __MouseY );
			}
			else if( @MouseDropCallback !is null )
				MouseDropCallback.OnMouseDrop( click );
			MousePressed[ click ] = false;
        }
		else if( RefListing !is null )
		{
			if( ( click == MOUSE_CLICK_LEFT && isCollision && @CurrentDAD !is null ) || !RefListing.MouseChecked )
				RefListing.MouseClickUp( click,  __MouseX, __MouseY );
		}
    }

    void MouseMove( int x, int y )
    {
        if( isHidden )
            return;
        mouseX = x - scrX - PosX;
        mouseY = y - scrY - PosY;
		
		int w = Width, h = Height;
		if( @Surface !is null )
		{
			w = Surface.Width;
			h = Surface.Height;
		}
		else
		{
			if(SpriteWidth != 0)
				w = SpriteWidth;
			if(SpriteHeight != 0)
				h = SpriteHeight;
		}
        if( autoCursor )
        {
            if( mouseX > 0 && mouseY > 0 && mouseX < w && mouseY < h && !isAutoCursor && GetCurrentCursor() != setCursor )
            {
                lastCursor = GetCurrentCursor();
                ChangeCursor( setCursor );
                isAutoCursor = true;
            }
            if( mouseX < 0 || mouseY < 0 || mouseX > w || mouseY > h )
            {
                if( isAutoCursor )
                {
                    isAutoCursor = false;
                    ChangeCursor( lastCursor );
                }
            }
        }
        if( MousePressed[ MOUSE_CLICK_LEFT ] && isScrollBar && sbRange > 0 )
        {
            if( mouseY < 0 )
                sbCurrentValue = sbReversed ? sbRange : 0;
            else if( mouseY > h && sbReversed )
                sbCurrentValue = 0;
            else
            {
                float scrollbar = float(mouseY) / sbStep;
                if( fraction( scrollbar ) * 10 > 5 )
                    sbCurrentValue = sbReversed ? uint( floor( scrollbar ) ) : uint( ceil( scrollbar ) );
                else
                    sbCurrentValue = sbReversed ? uint( ceil( scrollbar ) ) : uint( floor( scrollbar ) );
                if( sbReversed )
                    sbCurrentValue = sbRange - sbCurrentValue;
            }
            if( sbCurrentValue > sbRange )
                sbCurrentValue = sbRange;
        }
        if( isListBox && fontHeight > 0 )
        {
            if( ( mouseY - txtFrameY ) / fontHeight < maxTextLines && mouseY >= 0 + txtFrameY && mouseX >= 0 + txtFrameX && mouseX <= w - txtFrameX )
            {
                lbIndex = ( mouseY - txtFrameY ) / fontHeight + textOffset;
            }
            else
                lbIndex = -1;
        }
		
		if( @RefListing !is null )
			RefListing.MouseMove( x, y );
			
		if( @MouseMoveCallback !is null && ( ( mouseX > 0 && mouseY > 0 && mouseX < w && mouseY < h ) ||  isScrollBar ) )
            MouseMoveCallback.OnMouseMove( MousePressed[ MOUSE_CLICK_LEFT ] );
    }

    bool KeyPress( uint8 key )
    {
        if( isHidden )
            return false;
        bool  result = false;
		uint8 letter = 0;
		
		if( @InputBlockKeys is null || InputBlockKeys.find( key ) == -1 )
		{
			uint  startLength = text.length();
			result = ProcessKey( key, text, letter );
		
			if( text.length() > InputMaxLen )
				text.resize( InputMaxLen );
			if( text.length() > startLength )
			{
				if( @InputBlockLetters !is null  )
					for( uint i = 0, iEnd = InputBlockLetters.length(); i < iEnd; i++ )
						if( letter == InputBlockLetters[i] )
						{
							text.resize( startLength );
							break;
						}				
			
				if( DigitsOnly )
				{
					if( letter > 0x39 || letter < 0x30 )
						text.resize( startLength );
					else
						LastInput = __FullSecond;
				}
			}
		}
		if( @KeyPressCallback !is null )
			KeyPressCallback.OnKeyPress( key, letter, result );
        return result;
    }

    void InputLost()
    {
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
            MousePressed[ i ] = false;
			
		if( @RefListing !is null )
			RefListing.InputLost();
    }

    GUIElement@ GetNewInstance()
    {
        GUIElement newElement = this;
        return @newElement;
    }

    // Options
    IGUIElementOpt@ CallbackInit( IGUI::ElementCallbackInit@ callback )									{ @InitCallback = callback; return this; }
    IGUIElementOpt@ CallbackDraw( IGUI::ElementCallbackDraw@ callback )									{ @DrawCallback = callback; return this; }
    IGUIElementOpt@ CallbackDrawPos( IGUI::ElementCallbackDrawPos@ callback )							{ @DrawPosCallback = callback; return this; }
    IGUIElementOpt@ CallbackMouseClick( IGUI::ElementCallbackMouseClick@ callback )					{ @MouseClickCallback = callback; return this; }
    IGUIElementOpt@ CallbackMouseDown( IGUI::ElementCallbackMouseDown@ callback )						{ @MouseDownCallback = callback; return this; }
    IGUIElementOpt@ CallbackMouseDrop( IGUI::ElementCallbackMouseDrop@ callback )						{ @MouseDropCallback = callback; return this; }
    IGUIElementOpt@ CallbackMouseMove( IGUI::ElementCallbackMouseMove@ callback )						{ @MouseMoveCallback = callback; return this; }
    IGUIElementOpt@ CallbackKeyPress( IGUI::ElementCallbackKeyPress@ callback )						{ @KeyPressCallback = callback; return this; }
	IGUIElementOpt@ CallbackListActive( IGUI::ElementCallbackCallbackListActive@ callback ){ @ListActiveCallback = @callback; return this; }
	
    IGUIElementOpt@ Position( int x, int y )
    {
        PosX = x;
        PosY = y;
        return this;
    }

	IGUIElementOpt@ Position( int[]& pos )
	{
		if( pos.length() == 4 )
			return @Position( pos[0], pos[1], pos[2], pos[3] );
		else if( pos.length() == 2 ) return @Position( pos[0], pos[1] );
		return this;
	}
	
	
    IGUIElementOpt@ Position( int x, int y, int w, int h )
    {
        PosX = x;
        PosY = y;
		
		//if( w != 0 )
		{			
			Width = w;
			SpriteWidth = w;
			if( @Surface !is null )
				Surface.Width = w;
		}
		//if( h != 0 )
		{			
			Height = h;
			SpriteHeight = h;
			if( @Surface !is null )
				Surface.Height = h;
		}
		
        return this;
    }

    IGUIElementOpt@ Position( string& iniKey )
    {		
        string@ str = GetIfaceIniStr( iniKey );
        if( @str == null || str == "" )
            return Position( 0, 0, 0, 0);

        string@[]@ valuesStr = splitEx( str, " " );
        int[] values;
        int memmory = 0;
		for( int i = 0, iend = valuesStr.length(); i < iend; i++ )
            if( SafeStrToInt( valuesStr[ i ], memmory ) )
				values.insertLast( memmory );
		if( values.length() >= 3 )
			values[2] -= values[0] + 1;
		if( values.length() >= 4 )
			values[3] -= values[1] + 1;
			
		return @Position( values );
    }
	
    IGUIElementOpt@ CallbackHideChecker( IGUI::ElementHideChecker@ callback )
	{
		@HideChecker = callback;
        return this;
	}

    IGUIElementOpt@ DownPic( string@ sprName )
    {
        if( @sprName != null )
		{
			Sprite@ spr = Sprite();//cast<Sprite@>(@DownSpr);
			spr.Load( sprName, DefaultPath );
			if(@Surface !is null)
			{
				Surface.Width = spr.Width;
				Surface.Height = spr.Height;
			}
			@DownSpr = spr;
		}
        else
            @DownSpr = null;
        return this;
    }

    IGUIElementOpt@ Text( string@ t, int f, uint color, uint downColor, int flags )
    {
        if( @t is null )
            text = "";
        else
            text = t;
        font = f;
        TextColor = color;
        if( !isListBox )
            TextColorDown = downColor;
        TextFlags = flags;
        int w = 0;
        int h = 0, height = 0;
        int lines = 0;
        GetTextInfo( "TEST", 200, 200, font, flags, w, h, lines );
        fontHeight = h + 1;
		if(@Surface is null)
		{
			if( SpriteHeight == 0 )
				height = Height;
			else height = SpriteHeight;
		}
		else height = Surface.Height;
        maxTextLines = ( height + 1 - txtFrameY * 2 ) / fontHeight;
        if( isScrollableText )
        {
            scrollText = splitEx( text, "\n" );
            if( scrollText.last().length() < 2 )
                scrollText.removeLast();
        }
        return this;
    }

    IGUIElementOpt@ Text( string@ t, int f, uint color, uint[] multicolor, uint downColor, int flags )
    {
        @TextMultiColor = multicolor;
		return Text( t, f, color, downColor, flags );
    }

    IGUIElementOpt@ TextInput( bool enabled, uint maxLen, uint colorFocused )
    {
        IsTextInput = enabled;
        InputMaxLen = maxLen;
        TextColorFocused = colorFocused;
        return this;
    }

    IGUIElementOpt@ Switch( bool enabled )
    {
        SwitchEnabled = enabled;
        return this;
    }

    IGUIElementOpt@ SetJamming( bool enabled )
    {
        IsJamming = enabled;
        return this;
    }

    IGUIElementOpt@ ToHide( bool hide )
    {
        isHidden = hide;
        if( isAutoCursor && hide )
        {
            isAutoCursor = false;
            ChangeCursor( lastCursor );
        }
        return this;
    }

    IGUIElementOpt@ ScrollableText( bool scrollable )
    {
        isScrollableText = scrollable;
        return this;
    }

    IGUIElementOpt@ SetScroll( bool add, int val )
    {
        if( isScrollableText )
        {
            if( add && maxTextLines + textOffset + val < int(scrollText.length() + 1) && textOffset + val >= 0 )
                textOffset += val;
            if( !add && val >= 0 && maxTextLines + val < int(scrollText.length() + 1) )
                textOffset = val;
        }
        return this;
    }

    IGUIElementOpt@ SBSetRange( uint range )
    {
        if( range > 0 )
        {
            sbRange = range;
            sbStep = float(Surface.Height) / range;
            sbCurrentValue = 0;
            sbInitialized = true;
        }
        return this;
    }

    IGUIElementOpt@ SBScrollPic( string@ sprName )
    {
		Sprite@ spr = Sprite();
		spr.Load( sprName, DefaultPath );			
		@Scroll = @spr;
		
        Scroll.Width = Surface.Width;
        return this;
    }

    IGUIElementOpt@ SBSetValue( uint val )
    {
        if( sbInitialized )
            sbCurrentValue = val;
        return this;
    }

    IGUIElementOpt@ IsScrollBar( bool scroll )
    {
        isScrollBar = scroll;
        return this;
    }

    IGUIElementOpt@ IsListBox( bool listbox, uint highlight, uint down )
    {
        isListBox = listbox;
        TextColorFocused = highlight;
        TextColorDown = down;
        return this;
    }

    IGUIElementOpt@ ListBoxFocused( bool focused )
    {
        listBoxFocused = focused;
        return this;
    }

    IGUIElementOpt@ List( string@[] @ list )
    {
        font = FONT_FALLOUT;
        TextFlags = FT_ALIGN | FT_UPPER;
        fontHeight = 10;
        maxTextLines = ( Surface.Height + 1 - txtFrameY * 2 ) / fontHeight;
        scrollText = list;
        return this;
    }

    IGUIElementOpt@ Font( int font, uint color )
    {
        font = font;
        TextColor = color;
        int w = 0;
        int h = 0;
        int lines = 0;
        GetTextInfo( "TEST", 200, 200, font, TextFlags, w, h, lines );
        fontHeight = h + 1;
        maxTextLines = ( Surface.Height + 1 - txtFrameY * 2 ) / fontHeight;
        return this;
    }

    IGUIElementOpt@ TextFrame( int8 x, int8 y )
    {
        txtFrameX = x;
        txtFrameY = y;
        if( isScrollableText || isListBox )
        {
            if( fontHeight > 0 )
                maxTextLines = ( Surface.Height + 1 - txtFrameY * 2 ) / fontHeight;
        }
        return this;
    }

    IGUIElementOpt@ MultiText( string[] texts, int16 startDx, int16 startDy, uint16 dX, uint16 dY, uint8 countOfLine, int font, uint color, int flags )
    {
        MultiTextStartDx = startDx;
        MultiTextStartDy = startDy;
        MultiTextDX = dX;
        MultiTextDY = dY;
        MultiTextCountOfLine = countOfLine;
        MultiTextFont = font;
        MultiTextColor = color;
        MultiTextFlag = flags;

        uint16 textCount = texts.length();
        multiText = texts;
        MultiTextCountOfLine = countOfLine;
        return this;
    }

    IGUIElementOpt@ MultiPicture( uint[] hashs, uint8 dir, uint16 height, uint16 width, uint16 dX, uint16 dY, uint8 countOfLine, uint color )
    {
        uint16 hashsCount = hashs.length();

        MultiSpriteDX = dX;
        MultiSpriteDY = dY;
        MultiWidth = width;
        MultiHeight = height;
        MultiColor = color;
        MultiSpriteCountOfLine = countOfLine;
        MultiSprite.resize( hashsCount );
        for( uint16 i = 0; i < hashsCount; i++ )
        {		
			Sprite@ spr = Sprite();
			spr.Load( hashs[ i ], dir );
			@MultiSprite[ i ] = @spr;
        }
        return this;
    }

    IGUIElementOpt@ MultiPictureFrame( int16 x, int16 y )
    {
        MultiSpriteFrameDX = x;
        MultiSpriteFrameDY = y;

        return this;
    }

    IGUIElementOpt@ Picture( string sprName )
    {
        return this.Picture( sprName, DefaultPath );
    }

    IGUIElementOpt@ Picture( Sprite@ spr )
    {
        @Surface = @spr;
        return this;
    }

    IGUIElementOpt@ Picture( string sprName, int path )
    {
		if( @Surface is null )
			@Surface = Sprite();
		Sprite@ spr = cast<Sprite@>(@Surface);
		if( spr !is null )
			spr.Load( sprName, path );
        return this;
    }

    IGUIElementOpt@ Picture( uint hash, uint8 dir )
    {
		if( @Surface is null )
			@Surface = Sprite();
		Sprite@ spr = cast<Sprite@>(@Surface);
		if( spr !is null )
			spr.Load( hash, dir );
        return this;
    }

    IGUIElementOpt@ PictureSize( uint16 width, uint16 height )
    {
        SpriteWidth = width;
        SpriteHeight = height;
        return this;
    }
	
	IGUIElementOpt@ ForceCallbackMouseClick( int click )
    {
        MouseClickCallback.OnMouseClick( click );
        return this;
    }

    IGUIElementOpt@ AutoCursor( int cursor )
    {
        autoCursor = true;
        setCursor = cursor;
        return this;
    }

    IGUIElementOpt@ SetFocus( bool set )
    {
        IgnoreFocus = set;
        return this;
    }

    IGUIElementOpt@ InputTrigger()
    {
        LastInput = __FullSecond;
        return this;
    }

    IGUIElementOpt@ OnlyDigits( bool set )
    {
        DigitsOnly = true;
        return this;
    }

    IGUIElementOpt@ Flags( int flags )
    {
        TextFlags = flags;
        return this;
    }


    IGUIElementOpt@ Push( bool push )
    {
        MousePressed[ MOUSE_CLICK_LEFT ] = push;
        return this;
    }

    IGUIElementOpt@ SBReversed( bool set )
    {
        sbReversed = set;
        return this;
    }

    IGUIElementOpt@ ClickSound( string@ sound )
    {
        SoundClick = sound;
        return this;
    }

    IGUIElementOpt@ Clickable( bool click )
    {
        clickable = click;
        return this;
    }

    IGUIElementOpt@ Scale( bool toScale )
    {
        scale = toScale;
        return this;
    }

    IGUIElementOpt@ SetGroupIndex( uint index )
    {
        GroupIndex = index;
        return @this;
    }

    IGUIElementOpt@ SetNoFocusedKeyPress( bool isF )
    {
        NoFocusedKeyPress = isF;
        return @this;
    }

    void KeepCursor( int cursor )
    {
        lastCursor = cursor;
    }

    // Info
    int  GetPosX()  { return PosX; }
    int  GetPosY()  { return PosY; }
    bool IsHidden() 
	{
		if( @HideChecker !is null )
			return HideChecker.IsElementHide( this );
		return isHidden; 
	}
		
    int  GetTextScroll()
    {
        if( int( scrollText.length() ) - maxTextLines > 0 )
            return int( scrollText.length() ) - maxTextLines;
        else
            return 0;
    }
	
	::string@ InputBlockLetters; 
	uint[]@ InputBlockKeys;
	uint	InputCarriageTick;
	uint8	InputCarriage;
	
	IGUIElementOpt@ BlockInput( ::string@ blockLetters, uint[]@ blockKeys )
	{
		@InputBlockLetters = @blockLetters;
		@InputBlockKeys = @blockKeys;
		return @this;
	}
	
    int GetListElement() { return lbIndex; }

    string GetListElementStr() { if( scrollText.length() != 0 && lbIndex >= 0 && uint( lbIndex ) < scrollText.length() ) return scrollText[ lbIndex ]; else return ""; }

    int GetTextOffset() { return textOffset; }

    uint    GetSBScrollValue() { return sbCurrentValue; }
    string@ GetText()
    {
        if( !isScrollableText )
            return @text;
        else if( scrollText.length() != 0 )
            return join( scrollText, "\n" );
		else return @"";
    }
    uint GetElementsNumber() { return scrollText.length(); }

    uint GetSpriteId( bool down )
    {
		iVisual@ visual = down ? @DownSpr : @Surface;
		Sprite@ spr = cast<Sprite@>(@visual);
		if( spr is null ) return 0;
		return spr.Id;
    }

    bool IsAutoCursor() { return autoCursor; }

	IGUIElementOpt@ SetName( const ::string& name  ){ Name = name; return @this; }
	string@ GetName( ){ return Name; }
    // Data
    string						Name;
    bool                           isAutoCursor;
    bool                           autoCursor;
    int                            lastCursor;
    int                            setCursor;
    bool                           isScrollableText;
    bool                           isScrollBar;
    string@[] 					scrollText;
    int                            textOffset;
    int8                           fontHeight;
    int                            maxTextLines;
    int                            PosX;
    int                            PosY;
    int                            Width;
    int                            Height;
    uint16                         SpriteWidth;
    uint16                         SpriteHeight;
    int                            scrX;
    int                            scrY;
    int                            mouseX;
    int                            mouseY;
    iVisual@[] 						MultiSprite;
    uint16                         MultiSpriteDX;
    uint16                         MultiSpriteDY;
    int16                          MultiSpriteFrameDX;
    int16                          MultiSpriteFrameDY;
    uint16                         MultiWidth;
    uint16                         MultiHeight;
    string[] 						multiText;
    uint16                         MultiTextDX;
    uint16                         MultiTextDY;
    int16                          MultiTextStartDx;
    int16                          MultiTextStartDy;
    uint                           MultiColor;
    uint8                          MultiSpriteCountOfLine;
    uint8                          MultiTextCountOfLine;
    int                            MultiTextFont;
    uint                           MultiTextColor;
    int                            MultiTextFlag;
    iVisual@                        Surface;
    iVisual@                         DownSpr;

    iVisual@                         Scroll;
    uint                           sbRange;
    float                          sbStep;
    uint                           sbCurrentValue;
    bool                           sbInitialized;
    bool                           sbReversed;

    int8                           txtFrameX;
    int8                           txtFrameY;

    uint                           GroupIndex;
    bool                           isListBox;
    bool                           listBoxFocused;
    int                            lbIndex;
    int                            DefaultPath;
    string                         text;
    int                            font;
    uint                           TextColor;
    uint                           TextColorFocused;
    uint                           TextColorDown;
    uint[]@ TextMultiColor;
    int                            TextFlags;
    bool                           IsTextInput;
    bool                           IgnoreFocus;
    bool                           DigitsOnly;
    uint                           InputMaxLen;
    uint                           LastInput;
    bool                           IsFocused;
    bool                           NoFocusedKeyPress;
    bool[] 						   MousePressed;
    bool                           SwitchEnabled;
	bool							Jamming;
	bool							IsJamming;
    bool                           isHidden;
    bool                           clickable;
    bool                           scale;
	
	bool							NoCollision;
	
    string                         SoundClick;
	
	int 							ScreenIndex;
	
	Listing@						RefListing;
	
    IGUI::ElementCallbackInit@       				InitCallback;
    IGUI::ElementCallbackDraw@       				DrawCallback;
    IGUI::ElementCallbackDrawPos@    			DrawPosCallback;
    IGUI::ElementCallbackMouseClick@ 			MouseClickCallback;
    IGUI::ElementCallbackKeyPress@   			KeyPressCallback;
    IGUI::ElementCallbackMouseDown@  			MouseDownCallback;
    IGUI::ElementCallbackMouseDrop@  			MouseDropCallback;
    IGUI::ElementCallbackMouseMove@  			MouseMoveCallback;
	IGUI::ElementCallbackCallbackListActive@ ListActiveCallback;
	IGUI::ElementHideChecker@ HideChecker;
	IGUIElementOpt@ ListingOption( IGUI::ListingElementOpt@ opt )
	{
		if( @RefListing !is null )
			RefListing.SetOption( @opt );
		return @this;	
	}
	
    IGUIElementOpt@ ListingColor( uint color, uint focus, uint down )
	{
		if( @RefListing !is null )
			RefListing.SetColor( color, focus, down );
		return @this;
	}
	
	IGUIElementOpt@ SetListingShift( int shift ){ return @SetListingShift( false, shift ); }
	IGUIElementOpt@ SetListingShift( bool absolute, int shift )
	{
		if( @RefListing !is null )
			RefListing.SetShift( absolute, shift );
		return @this;
	}
	
	
	uint get_ListingShift( )
	{
		if( @RefListing !is null )
			return RefListing.Shift;
		return 0;
	}
	
	IGUIElementOpt@ ListingOffset( int offset )
	{
		if( @RefListing !is null )
			RefListing.Offset = offset;
		return @this;
	}
	
	IGUIElementOpt@ ListingMouseChecked( bool checked )
	{
		if( @RefListing !is null )
			RefListing.MouseChecked = checked;
		return @this;
	}
	
	IGUIElementOpt@ ListingStep( uint step )
	{
		if( @RefListing !is null )
			RefListing.ShiftStep = step;
		return @this;
	}
	
    IGUIElementOpt@ ListingDad( IGUIDragAndDropOpt@ dadOpt )
	{
		if( @RefListing !is null )
			@RefListing.DadOption = dadOpt;
		return @this;
	}
	
    IGUIElementOpt@ Listing( IGUIListingElement@[]@ list )
    {
		if( @RefListing is null )
			@RefListing = @Listing( list, Width, Height, ScreenIndex );
		else 
			RefListing = list;
        return @this;
    }
	
	IGUIElementOpt@ SetNoCollision( bool coll )
	{
		NoCollision = coll;
		return @this;
	}
}

class GUIScreen : IGUIScreenOpt
{
    GUIScreen( string@ sprName, int path )
    {
		@Surface = @Sprite( );
		SetPicture( sprName, path );
        Index = 0;

        IsCanMove = true;
        IsModal = true;
        IsMultiinstance = false;
        IsIgnoreBorders = false;
        IsCloseOnMiss = false;
        IsAutoCursor = false;
		NoCollision = false;

        AutoCursorType = CURSOR_DEFAULT;
        AutoCursorPrev = CURSOR_DEFAULT;

        IsHardcoded = false;
		IsHidden = false;
		
		PositionCenter( );
        LastX = 0;
        LastY = 0;
        SpriteWidth = 0;
        SpriteHeight = 0;
        @ShowCallback = null;
        @HideCallback = null;
        @MoveCallback = null;
    }

	bool IsCollision( int x, int y, bool ignoreNoColl = false )
	{
		return ( IS_COLLISION( x, y, PosX, PosY, Surface.Width, Surface.Height ) || ( !ignoreNoColl && NoCollision ) );
	}

	bool IsCollisionElement( int x, int y, uint index )
	{
		return IsCollisionElement( x, y, Elements[ index ] );
	}

	bool IsCollisionElement( int x, int y, GUIElement@ e )
	{
		if( e.NoCollision )
			return false;
		uint        w = e.Width > 0 ? e.Width : e.Surface.Width,
					 h = e.Height > 0 ? e.Height : e.Surface.Height;
		return ( IS_COLLISION( x, y, PosX + e.PosX, PosY + e.PosY, w, h ) );
	}
	
    void Draw()
    {
        if( @Surface !is null )
        {
            if( SpriteWidth == 0 || SpriteHeight == 0 )
                Surface.Draw( PosX, PosY );
            else
				Surface.Draw( PosX, PosY, SpriteWidth, SpriteHeight );
        }
        for( uint i = 0, j = Elements.length(); i < j; i++ )
            Elements[ i ].Draw( PosX, PosY );
    }

    bool MouseDown( int click, int x, int y )
    {
        for( uint i = 0, j = Elements.length(); i < j; i++ )
            Elements[ i ].IsFocused = false;
        for( uint i = Elements.length(); i > 0;)
        {
			GUIElement@ e = @Elements[ --i ];
            if( IsCollisionElement( x, y, @e ) && e.MouseDown( click ) && !e.IsHidden() )
            {
                e.IsFocused = true;
                return true;
            }
        }

        if( !IsHardcoded && click == MOUSE_CLICK_LEFT )
        {
            if( IsCollision( x, y, true ) )
            {
                @MouseMoveScreen = @this;
                LastX = x;
                LastY = y;
                return true;
            }
            else if( IsCloseOnMiss )
            {
                HideScreen( 0, 0, 0, 0 );
                return true;
            }
        }
        return false;
    }

    bool MouseUp( int click, int x, int y )
    {
		// MouseMoveScreen
		if( @MouseMoveScreen is @this )
			@ MouseMoveScreen = null;
			
		bool result = false;
        for( uint i = Elements.length(); i > 0;)
        {
            GUIElement@ e = Elements[ --i ];
            if( IsCollisionElement( x, y, @e ) && !e.IsHidden() )
            {
                e.MouseUp( click, true );
                result = true;
            }
            else
            {
                e.MouseUp( click, false );
            }
        }
        return result;
    }

    void MouseMove( int x, int y )
    {
        if( IsCanMove && @MouseMoveScreen is @this )
        {
            int lastPosX = PosX;
            int lastPosY = PosY;
            int offsX = x - LastX;
            int offsY = y - LastY;
            LastX = x;
            LastY = y;
            PosX += offsX;
            PosY += offsY;

            // Check screen borders
            if( !IsIgnoreBorders )
            {
                int px = PosX;
                int py = PosY;
                if( PosX < 0 )
                    PosX = 0;
                if( PosY < 0 )
                    PosY = 0;
                if( PosX + Surface.Width > __ScreenWidth )
                    PosX = __ScreenWidth - Surface.Width;
                if( PosY + Surface.Height > __ScreenHeight )
                    PosY = __ScreenHeight - Surface.Height;
                LastX += PosX - px;
                LastY += PosY - py;
            }
            if( @MoveCallback !is null && ( lastPosX != PosX || lastPosY != PosY ) )
                MoveCallback.OnMove( PosX, PosY );
        }

        for( uint i = 0, j = Elements.length(); i < j; i++ )
            Elements[ i ].MouseMove( x, y );
    }

    bool KeyPress( uint8 key )
    {
        for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            GUIElement@ e = Elements[ i ];
            if( ( ( e.IsFocused || e.IgnoreFocus ) && ( e.IsTextInput || @e.KeyPressCallback !is null ) ) || e.NoFocusedKeyPress )
                return e.KeyPress( key );
        }
        return false;
    }

    void InputLost()
    {
        for( uint i = 0, j = Elements.length(); i < j; i++ )
            Elements[ i ].InputLost();
    }
	
    GUIScreen@ GetNewInstance()
    {
        GUIScreen               screen = this;
        IGUI::ScreenCallbackShow@ newCallback = ShowCallback;
        for( uint i = 0, j = Elements.length(); i < j; i++ )
            @screen.Elements[ i ] = Elements[ i ].GetNewInstance();
        return @screen;
    }

    // Options
    IGUIScreenOpt@ CallbackShow( IGUI::ScreenCallbackShow@ callback ) { @ShowCallback = callback;
                                                                      return this; }
    IGUIScreenOpt@ CallbackHide( IGUI::ScreenCallbackHide@ callback ) { @HideCallback = callback;
                                                                      return this; }
    IGUIScreenOpt@ CallbackMove( IGUI::ScreenCallbackMove@ callback ) { @MoveCallback = callback;
                                                                      return this; }
    IGUIScreenOpt@ Position( int x, int y ) 
	{
		PosX = x;
        PosY = y;
        return this; 
	}

	IGUIScreenOpt@ PositionCenter( )
	{
		return Position( __ScreenWidth / 2 - Surface.Width / 2, __ScreenHeight / 2 - Surface.Height / 2 );
	}
	
    IGUIScreenOpt@ CanMove( bool enabled ) { IsCanMove = enabled;
                                             return this; }
    IGUIScreenOpt@ Modal( bool enabled ) { IsModal = enabled;
                                           return this; }
    IGUIScreenOpt@ Multiinstance( bool enabled ) { IsMultiinstance = enabled;
                                                   return this; }
    IGUIScreenOpt@ IgnoreBorders( bool enabled ) { IsIgnoreBorders = enabled;
                                                   return this; }
    IGUIScreenOpt@ CloseOnMiss( bool enabled ) { IsCloseOnMiss = enabled;
                                                 return this; }
    IGUIScreenOpt@ AutoCursor( bool enabled, int cursorType ) { IsAutoCursor = enabled;
                                                                AutoCursorType = cursorType;
                                                                return this; }
	
	IGUIScreenOpt@ SetPicture( string@ sprName ) 
	{
		return this.SetPicture( sprName, PT_ART_INTRFACE ); 
	}
	
	IGUIScreenOpt@ SetPicture( string@ sprName, int path ) 
	{
        if( @sprName != null )
		{
			Sprite@ spr = null;
			if( @Surface is null ) 
			{
				@spr = Sprite();
				@Surface = @spr;
			}
			else @spr = cast<Sprite@>(@Surface);
            if( @spr !is null ) spr.Load( sprName, path );
		}
		return this; 
	}

	IGUIScreenOpt@ SetNoCollision( bool coll )
	{
		NoCollision = coll;
		return @this;
	}
	
    void AllGroupElementChangePos( uint index, int x, int y )
    {
        if( index != 0 )
        {
            for( uint i = 0, j = Elements.length(); i < j; i++ )
            {
                GUIElement@ e = Elements[ i ];
                if( valid( e ) && e.GroupIndex == index )
                {
                    e.PosX += x;
                    e.PosY += y;
                }
            }
        }
    }

    // Info
    int GetPosX() { return PosX; }
    int GetPosY() { return PosY; }
	IGUIElementOpt@[]@ GetElements()
    {
		IGUIElementOpt@[] result;
		result.resize(Elements.length());
		for(uint i=0,j=Elements.length();i<j;i++) @result[i]=Elements[i];
		return result;
	}
	
	IGUIElementOpt@ get_ElementOpt( const string name ) override
    {
		for( uint i = 0, iEnd = Elements.length(); i < iEnd; i++ )
			if( Elements[i].Name == name )
				return @Elements[i];
		return null;
	}
	
	
    IGUIScreenOpt@ ToHide( bool hide )
    {
        IsHidden = hide;
        return this;
    }

    // Data
    int                     Index;
    int                     PosX;
    int                     PosY;
    int                     Width;
    int                     Height;
    uint16                  SpriteWidth;
    uint16                  SpriteHeight;
    int                     LastX;
    int                     LastY;
    iVisual@              Surface;

    bool                    IsCanMove;
    bool                    IsModal;
    bool                    IsMultiinstance;
    bool                    IsIgnoreBorders;
    bool                    IsCloseOnMiss;
	
	bool					 RealAutoCursor;
	bool					 IsHidden;
	bool					 NoCollision;
	
    bool                    IsAutoCursor
	{
		get
		{
			return RealAutoCursor && !IsHidden;
		}
		
		set
		{
			RealAutoCursor = value;
		}
	}

    int                     AutoCursorType;
    int                     AutoCursorPrev;

    bool                    IsHardcoded;
    bool                    IsLMouseDown;

    IGUI::ScreenCallbackShow@ ShowCallback;
    IGUI::ScreenCallbackHide@ HideCallback;
    IGUI::ScreenCallbackMove@ MoveCallback;
    GUIElement@[] Elements;
}

class GUIInformer : IGUIInformerOpt
{
	GUIInformer( ::string& name )
	{
		prv_Name = name;
		prv_Delay = -1;
	}

    IGUIInformerOpt@ AddDescriptor( IGUIDescriptor@ descriptor )
	{
		return @this;
	}
	
    IGUIInformerOpt@ SetDealy( uint delay )
	{
		prv_Delay = delay;
		return @this;
	}
	
    IGUIInformerOpt@ SetPosition( int x, int y )
	{
		prv_PosX = x;
		prv_PosY = y;
		return @this;
	}
	
    IGUIInformerOpt@ SetMouse( )
	{
		SetPosition( ::__MouseX, ::__MouseY );
		return @this;
	}
	
    ::string@ get_Name( )
	{
		return @prv_Name;
	}
	
	private int prv_PosX;
	private int prv_PosY;
	
	private int prv_Delay;
	private ::string prv_Name;
}

IGUIInformerOpt@ GUI_CreateInformer( ::string@ name )
{
	return @GUIInformer( name );
}

//
// API
//

// Create new screen
IGUIScreenOpt@ GUI_CreateScreen( int screenIndex, string@ sprName )
{
    if( screenIndex == 0 )
        return null;
    DeleteScreen( screenIndex );
    return CreateScreen( screenIndex, sprName );
}

// Delete old screen, hardcoded screens included
void GUI_DeleteScreen( int screenIndex )
{
    if( screenIndex == 0 )
        return;
    DeleteScreen( screenIndex );
}

// Add element on screen
IGUIElementOpt@ GUI_AddScreenElement( int screenIndex, string@ sprName, int x, int y )
{
    if( screenIndex == 0 )
        return null;
    GUIScreen@ screen = GetScreen( screenIndex );
    if( @screen is null )
        @screen = CreateScreen( screenIndex, null );

    GUIElement element( sprName, PT_ART_INTRFACE, screenIndex );
    element.Position( x, y );

    screen.Elements.insertLast( @element );
    return @element;
}

IGUIElementOpt@ GUI_AddScreenElement( int screenIndex, string@ sprName, int[]& position )
{
	return GUI_AddScreenElement( screenIndex, @sprName )
				.Position( position );
}

IGUIElementOpt@ GUI_AddScreenElement( int screenIndex, string@ sprName )
{
	return GUI_AddScreenElement( screenIndex, @sprName, 0, 0 );
}

IGUIElementOpt@ GUI_AddScreenElementBySprite( int screenIndex, Sprite@ spr, int x, int y )
{
    if( screenIndex == 0 )
        return null;
    if( @GetScreen( screenIndex ) is null )
        CreateScreen( screenIndex, null );

    GUIScreen@ screen = GetScreen( screenIndex );
    GUIElement element( @spr, screenIndex );
    element.Position( x, y );

    screen.Elements.insertLast( @element );
    return @element;
}

// Screen options
IGUIScreenOpt@ GUI_GetScreenOptions( int screenIndex )
{
    return @GetScreen( screenIndex );
}

// Screen options
IGUIScreenOpt@ GUI_GetActiveScreenOptions( int screenIndex, int ignore )
{
    // ActiveScreens //Index
    IGUIScreenOpt@ LastOpt = null;
    for( uint i = 0, iEnd = ActiveScreens.length(); i < iEnd; i++ )
    {
        if( valid( ActiveScreens[ i ] ) && ActiveScreens[ i ].Index == screenIndex )
        {
            @ LastOpt = ActiveScreens[ i ];
            if( ignore-- == 0 )
                break;
        }
    }
    return LastOpt;
}

// Valid only on IGUI::ScreenCallbackShow::OnShow callback
IGUIScreenOpt@ GUI_GetScreenOptions()
{
    return LastScreenOpt;
}

// Valid only on IGUI::ElementCallbackInit::OnInit callback
IGUIElementOpt@ GUI_GetElementOptions()
{
    return LastElementOpt;
}

//
// Engine callbacks
//

void GUI_Init()
{
	HiddensCursor.resize( 0 );
    AllScreens.resize( 0 );
    ActiveScreens.resize( 0 );
			
    // Register hardcoded screens
    CreateScreen( CLIENT_MAIN_SCREEN_LOGIN, null );
    CreateScreen( CLIENT_MAIN_SCREEN_REGISTRATION, null );
    //CreateScreen( CLIENT_MAIN_SCREEN_OPTIONS, null );
    //CreateScreen( CLIENT_MAIN_SCREEN_CREDITS, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GAME, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GLOBAL_MAP, null );
    CreateScreen( CLIENT_MAIN_SCREEN_WAIT, null );
    //CreateScreen( CLIENT_SCREEN_INVENTORY, null );
    CreateScreen( CLIENT_SCREEN_PICKUP, null );
    CreateScreen( CLIENT_SCREEN_MINIMAP, null );
    CreateScreen( CLIENT_SCREEN_CHARACTER, null );
    //CreateScreen( CLIENT_SCREEN_DIALOG, null );
    CreateScreen( CLIENT_SCREEN_BARTER, null );
    CreateScreen( CLIENT_SCREEN_PIP_BOY, null );
    //CreateScreen( CLIENT_SCREEN_FIX_BOY, null );
    CreateScreen( CLIENT_SCREEN_MENU, null );
    //CreateScreen( CLIENT_SCREEN_AIM, null );
    //CreateScreen( CLIENT_SCREEN_TEST, null );
    CreateScreen( CLIENT_SCREEN_SPLIT, null );
    CreateScreen( CLIENT_SCREEN_TIMER, null );
    CreateScreen( CLIENT_SCREEN_DIALOGBOX, null );
    CreateScreen( CLIENT_SCREEN_ELEVATOR, null );
    CreateScreen( CLIENT_SCREEN_SAY, null );
    CreateScreen( CLIENT_SCREEN_CHA_NAME, null );
    CreateScreen( CLIENT_SCREEN_CHA_AGE, null );
    CreateScreen( CLIENT_SCREEN_CHA_SEX, null );
    CreateScreen( CLIENT_SCREEN_GM_TOWN, null );
    CreateScreen( CLIENT_SCREEN_INPUT_BOX, null );
    CreateScreen( CLIENT_SCREEN_SKILLBOX, null );
    CreateScreen( CLIENT_SCREEN_USE, null );
    CreateScreen( CLIENT_SCREEN_PERK, null );
    CreateScreen( CLIENT_SCREEN_TOWN_VIEW, null );
    //CreateScreen( CLIENT_SCREEN_SAVE_LOAD, null );
    for( uint i = 0, iMax = AllScreens.length(); i < iMax; i++ )
        AllScreens[ i ].IsHardcoded = true;    
}

int GUI_GetMouseScreenIndex( )
{
	return GUI_GetMonitorScreenIndex( __MouseX, __MouseY );
}

int GUI_GetMonitorScreenIndex( int x, int y )
{
    for( uint i = ActiveScreens.length(); i-- > 0; )
    {
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.IsCollision( x, y ) )
            return screen.Index;
    }
	return CLIENT_SCREEN_NONE;
}

int GUI_GetActiveMainScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.first().Index : CLIENT_SCREEN_NONE;
}

int GUI_GetActiveScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.last().Index : CLIENT_SCREEN_NONE;
}

void GUI_GetActiveScreens( int[]& result )
{
    result.resize( ActiveScreens.length() );
    for( uint i = 0, iMax = result.length(); i < iMax; i++ )
        result[ i ] = ActiveScreens[ i ].Index;
}

bool GUI_IsScreenActive( int screen )
{
    for( uint n = 0; n < ActiveScreens.length(); n++ )
    {
        if( ActiveScreens[ n ].Index == screen )
            return true;
    }
    return false;
}

void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 )
{
    GUIScreen@ screen = GetScreen( screenIndex );
    if( @screen !is null )
    {
        if( !screen.IsMultiinstance )
        {
            // Close all another instances
            for( uint i = ActiveScreens.length(); i > 0;)       // From end
            {
                i--;
                if( ActiveScreens[ i ].Index == screenIndex )
                {
                    ActiveScreens.removeAt( i );
                    if( @screen.HideCallback !is null )
                        screen.HideCallback.OnHide( p0, p1, p2 );
                }
            }
        }

        // Create new instance
        @screen = screen.GetNewInstance();
        ActiveScreens.insertLast( @screen );

        // Set screen cursor
        if( screen.IsAutoCursor )
        {
            screen.AutoCursorPrev = GetCurrentCursor();
            ChangeCursor( screen.AutoCursorType );
        }

        // Call init callbacks
        @LastScreenOpt = screen;
        // First init elements
        for( uint i = 0, iMax = screen.Elements.length(); i < iMax; i++ )
        {
            GUIElement@ e = screen.Elements[ i ];
            if( @e.InitCallback !is null )
            {
                @LastElementOpt = e;
                e.InitCallback.OnInit();
                @LastElementOpt = null;
            }
        }
        // Then show
        if( @screen.ShowCallback !is null )
        {
            screen.ShowCallback.OnShow( p0, p1, p2 );
        }
        @LastScreenOpt = null;
    }
}

void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 )
{
    for( uint i = ActiveScreens.length(); i > 0;) // From end
    {
        i--;
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.Index == screenIndex )
        {
            // Remove
            ActiveScreens.removeAt( i );

            // Hide callback
            if( @screen.HideCallback !is null )
            {
                screen.HideCallback.OnHide( p0, p1, p2 );
            }

            // Restore cursor
            if( screen.IsAutoCursor )
            {
                ::ChangeCursor( screen.AutoCursorPrev );
            }

            // Store position for non-multiinstance screens
            if( !screen.IsMultiinstance )
            {
                GUIScreen@ instance = GetScreen( screenIndex );
                instance.PosX = screen.PosX;
                instance.PosY = screen.PosY;
            }
            break;
        }
    }
}

void GUI_Render( bool mainScreen )
{
    if( mainScreen )
    {
        if( ActiveScreens.length() > 0 )
        {
            GUIScreen@ screen = ActiveScreens[ 0 ];
            DrawHardcodedScreen( screen.Index );
            GetHardcodedScreenPos( screen.Index, screen.PosX, screen.PosY );
            screen.Draw();
        }
    }
    else
    {
        for( uint i = 1, j = ActiveScreens.length(); i < j; i++ )
        {
            GUIScreen@ screen = ActiveScreens[ i ];
			if( !screen.IsHidden )
			{
				if( screen.IsHardcoded )
				{
					DrawHardcodedScreen( screen.Index );
					GetHardcodedScreenPos( screen.Index, screen.PosX, screen.PosY );
				}
				screen.Draw();
			}
        }
		
		if( @CurrentDAD !is null )
			CurrentDAD.Draw( __MouseX, __MouseY );
    }
}

GUIElement@ GetFocusElement( )
{
	GUIScreen@ screen = GetFocusScreen( );
	if( screen !is null )
	{
		const uint len = screen.Elements.length();
		for( uint i = 0; i < len; i++ )
		{
			if( screen.IsCollisionElement( __MouseX, __MouseY, i ) && !screen.Elements[i].IsHidden() )
				return screen.Elements[i];
		}
	}
	return null;
}

IGUIElementOpt@ GUI_GetFocusElement( )
{
	return GetFocusElement( );
}

GUIScreen@ GetFocusScreen( )
{
	uint len = ActiveScreens.length();
    if( len != 0 )
	{
		GUIScreen@ tmpScreen = ActiveScreens[ len - 1 ];
		if( tmpScreen.IsCollision( __MouseX, __MouseY ) )
			return tmpScreen;
		for( uint i = ActiveScreens.length() - 1; i > 0;)     // From end
		{
			GUIScreen@ nextScreen = ActiveScreens[ --i ];
			if( nextScreen.IsCollision( __MouseX, __MouseY ) )
			{
				// Swap screens
				@tmpScreen = ActiveScreens[ i ];
				@ActiveScreens[ i ] = ActiveScreens[ len - 1 ];
				@ActiveScreens[ len - 1 ] = tmpScreen;
				return tmpScreen;
			}
		}
	}
	return null;
}

IGUIScreenOpt@ GUI_GetFocusScreen( )
{
	return GetFocusScreen( );
}

bool GUI_MouseDown( int click, int x, int y )
{
	if( @MouseMoveScreen !is null )
		return true;
		
    uint len = ActiveScreens.length();
    if( len != 0 )
    {
        GUIScreen@ screen = ActiveScreens[ len - 1 ];
        bool       result = screen.MouseDown( click, x, y );
        if( result )
        {
            if( click == MOUSE_CLICK_WHEEL_UP || click == MOUSE_CLICK_WHEEL_DOWN )
                return GUI_MouseUp( click, x, y );
            return true;
        }

        if( len > 1 && !screen.IsHardcoded && !screen.IsModal && click == MOUSE_CLICK_LEFT && !screen.IsCollision( x, y ) )
        {
            for( uint i = ActiveScreens.length() - 1; i > 0;)     // From end
            {
                GUIScreen@ nextScreen = ActiveScreens[ --i ];
                if( nextScreen.IsCollision( x, y ) )
                {
                    // Swap screens
                    GUIScreen@ tmpScreen = ActiveScreens[ i ];
                    @ActiveScreens[ i ] = ActiveScreens[ len - 1 ];
                    @ActiveScreens[ len - 1 ] = tmpScreen;
                    return GUI_MouseDown( click, x, y );                 // Click new screen
                }
            }
        }
    }
    return false;
}

bool GUI_MouseUp( int click, int x, int y )
{
	if( @MouseMoveScreen !is null )
	{
		MouseMoveScreen.MouseUp( click, x, y );
		return true;
	}
	
	bool result = false;
    uint len = ActiveScreens.length();
    if( len != 0 )
        result = ActiveScreens[ len - 1 ].MouseUp( click, x, y );
    if( click == MOUSE_CLICK_LEFT && @CurrentDAD !is null )
		@CurrentDAD = null;
	return result;
}

void GUI_MouseMove( int x, int y )
{
	if( @MouseMoveScreen !is null )
		MouseMoveScreen.MouseMove( x, y );
	else
	{
		uint len = ActiveScreens.length();
		if( len != 0 )
			ActiveScreens[ len - 1 ].MouseMove( x, y );
	}
}

bool GUI_KeyDown( uint8 key )
{
	InputElement@ k = InputSpace.Keyboard.Elements[ key ];
	if( @k !is null )
	{
		k.Pressed = true;
		k.Jamming = !k.Jamming;
	}
	
    uint len = ActiveScreens.length();
    if( len != 0 )
        return ActiveScreens[ len - 1 ].KeyPress( key );
    return false;
}

bool GUI_KeyUp( uint8 key )
{
	InputElement@ k = InputSpace.Keyboard.Elements[ key ];
	if( @k !is null )
		k.Pressed = false;
    return false;
}


const bool get_CtrlPressed(  )
{
	return KeyPressed[ DIK_LCONTROL ] || KeyPressed[ DIK_RCONTROL ];
}

const bool get_ShiftPressed(  )
{
	return KeyPressed[ DIK_LSHIFT ] || KeyPressed[ DIK_RSHIFT ];
}

const bool get_KeyPressed( uint index )
{
	InputElement@ k = InputSpace.Keyboard.Elements[ index ];
	if( @k !is null )
		return k.Pressed;
	return false;
}

const bool get_KeyJamming( uint index )
{
	InputElement@ k = InputSpace.Keyboard.Elements[ index ];
	if( @k !is null )
		return k.Jamming;
	return false;
}

void GUI_InputLost()
{
	@MouseMoveScreen = null;
	@CurrentDAD = null;
	InputSpace.Lose();
    uint len = ActiveScreens.length();
    if( len != 0 )
        ActiveScreens[ len - 1 ].InputLost();
}

//
// Internal
//

GUIScreen@ CreateScreen( int screenIndex, string@ sprName )
{
    GUIScreen screen( sprName, PT_ART_INTRFACE );
    screen.CanMove( true );
    screen.Position( __ScreenWidth / 2 - screen.Surface.Width / 2, __ScreenHeight / 2 - screen.Surface.Height / 2 );
    screen.Index = screenIndex;
    AllScreens.insertLast( @screen );
    return @screen;
}

void DeleteScreen( int screenIndex )
{
    for( uint i = 0; i < ActiveScreens.length();)
    {
        if( ActiveScreens[ i ].Index == screenIndex )
        {
            ActiveScreens.removeAt( i );
            i = 0;
        }
        else
        {
            i++;
        }
    }

    for( uint i = 0, j = AllScreens.length(); i < j; i++ )
    {
        if( AllScreens[ i ].Index == screenIndex )
        {
            AllScreens.removeAt( i );
            break;
        }
    }
}

IGUIDragAndDropElement@ RealCurrentDAD = null;
HideCursorDAD HideCursorDADPattern;

class HideCursorDAD : IGUIHiddenCursorInfo
{

}

IGUIDragAndDropElement@ CurrentDAD
{
	get
	{
		return @RealCurrentDAD;
	}
	
	set
	{
		if( @RealCurrentDAD !is @value )
		{
			if( @RealCurrentDAD !is null )
				RealCurrentDAD.Drop();
			
			if( ( @value !is null && value.Drag( ) ) || @value is null )
				@ RealCurrentDAD = @value;
		}
		
		if( @RealCurrentDAD !is null )
			GUI_HideCursor( @HideCursorDADPattern );
		else
			GUI_FreeCursor( @HideCursorDADPattern );
	}
}

void GUI_SetDragAndDrop( IGUIDragAndDropElement@ dad )
{
	@CurrentDAD = @dad;
}

IGUIDragAndDropElement@ GUI_GetDragAndDrop( )
{
	return @CurrentDAD;
}

GUIScreen@ GetScreen( int screenIndex )
{
    if( screenIndex == 0 )
        return null;
    for( uint i = 0, iMax = AllScreens.length(); i < iMax; i++ )
        if( AllScreens[ i ].Index == screenIndex )
            return @AllScreens[ i ];
    return null;
}

bool ProcessKey( uint8 key, string& text, uint8& letter )
{
    if( InputSpace.Keyboard.Elements.length() == 0 )
        return false;

    if( key == DIK_BACK )
    {
        if( text.length() > 0 )
            text.resize( text.length() - 1 );
        return true;
    }

    InputElement@ k = InputSpace.Keyboard.Elements[ key ];
    if( @k !is null )
    {
		string addtxt = k.Letter[ ::GetKeybLang() * 2 + ( ShiftPressed ? 1 : 0 ) ];
        if( addtxt.length() > 0 )
		{
			const uint len = text.length();
			text += addtxt;
			letter = text[ len ];
			return true;
		}
    }
    return false;
}

void SwitchPicture( IGUIElementOpt@ elementOpt, Sprite@ newSpr )
{	
	GUIElement@ element = cast<GUIElement>(@elementOpt);
	if(  @element != null )
		element.Picture( @newSpr );
}

void GUI_HideCursor( IGUIHiddenCursorInfo@ info )
{
	for( uint i = 0, iEnd = HiddensCursor.length(); i < iEnd; i++ )
		if( @HiddensCursor[i] == @info )
			return;
	
	HiddensCursor.insertLast( @info );
	__HideCursor = true;
}

const bool GUI_FreeCursor( IGUIHiddenCursorInfo@ info )
{
	for( uint i = 0, iEnd = HiddensCursor.length(); i < iEnd; i++ )
	{
		if( @HiddensCursor[i] == @info )
		{
			HiddensCursor.removeAt( i );
			::__HideCursor = ( HiddensCursor.length() != 0 );
			return true;
		}
	}
	return false;
}

bool get_MouseDown( uint index )
{
	return InputSpace.Mouse.Elements[index].Pressed;
}

void set_MouseDown( uint index, bool value )
{
	InputSpace.Mouse.Elements[index].Pressed = value;
}

