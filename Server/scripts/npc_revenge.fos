// Author: rifleman17
// Скрипт для НПЦ-жителей города, не защищенных баунтихантерами
// Периодически, после того, как местные слишком часто умирали, НПЦ будут собираться вместе и принимать решение атаковать всех посетителей города.
// у НПЦ занимается Var9 под хранение числа простоев.

#include "_macros.fos"
#include "serializator.fos"

#define MODE_NORMAL        (0) // Обычный режим
#define MODE_LEADER_CALLS  (1) // Лидер призывает игроков
#define MODE_MEETING       (2) // Идет митинг
#define MODE_HOSTILE       (3) // Враждебный режим, все нпц атакуют любых игроков

#define _AnyDataKey #(mapId)("RevengeMapInfo_"+mapId)

#define MAX_LEADER_CALLS   (4) // Максимальное число призывов лидера
#define MAX_DEADS_BASE     (1) // Максимальное число убитых нпц по умолчанию
#define LEADER_RADIUS      (10) // Радиус области возле лидера. куда пойдут нпц

#define PLANE_MOVE2LEADER  (24) // План на перемещение к лидеру в момент MODE_LEADER_CALLS
#define PLANE_WAITMEETING  (25) // План на ожидание завершения лекции
#define CTE_CHECK_GAG      (26) // Идентификатор события поиска преград при движении.
#define DL #(s) (Log("npc_revenge: " + s))
//#define DL #(s)

import bool AddMiscPlane(Critter& npc, uint priority, uint waitSecond, string@ funcName) from "npc_planes";
import bool AddWalkPlane(Critter& npc, uint priority, int identifier, uint identifierExt, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut) from "npc_planes";
import bool GetFreeHex(Map& map, uint radius, uint16& hx, uint16& hy) from "caravan";
import bool AddAttackPlane(Critter& npc, uint priority, uint critId) from "npc_planes";

bool Map2Revenge(Map& map,  uint leaderRole, uint textMsg, uint strCall, uint strCallAns, uint strFirst, uint strLast, uint strAns, uint strKill, uint strEnter)
{
	RevengeMapInfo rm=RevengeMapInfo(map.Id, leaderRole, textMsg, strCall, strCallAns, strFirst, strLast, strAns, strKill, strEnter);
	if(valid(rm))
	{
		rm.Save();
		return true;
	}
	return false;
}

RevengeMapInfo@ RevengeFromMap(Map@ map)
{
	if (!valid(map))
		return null;
	RevengeMapInfo@ rm=RevengeMapInfo(map);
	if(valid(rm) && rm.Exists())
	{
		rm.Load();
		return rm;
	}
	return null;
}

int GetRevengeMode(Map& map)
{
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if (!valid(rm))
		return -1;
	return rm.MapMode;
}

class RevengeMapInfo
{
	uint MapId;            // Карта, на которой происходят все события
	uint DeadNpcToRevenge; // Максимальное число убитых на карте НПЦ, после которого местные становястя агрессивны по отношению к игроку.
	uint DeadsCounter;     // Текущее число убитых на карте НПЦ.
	uint MapMode;          // Режимы карты: обычный, идет сбор нпц вокруг лидера, идет митинг, враждебный
	uint LeaderRole;       // Номер роли нпц-лидера, который призывает всех местных жителей.
	// Текстовые реплики
	uint TextMsg;          // Номер текстового файла, в котором лежат реплики лидера.
	uint StrCall;          // Номер строки, в которой лидер призывает местных.
	uint StrCallAnswer;    // Ответы НПЦ на призывы лидера.
	uint LeaderCalls;      // Счетчик призывов лидера.
	uint LastActionTime;   // Время последнего действия, совершенного лидером, например, произнесенной фразы
	
	uint StrMeetingFirst;  // Первая фраза из монолога лидера во время митинга
	uint StrMeetingLast;   // Последняя фраза из монолога лидера во время митинга
	uint StrMeetingCur;    // Текущая активная фраза из монолога лидера
	uint StrMeetingAnswer; // Строка ответа НПЦ на реплики лидера во время митинга
	
	uint StrHostileKill;   // Строка, которую произносит НПЦ, убивший игрока во враждебном режиме.
	uint StrHostileEnter;  // Строка, которую произносят НПЦ при входе игрока в локацию
	
	RevengeMapInfo(Map& map)
	{
		this.MapId=map.Id;
	}
	
	RevengeMapInfo(uint mapId, uint leaderRole, uint textMsg, uint strCall, uint strCallAns, uint strFirst, uint strLast, uint strAns, uint strKill, uint strEnter)
	{
		this.MapId=mapId;
		this.DeadNpcToRevenge=MAX_DEADS_BASE;
		this.DeadsCounter=0;
		this.MapMode=MODE_NORMAL;
		this.LeaderRole=leaderRole;
		this.TextMsg=textMsg;
		this.TextMsg=textMsg;
		this.StrCall=strCall;
		this.StrCallAnswer=strCallAns;
		this.LeaderCalls=0;
		this.StrMeetingFirst=strFirst;
		this.StrMeetingLast=strLast;
		this.StrMeetingCur=0;
		this.StrMeetingAnswer=strAns;
		this.StrHostileKill=strKill;
		this.StrHostileEnter=strEnter;
	}
	
	void SetMode(uint mode)
	{
		switch(mode)
		{
			case MODE_NORMAL:
				if(this.MapMode !=MODE_NORMAL)
					this.DeadNpcToRevenge +=10;
				break;
			case MODE_LEADER_CALLS:
				this.LeaderCalls=0;
				this.LastActionTime=0;
				break;
			case MODE_MEETING:
				this.LastActionTime=0;
				this.StrMeetingCur=0;
				break;
			case MODE_HOSTILE:
				this.LastActionTime=__FullSecond; // Используем для последующих проверок, все ли НПЦ добрались домой
				break;
			default:
				break;
		}
		this.MapMode=mode;
		this.Save();
		this.SetEvents();
	}
	
	void SetEvents()
	{
		Map@ map=GetMap(this.MapId);
		if (!valid(map)) 
			return;
		map.SetEvent(MAP_EVENT_CRITTER_DEAD, "_MapCritterDead");
		switch(this.MapMode)
		{
			case MODE_NORMAL:
				map.SetEvent(MAP_EVENT_IN_CRITTER, "");
				break;
			case MODE_LEADER_CALLS:
				map.SetEvent(MAP_EVENT_LOOP_0 , "_MapLoop0_LeaderCalls");
				map.SetLoopTime(0, 15000);  // Раз в 15 секунд
				break;
			case MODE_MEETING:
				map.SetEvent(MAP_EVENT_LOOP_0 , "_MapLoop0_Meeting");
				map.SetLoopTime(0, 10000); // Раз в 10 секунд
				break;
			case MODE_HOSTILE:
				CancelPlanes(map);
				map.SetEvent(MAP_EVENT_LOOP_0 , "_MapLoop0_CheckGag");
				map.SetLoopTime(0, 60000); // Раз в 60 секунд
				map.SetEvent(MAP_EVENT_IN_CRITTER, "_MapInCritter");
				break;
			default:
				break;
		}
	}
	void CancelPlanes(Map& map)
	{
		DL("cancel called");
		Critter@[] critters;
		Critter@ cr;
		map.GetCritters(0, FIND_ALL|FIND_ONLY_NPC, critters);
		for(uint i=0, iMax=critters.length(); i<iMax; i++)
		{
			@cr=critters[i];
			if(valid(cr))
			{
				NpcPlane@[] planes;
				cr.GetPlanes(AI_PLANE_WALK,planes);
				uint erased=0;
				for(uint j=0, jMax=planes.length(); j<jMax; j++)
				{
					if(planes[j].Identifier==PLANE_MOVE2LEADER)
					{
						 if(cr.ErasePlane(j-erased)) 
							erased++;
					}
				}
			}
		}
	}
	// Serializator
	void Save()
	{
		Serializator save;
		save.Set(this.MapId);
		save.Set(this.DeadNpcToRevenge);
		save.Set(this.DeadsCounter);
		save.Set(this.MapMode);
		save.Set(this.LeaderRole);
		save.Set(this.TextMsg);
		save.Set(this.StrCall);
		save.Set(this.StrCallAnswer);
		save.Set(this.LeaderCalls);
		save.Set(this.LastActionTime);
		save.Set(this.StrMeetingFirst);
		save.Set(this.StrMeetingLast);
		save.Set(this.StrMeetingCur);
		save.Set(this.StrMeetingAnswer);
		save.Set(this.StrHostileKill);
		save.Set(this.StrHostileEnter);
		save.Save(_AnyDataKey(this.MapId));
	}
	
	void Load()
	{
		Serializator load;
		if (!load.Load(_AnyDataKey(this.MapId)))
			return;
		load.Get(this.MapId);
		load.Get(this.DeadNpcToRevenge);
		load.Get(this.DeadsCounter);
		load.Get(this.MapMode);
		load.Get(this.LeaderRole);
		load.Get(this.TextMsg);
		load.Get(this.StrCall);
		load.Get(this.StrCallAnswer);
		load.Get(this.LeaderCalls);
		load.Get(this.LastActionTime);
		load.Get(this.StrMeetingFirst);
		load.Get(this.StrMeetingLast);
		load.Get(this.StrMeetingCur);
		load.Get(this.StrMeetingAnswer);
		load.Get(this.StrHostileKill);
		load.Get(this.StrHostileEnter);
	}

	bool Exists()
	{
		string key=_AnyDataKey(this.MapId);
		return IsAnyData(key);
	}
	
	void Erase()
	{
		string key=_AnyDataKey(this.MapId);
		if(IsAnyData(key))
			EraseAnyData(key);
		Map@ map=GetMap(this.MapId);
		if (!valid(map))
			return;
		map.SetEvent(MAP_EVENT_LOOP_0 , "");
		map.SetEvent(MAP_EVENT_IN_CRITTER, "");
		map.SetScript("");
	}
}
// События различных стадий
void _MapInCritter(Map& map, Critter& cr)
{
	if(cr.IsPlayer())
	{
		uint minDist=50000;
		int idx=-1;
		uint dist=0;
		RevengeMapInfo@ rm=RevengeFromMap(map);
		if (!valid(rm) || rm.MapMode !=MODE_HOSTILE)
			return;
		Critter@[] critters;
		map.GetCritters(0, FIND_LIFE|FIND_ONLY_NPC, critters);
		Critter@ npc;
		for(uint i=0, iMax=critters.length(); i<iMax; i++)
		{
			@npc=critters[i];
			if(valid(npc) && IsLocalNpc(npc, map))
			{
				npc.ModeBase[MODE_NO_SUPPLY]=1;
				AddAttackPlane(npc, 0, cr.Id);
				dist=GetCrittersDistantion(cr,npc);
				if(dist<minDist)
				{
					minDist=dist;
					idx=i;
				}
			}
		}
		if(idx > 0)
		{
			@npc=critters[idx];
			if(valid(npc))
			{
				DL("npc talk");
				npc.SayMsg(SAY_NORM, rm.TextMsg, rm.StrHostileEnter); 
			}
		}
	}
}

// Если нпц загородили друг другу проход
void _MapLoop0_CheckGag(Map& map)
{	
	DL("Checking gag");
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if ((rm.LastActionTime + __TimeMultiplier * 60*3)<__FullSecond) // 3 минуты. Проверок будет 4 шт
		map.SetEvent(MAP_EVENT_LOOP_0 , "");
	Critter@[] critters;
	Critter@ cr;
	map.GetCritters(0, FIND_LIFE|FIND_ONLY_NPC, critters);
	for(uint i=0, iMax=critters.length(); i<iMax; i++)
	{
		@cr=critters[i];
		if(valid(cr) && IsLocalNpc(cr, map) && !cr.IsNoPlanes())
		{
			DL("try find");
			if(CritterGagHome(cr, map) && cr.GetTimeEvents(CTE_CHECK_GAG, null, null, null)==0)
			{
				DL("Found gagging npc. Id: " + cr.Id);
				// Нпц имеет только один план, идти на домашнюю позицию
				// проход не найден
				// еще не задано событие проверки нужно ли смещение
				// сохраняем текущие координаты в Var9
				cr.StatBase[ST_VAR9]==int(cr.HexX * cr.HexY);
				cr.AddTimeEvent("cte_CheckGag", 15 * __TimeMultiplier, CTE_CHECK_GAG);
			}
		}
	}
}
  
uint cte_CheckGag(Critter& cr, int identifier, uint& stage)
{
	DL("Checking gag");
	Map@ map=cr.GetMap();
	if(valid(map) && CritterGagHome(cr, map))
	{
		if(cr.HexX * cr.HexY==uint(cr.Stat[ST_VAR9]))
		{
			DL("Gag: Move Random");
			cr.MoveRandom();
		}
	}	
	cr.StatBase[ST_VAR9]=0;
	return 0;
}

// Предположение: криттер застрял на дороге домой
bool CritterGagHome(Critter& cr, Map& map)
{
	uint16 hx=0;
	uint16 hy=0;
	uint8 dir=0;
	uint mapId=0;
	NpcPlane@[] planes;
	cr.GetHomePos(mapId, hx, hy, dir);
	
	if(cr.GetPlanes(planes)==1 && valid(planes[0]) && planes[0].Type==AI_PLANE_WALK	&& planes[0].Walk_HexX==hx 
		&& planes[0].Walk_HexY==hy && planes[0].Walk_Dir==dir && map.GetPathLength(cr.HexX, cr.HexY, hx, hy, 0)==0)
	{
		return true;
	}
	DL("no gag!");
	return false;
}

void _MapLoop0_Meeting(Map& map)
{
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if(rm.LastActionTime > 0 && __FullSecond<(rm.LastActionTime + 10 * __TimeMultiplier))
		return; // Иногда MAP_LOOP происходит чаще, чем указано в SetLoopTime. Эта проверка, чтобы НПЦ не частил.
	if (!valid(rm))
		return;	
	if(map.GetNpcCount(rm.LeaderRole, FIND_LIFE|FIND_ONLY_NPC) > 0 && (rm.StrMeetingFirst + rm.StrMeetingCur)<rm.StrMeetingLast)
	{
		Critter@ leader=map.GetNpc(rm.LeaderRole, FIND_LIFE|FIND_ONLY_NPC, 0);
		if(valid(leader))
		{
			leader.SayMsg(SAY_SHOUT, rm.TextMsg, rm.StrMeetingFirst + rm.StrMeetingCur);
			rm.StrMeetingCur ++;
			rm.Save();
			uint[] values={map.Id, leader.HexX, leader.HexY};
			CreateTimeEvent(__FullSecond + __TimeMultiplier * 10, "e_MeetingAnswer", values, false);
			return;
		}
	}
	// Лидер не найден, сразу переходим к стадии атаки
	map.SetEvent(MAP_EVENT_LOOP_0 , ""); // Сначала сброс, затем новое присвоение уже в rm.SetMode
	rm.SetMode(MODE_HOSTILE);
}

uint e_MeetingAnswer(uint[]@ values)
{
	uint mapId=values[0];
	uint hx=values[1];
	uint hy=values[2];
	Critter@[] npc;
	Map@ map=GetMap(mapId);
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if(valid(map) && valid(rm) && rm.MapMode==MODE_MEETING && map.GetCrittersHex(hx, hy, LEADER_RADIUS, FIND_LIFE|FIND_ONLY_NPC, npc) > 0 && valid(rm))
	{
		uint i=Random(0, npc.length() - 1);
		Critter@ cr=npc[i];
		if(valid(cr) && IsLocalNpc(cr, map) && uint(cr.Stat[ST_NPC_ROLE]) !=rm.LeaderRole)
			cr.SayMsg(SAY_NORM, rm.TextMsg, rm.StrMeetingAnswer);
	}
	return 0;
}
void _MapLoop0_LeaderCalls(Map& map)
{
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if (!valid(rm))
		return;	
	if(rm.LastActionTime > 0 && __FullSecond<(rm.LastActionTime + 15 * __TimeMultiplier))
		return; // Иногда MAP_LOOP происходит чаще, чем указано в SetLoopTime. Эта проверка, чтобы НПЦ не частил.
	rm.LastActionTime=__FullSecond;
	if(map.GetNpcCount(rm.LeaderRole, FIND_LIFE|FIND_ONLY_NPC) > 0)
	{			
		Critter@ leader=map.GetNpc(rm.LeaderRole, FIND_LIFE|FIND_ONLY_NPC, 0);
		if(valid(leader) && rm.LeaderCalls<MAX_LEADER_CALLS)
		{
			rm.LeaderCalls++;
			rm.Save();
			leader.SayMsg(SAY_SHOUT, rm.TextMsg, rm.StrCall); // Лидер кричит созывающую фразу			
			Critter@[] npc;
			Critter@ cr;
			for(uint i=0, iMax=map.GetCritters(0, FIND_LIFE|FIND_ONLY_NPC, npc); i<iMax; i++)
			{
				@cr=npc[i];
				if(valid(cr) && IsLocalNpc(cr, map) && cr.IsNoPlanes() && uint(cr.Stat[ST_NPC_ROLE]) !=rm.LeaderRole)
				{
					if(cr.Stat[BT_BRAHMIN] !=BT_RAT && cr.Stat[BT_BRAHMIN] !=BT_DOG && cr.Stat[BT_BRAHMIN] !=BT_CHILDREN && cr.Stat[ST_BODY_TYPE] !=BT_CHILDREN && Random(0, 5)==0) // Детей из реплик исключаем
						cr.SayMsg(SAY_NORM, rm.TextMsg, rm.StrCallAnswer); // Относительная частота произнесения
					uint16 hx=leader.HexX;
					uint16 hy=leader.HexY;
					if(GetFreeHex(map, LEADER_RADIUS, hx, hy))
					{
						if(AddWalkPlane(cr, 0, PLANE_MOVE2LEADER, 0, hx, hy, GetDirection(hx, hy, leader.HexX, leader.HexY), ((Random(1,3)==1)?true:false), Random(0, 1)))
						{
							AddMiscPlane(cr, 0, 0, "npc_revenge@plane_WaitMeeting");
							cr.StatBase[ST_VAR9]=0;
						}
					}
				}
			}
			return;					
		}
		else
		{
			map.SetEvent(MAP_EVENT_LOOP_0 , ""); // Сначала сброс, затем новое присвоение уже в rm.SetMode
			rm.SetMode(MODE_MEETING);
			return;
		}
	}
	// Лидер не найден, сразу переходим к стадии атаки
	map.SetEvent(MAP_EVENT_LOOP_0 , ""); // Сначала сброс, затем новое присвоение уже в rm.SetMode
	rm.SetMode(MODE_HOSTILE);
}

void plane_WaitMeeting(Critter& cr)
{
	if(cr.Stat[ST_VAR9] > 100)
		return; // Слишком долго ждали, значит, что-то пошло не так
	cr.StatBase[ST_VAR9]++;
	Map@ map=cr.GetMap();
	if (!valid(map))
		return;
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if (!valid(rm))
		return;
	if(rm.MapMode==MODE_LEADER_CALLS || rm.MapMode==MODE_MEETING) // Продолжаются призывы к сбору от лидера, либо идет митинг
		AddMiscPlane(cr, 0, __FullSecond + __TimeMultiplier * 10, "npc_revenge@plane_WaitMeeting");
}

void _RevengeMapInit(Map& map, bool firstTime)
{
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if (!valid(rm))
		return;
	rm.SetEvents();	
}



// Признак, это местный НПЦ
bool IsLocalNpc(Critter@ cr, Map@ map)
{
	if (!valid(cr) || cr.IsPlayer() || !valid(map))
		return false;
	uint mapId=0;
	uint16 hx=0, hy=0;
	uint8 dir=0;
	cr.GetHomePos(mapId, hx, hy, dir);
	return (mapId==map.Id);
}

// Признак, все нпц на карте враждебны
bool IsHostileMap(Map@ map)
{
	if (!valid(map))
		return false;
	RevengeMapInfo@ rm=RevengeFromMap(map);
	return valid(rm) && rm.MapMode==MODE_HOSTILE;
}

void _MapCritterDead(Map& map, Critter& cr, Critter@ killer)
{
	DL("smbdy dead");
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if (!valid(rm))
		return;		
	if(IsLocalNpc(cr, map) && valid(killer) && killer.IsPlayer())
	{
		rm.DeadsCounter++;
	}
	if(cr.IsPlayer() && IsLocalNpc(killer, map))
	{
		rm.DeadsCounter--;
		if(rm.MapMode==MODE_HOSTILE)
			killer.SayMsg(SAY_NORM, rm.TextMsg, rm.StrHostileKill, "$pname" + GetPlayerName(cr.Id));
	}
	rm.Save();
	if(rm.DeadsCounter==0 && rm.MapMode==MODE_HOSTILE)
		rm.SetMode(MODE_NORMAL);
	if(rm.DeadsCounter==rm.DeadNpcToRevenge && rm.MapMode==MODE_NORMAL)		
		rm.SetMode(MODE_LEADER_CALLS);
}

// debug
void Revenge(Critter& cr, int role, int, int)
{
	Map@ map=cr.GetMap();
	if(valid(RevengeFromMap(map)))
	{
		cr.Say(SAY_NETMSG, "revenge already set");
		return;
	}
	Map2Revenge(map, role, TEXTMSG_TEXT, 7200, 7201, 7202, 7207, 7208, 7209, 7210);
	map.SetScript("_RevengeMapInit");
	RevengeMapInfo@ rm=RevengeFromMap(map);
		rm.SetEvents();
}

void Erase(Critter& cr, int role, int, int)
{
	Map@ map=cr.GetMap();
	RevengeMapInfo@ rm=RevengeFromMap(map);
	if (!valid(rm))
	{
		cr.Say(SAY_NETMSG, "revenge not set");
		return;
	}
	rm.Erase();
	map.SetScript("");
}