// Author: Tab10id
// #define __DEBUG__
#include "_macros.fos"
#include "roulette_game_list_h.fos"
#include "roulette_h.fos"

// ToDo
// 1. Использование функции Say About для ввода координат ставок.
// 2. Ставки на 2 поля.
// 3. Использование SayAbout для ввода размера ставки.
// 4. Отображение в диалоге количества игровой валюты, если эта валюта не является монетами.
// 5. Восклицания игрока в случае крупного выигрыша и низком навыке игры.
// 6. Реализация жульничества связанного с подкупом крупье.
// 7. Сохранение данный в массиве AnyData по аналогии со скриптом покера.
// 8. Запрет на повторение ставки на то же поле.
// 9. Всплывающие фразы над крупье во время игры.

#define GAMEVAR_COUNT            ( 1 ) // ToDo
#define ANSWER_COUNT_PER_PAGE    ( 5 )
#define NAV_BACK                 ( 0 )
#define NAV_NEXT                 ( 1 )


uint NumOfNpc = 0;             // При инициализации нового криттера с установленным скриптом рулетки эта переменная будет инкриментированна
uint[][] GameAnyData;          // Массив хранящий статус игры (текущие ставки, номера страниц в диалоге и прочее), создается на случай остановки сервера, или необходимости игрока отойти от компьютера во время игры (закрытие диалога не приведет к потере денег)
uint[][] AnyDataTemp;          // Временный массив
uint8[] CurBetType;            // Текущий тип ставки (на число, на 2, на 3, на 4, на 6, на 12 (линии, дюжины), черное/красное, четное/нечетное, большое/малое)
// bool[] InGame; // true если игра идет
uint8[] DialogAnswerPageIndex; // номер страницы во время выбора координад для ставки
uint8[] DialogAnswerNum;       // Количество реплик определенного типа, прошедших проверку. Создано для реализации навигации в диалоге ([назад] и [далее])

CBet@[][] Bets;                // Массив ставок (включая размер)


// Следующие переменные расчитывается для каждого нпц с прикрепленным скриптом рулетки на основе значения NpcRole
uint[] MinBet;         // Значения минимальной ставки
uint[] MaxBet;         // Значения максимальной ставки
uint[] Bet1;           // Первый вариант ставки для диалога
uint[] Bet2;           // Второй вариант ставки для диалога
uint[] Bet3;           // Третий вариант ставки для диалога
uint[] Bet4;           // Четвертый вариант ставки для диалога
uint[] AllBetSize;     // Общая сумма ставок игрока
uint16[] OnCheat1;     // Реакция на жульничество типа 1
uint16[] OnCheat2;     // Реакция на жульничество типа 2
uint16[] OnCheat3;     // Реакция на жульничество типа 3
uint8[] CLevel;        // уровень наблюдательности крупье (от 1 до 10)
uint[] StopGameMoney;  // Сумма после которой крупье перестает играть с игроком
uint16[] WaitForGame;  // Время, которое крупье не будет играть с игроком
uint16[] GameCurrency; // Валюта игры (PID итема)

void _RouletteInit( Critter& croupier, bool firstTime )
{
    AddElements();
    croupier.StatBase[ CROUPIER_NUM ] = NumOfNpc++;                                                     // Приписываем крупье уникальный идентификатор
    DialogAnswerNum[ croupier.StatBase[ CROUPIER_NUM ] ] = 0;                                           // обнуляем старые данные
    if( IsAnyData( "Roulette_" + croupier.Id ) )                                                        // Проверяем наличие данных о текущей игре в сэйве сервера
    {
        if( GetAnyData( "Roulette_" + croupier.Id, AnyDataTemp[ croupier.StatBase[ CROUPIER_NUM ] ] ) ) // Загружаем из сэйва данные о текущей игре игрока
        {
            for( uint8 i = 0; i < GAMEVAR_COUNT; i++ )
            {
                GameAnyData[ croupier.StatBase[ CROUPIER_NUM ] ][ i ] = AnyDataTemp[ croupier.StatBase[ CROUPIER_NUM ] ][ i ];
            }
            // GetAData(croupier);//DEBUG
            // InGame[croupier.StatBase[CROUPIER_NUM]]=true;
        }
    }
    LoadSettings( croupier.Stat[ ST_NPC_ROLE ], croupier ); // Загружаем в переменные данные, соответствующие данному нпц
    // croupier.SetEvent(CRITTER_EVENT_FINISH,"_SaveAD");//DEBUG
}


void AddElements()
{
    Bets.grow( 1 );
    CurBetType.grow( 1 );
    DialogAnswerPageIndex.grow( 1 );
    DialogAnswerNum.grow( 1 );
    AnyDataTemp.grow( 1 );
    GameAnyData.grow( 1 );
    // InGame.grow(1);
    MinBet.grow( 1 );
    MaxBet.grow( 1 );
    Bet1.grow( 1 );
    Bet2.grow( 1 );
    Bet3.grow( 1 );
    Bet4.grow( 1 );
    AllBetSize.grow( 1 );
    OnCheat1.grow( 1 );
    OnCheat2.grow( 1 );
    OnCheat3.grow( 1 );
    CLevel.grow( 1 );
    StopGameMoney.grow( 1 );
    WaitForGame.grow( 1 );
    GameCurrency.grow( 1 );
}

void dlg_MakeBet( Critter& master, Critter@ croupier, string@ str )      // Ветка выбора координат ставки
{
    int coord = 0;
    if( IS_DIALOG_SAY_MODE( str ) )                                      // Если игрок воспользовался функцией Say About
    {
        master.Say( SAY_APPEND, "\n" );
        if( ( not SafeStrToInt( str, coord ) ) and ( str != "00" ) )     // Проверяем данные на соответствие игровым полям
        {
            master.SayMsg( SAY_APPEND, TEXTMSG_DLG, STR_INVALID_COORD ); // Если не соответствуют, то выдаем сообщение об ошибке
        }
        else
        {
            if( str == "00" )
            {
                master.SayMsg( SAY_DIALOG, TEXTMSG_DLG, STR_COORD_OPERATION_SUCCESS );             // Есди игрок ввел "00", то выводим сообщение об успешной операции
            }
            else
            {
                if( ( coord < 0 ) or ( coord > 36 ) )
                {
                    master.SayMsg( SAY_APPEND, TEXTMSG_DLG, STR_INVALID_COORD );                 // Есди число лежит не в промежутке, от нуля, до 36, значит игрок ввел неверное значение координаты
                }
                else
                {
                    master.SayMsg( SAY_DIALOG, TEXTMSG_DLG, STR_COORD_OPERATION_SUCCESS );                 // Есди число лежит в промежутке, от нуля, до 36, значит игрок ввел верное значение координаты
                }
            }
        }
    }
    else
    {
        if( valid( str ) )                                           // Вызыв функции произошел в момент формирования диалога
        {
            str = "$makebet" + "@msg dlg " + STR_SET_BET_TYPE + "@"; // ToDo спрашиваем на что будем ставить (в дальнейшем будет доработка)
        }
    }
}

void dlg_CheckWinNumber( Critter& master, Critter@ croupier, string@ str )            // Формирование диалога с выпадение шарика.
{
    uint num;                                                                         // число на который вападет шарик
    uint winCash;                                                                     // Сумма выигрыша
    if( not IS_DIALOG_GENERATED( str ) )
        return;
    num = GetNumber();                                                                // Получаем выигрышный номер
    winCash = CheckWinCash( croupier, num );                                          // получаем сумму выигрыша
    if( winCash > 0 )                                                                 // Если выигрыш больше 0
    {
        master.AddItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ], winCash ); // Выдаем игроку его выигрыш (в игровой валюте)
    }
    str += "$winnumber" + GetNumberStr( num ) + winCash;                              // Выдаем в диалог информацию о сумме выигрыша
    EndGame( croupier );                                                              // Завершаем текущую игру
}

void dlg_SetBetSize( Critter& master, Critter@ croupier, string@ str )                // Установка размера ставки
{
    uint mBet;                                                                        // Максимальный размер ставки, возможный у данного нпц, на данный момент, при этом типе ставки
    if( !IS_DIALOG_SAY_MODE( str ) )
    {
        mBet = GetMaxBetForBetType( croupier, croupier.StatBase[ BET_TYPE ] );
        // ToDo необходимо сделать проверку на непривышение максимального размера общей суммы ставок

        // Формируем реплики
        str += "$minbet" + MinBet[ croupier.StatBase[ CROUPIER_NUM ] ];
        str += "$betone" + Bet1[ croupier.StatBase[ CROUPIER_NUM ] ];
        str += "$bettwo" + Bet2[ croupier.StatBase[ CROUPIER_NUM ] ];
        str += "$betthree" + Bet3[ croupier.StatBase[ CROUPIER_NUM ] ];
        str += "$betfour" + Bet4[ croupier.StatBase[ CROUPIER_NUM ] ];
        str += "$maxbet" + mBet;
        str += "$allmoney" + master.CountItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ] );
    }
}

bool d_MaxBet( Critter& master, Critter@ croupier ) // Проверка достаточно ли у игрока денег, чтобы сделать максимальную ставку.
{
    uint maxBet = GetMaxBetForBetType( croupier, croupier.StatBase[ BET_TYPE ] );

    // ToDo необходимо сделать проверку на непривышение максимального размера общей суммы ставок

    if( master.CountItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ] ) > maxBet )
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool d_IsSpecBet( Critter& master, Critter@ croupier, int betType, int betNum )                                                                                                                                                                                                                                                                  // Показывать ли варианты координат для ставки
{
    if( int( CurBetType[ croupier.StatBase[ CROUPIER_NUM ] ] ) == betType )                                                                                                                                                                                                                                                                             // Если текущий тип ставки совпадает с типом реплики
    {
/*		if(uint(betNum)>DialogAnswerNum[croupier.StatBase[CROUPIER_NUM]]) // ToDo воспользоваться новой функцией диалогэдитора.
                {
                        DialogAnswerNum[croupier.StatBase[CROUPIER_NUM]]=uint(betNum);
                }*/
        DialogAnswerNum[ croupier.StatBase[ CROUPIER_NUM ] ]++;                                                                                                                                                                                                                                                                                  // Считаем количество ответов, прошедших проверку
        if( ( DialogAnswerNum[ croupier.StatBase[ CROUPIER_NUM ] ] < ( DialogAnswerPageIndex[ croupier.StatBase[ CROUPIER_NUM ] ] * ANSWER_COUNT_PER_PAGE + 1 ) ) or ( DialogAnswerNum[ croupier.StatBase[ CROUPIER_NUM ] ] - ( DialogAnswerPageIndex[ croupier.StatBase[ CROUPIER_NUM ] ] * ANSWER_COUNT_PER_PAGE ) > ANSWER_COUNT_PER_PAGE ) ) // если реплика находится на выбранной в диалоге странице.
        {
            return false;
        }
        else
        {
            return true;
        }
    }
    else
    {
        return false;
    }
}

bool d_IsNavigationNeeded( Critter& master, Critter@croupier, int nav )                                                                                         // Нужна ли навигация
{
    if( nav == NAV_BACK )                                                                                                                                       // Есди проверка на навигационную панель для возвращения
    {
        if( DialogAnswerPageIndex[ croupier.StatBase[ CROUPIER_NUM ] ] > 0 )                                                                                    // если текущая страница не первая
        {
            return true;                                                                                                                                        // показывает навигационную реплику [назад]
        }
        else                                                                                                                                                    // страница первая
        {
            return false;                                                                                                                                       // не показывает навигационную реплику [назад]
        }
    }
    else                                                                                                                                                        // Есди проверка на навигационную панель для перехода на следующую страницу
    {
        if( DialogAnswerNum[ croupier.StatBase[ CROUPIER_NUM ] ] > ( DialogAnswerPageIndex[ croupier.StatBase[ CROUPIER_NUM ] ] + 1 ) * ANSWER_COUNT_PER_PAGE ) // если находимся не на последней странице
        {
            return true;                                                                                                                                        // показывает навигационную реплику [далее]
        }
        else                                                                                                                                                    // страница последняя
        {
            return false;                                                                                                                                       // не показывает навигационную реплику [далее]
        }
    }
}

bool d_NoBets( Critter& master, Critter@ croupier, int val )      // Делал ли игрок ставки
{
    bool res;
    if( Bets[ croupier.StatBase[ CROUPIER_NUM ] ].length() == 0 ) // Есди игрок не делал ставки
    {
        res = true;
    }
    else
    {
        res = false;
    }
    if( val == BET_SIZE_IS_NULL ) // Есди проверяем, что игрок не делал ставки
    {
        return res;               // выводим res
    }
    else                          // в противном случае
    {
        return !res;              // возвращаем обратное значение res
    }
}

bool d_IsMoneyEnough( Critter& master, Critter@ croupier, int val )                            // Хватает ли денег
{
    uint8 betType;                                                                             // Тип ставки
    uint  outSidebetsSize = 0;                                                                 // Размер внешних ставок (на черное/красное, четное/нечетное, большое/малое, дюжина, колонка)
    uint  inSidebetsSize = 0;                                                                  // Размер внутренних ставок (число, сплит, стрит, квадрат, 6 чисел)
    uint  playerMoney = master.CountItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ] ); // Количество денег игрока
    uint8 len = Bets[ croupier.StatBase[ CROUPIER_NUM ] ].length();                            // Количество ставок
    if( len == 0 )                                                                             // Если игрок еще не ставил
    {
        if( playerMoney >= MinBet[ croupier.StatBase[ CROUPIER_NUM ] ] )                       // Проверяем хватает ли у игрока денег на минимальную ставку
        {
            return true;                                                                       // Денег хватает
        }
        else
        {
            return false;                // Денег не хватает
        }
    }
    else                                 // Если игрок уже сделал одну или несколько ставок, нужно проверить, есть ли какая-нибудь сумма на внутренних ставках, если сумма внутренних ставок + количество денег игрока будет превышать миниимальную ставку, то игрок может играть
    {
        for( uint8 i = 0; i < len; i++ ) // Проходим по всем совершенным ставкам
        {
            betType = Bets[ croupier.StatBase[ CROUPIER_NUM ] ][ i ].BetType;
            switch( betType )
            {
            case SINGLE_NUMBER_BET:
            case SPLIT_BET:
            case STREET_BET:
            case CORNER_BET:
            case SIX_LINE_BET:
                inSidebetsSize += Bets[ croupier.StatBase[ CROUPIER_NUM ] ][ i ].BetSize;                 // Считаем сумму внутренних ставок
                break;
            default:
                outSidebetsSize += Bets[ croupier.StatBase[ CROUPIER_NUM ] ][ i ].BetSize;                // Считаем сумму внешних ставок
                break;
            }
        }
        if( val == INSIDE_BETS )     // Если проверяем внутренние ставки
        {
            if( ( playerMoney + inSidebetsSize ) >= MinBet[ croupier.StatBase[ CROUPIER_NUM ] ] )
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else         // Если проверяем внешние ставки (в дальнейшем, эта часть кода будет изменена)
        {
            if( ( playerMoney + outSidebetsSize ) >= MinBet[ croupier.StatBase[ CROUPIER_NUM ] ] )
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}

bool d_IsMoneyEnoughForBet( Critter& master, Critter@ croupier, int betNum ) // Хватает ли денего на стандартную ставку (betNum хранит номер стандартной ставки)
{
    uint bet;                                                                // Размер стандартной ставки
    uint maxBet;                                                             // Максимальная ставка
    switch( betNum )
    {
    case 1:
        bet = Bet1[ croupier.StatBase[ CROUPIER_NUM ] ];
        break;
    case 2:
        bet = Bet2[ croupier.StatBase[ CROUPIER_NUM ] ];
        break;
    case 3:
        bet = Bet3[ croupier.StatBase[ CROUPIER_NUM ] ];
        break;
    case 4:
        bet = Bet4[ croupier.StatBase[ CROUPIER_NUM ] ];
    }
    maxBet = GetMaxBetForBetType( croupier, croupier.StatBase[ BET_TYPE ] );           // Получаем максимум для ставки указанного типа
    if( bet > maxBet )                                                                 // Если стандартная ставка превышает максимальную для данного типа ставки
    {
        return false;                                                                  // Не показываем данный вариант ставки
    }
    if( master.CountItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ] ) >= bet ) // Если денег хватает, то показываем строку
    {
        return true;
    }
    else
    {
        return false;
    }
}

bool d_AllMoneyBet( Critter& master, Critter@ croupier )                                // Показывать ли вариант "Поставить все деньги"
{
    uint money = master.CountItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ] ); // Получаем количество денег игрока
    if( ( money <= MaxBet[ croupier.StatBase[ CROUPIER_NUM ] ] ) and ( money != 0 ) )   // Если количество денег у игрока меньше максимальной ставки, то показываем строку
    {
        return true;
    }
    else
    {
        return false;
    }
}

void r_NavUse( Critter& master, Critter@ croupier, int nav )          // Использование навигационной реплики ([назад] или [далее])
{
    DialogAnswerNum[ croupier.StatBase[ CROUPIER_NUM ] ] = 0;         // Сбрасываем счетчик ответов прошедших проверку на показ
    if( nav == NAV_BACK )                                             // Если использована строка [назад]
    {
        DialogAnswerPageIndex[ croupier.StatBase[ CROUPIER_NUM ] ]--; // Переключаемся на страницу назад
    }
    else                                                              // Если игрок нажал [далее]
    {
        DialogAnswerPageIndex[ croupier.StatBase[ CROUPIER_NUM ] ]++; // Переходим на страницу вперед
    }
}

void r_SetBet( Critter& master, Critter@ croupier, int betType, int coord ) // Установка типа ставки и ее координат
{
    croupier.StatBase[ BET_TYPE ] = betType;                                // Сохраняем тип ставки
    if( betType == SINGLE_NUMBER_BET )                                      // В случае ставки на число координатой является номер числа
    {
        /*if(croupier.StatBase[BET_COORD1]==0)
           {*/
        croupier.StatBase[ BET_COORD1 ] = coord;
        /*}
           else
           {
                if(croupier.StatBase[BET_COORD2]==0)
                {
                        croupier.StatBase[BET_COORD2]=coord;
                }
                else
                {
                        croupier.StatBase[BET_COORD3]=coord;
                }
           }*/
    }
    else     // Для остальных ставок координата - номер ставки (в дальнейшем функция будет доработана для использования кнопки SayAbout)
    {
        croupier.StatBase[ BET_COORD1 ] = coord;
    }
}

void r_SetBetSize( Critter& master, Critter@ croupier, int betSizeNum )    // Установка размера ставки
{
    uint8  len = Bets[ croupier.StatBase[ CROUPIER_NUM ] ].length();       // Получаем количество сделаных игроком ставок
    uint8  len2;                                                           // Количество выигрышных чисел
    uint8  coord2 = 0, coord3 = 0;                                         // Массив координат ставки
    uint   bCoord;                                                         // вспомогательная переменная, хранит число приводящее к выигрышу
    uint8  cbTemp;                                                         // Вспомогательная переменная, хранит номер ставки на квадрат
    string sCoords = "";                                                   // Строка с указанием чисел на которые была сделана ставка
    uint8[] coords;                                                        // Массив с координатами ставки
    uint   mBet;                                                           // Максимальная ставка для данного типа ставок
    mBet = GetMaxBetForBetType( croupier, croupier.StatBase[ BET_TYPE ] ); // Получаем максимальную ставку для данного типа ставок
    Bets[ croupier.StatBase[ CROUPIER_NUM ] ].resize( len + 1 );           // Увеличиваем на 1 массив ставок игрока
    switch( betSizeNum )                                                   // Проверяем номер размера ставки
    {
    case STANDART_BET_ONE:                                                 // Если выбрана стандартная ставка 1
        croupier.StatBase[ BET_SIZE ] = Bet1[ croupier.StatBase[ CROUPIER_NUM ] ];
        break;
    case STANDART_BET_TWO:                                                 // Если выбрана стандартная ставка 2
        croupier.StatBase[ BET_SIZE ] = Bet2[ croupier.StatBase[ CROUPIER_NUM ] ];
        break;
    case STANDART_BET_THREE:                                               // Если выбрана стандартная ставка 3
        croupier.StatBase[ BET_SIZE ] = Bet3[ croupier.StatBase[ CROUPIER_NUM ] ];
        break;
    case STANDART_BET_FOUR:                                                // Если выбрана стандартная ставка 4
        croupier.StatBase[ BET_SIZE ] = Bet4[ croupier.StatBase[ CROUPIER_NUM ] ];
        break;
    case STANDART_BET_ALL_MONEY:                                           // Если выбрана игра на все деньги
        croupier.StatBase[ BET_SIZE ] = master.CountItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ] );
    case STANDART_BET_MAX:                                                 // Если выбрана максимальная ставка
        croupier.StatBase[ BET_SIZE ] = mBet;
        break;
    default:
        break;
    }
    master.DeleteItem( GameCurrency[ croupier.StatBase[ CROUPIER_NUM ] ], croupier.StatBase[ BET_SIZE ] );                            // Забираем у игрока деньги
    AllBetSize[ croupier.StatBase[ CROUPIER_NUM ] ] += croupier.StatBase[ BET_SIZE ];                                                 // Увеличиваем общую сумму ставок
    @Bets[ croupier.StatBase[ CROUPIER_NUM ] ][ len ] = CBet( croupier.StatBase[ BET_TYPE ], croupier.StatBase[ BET_SIZE ], coords ); // Сохраняем ставку в массиве
    coords.resize( 3 );                                                                                                               // Увеличиваем массив координат с null до 3
    if( croupier.StatBase[ BET_TYPE ] == CORNER_BET )                                                                                 // Высчитываем 2 координаты для ставки на квадрат
    {
        cbTemp = croupier.StatBase[ BET_COORD1 ];
        croupier.StatBase[ BET_COORD1 ] = GetCornerCoord( cbTemp, 1 );                                                                // Получаем первую координату
        coord2 = GetCornerCoord( cbTemp, 2 );                                                                                         // Получаем вторую координату
    }
    coords[ 0 ] = croupier.StatBase[ BET_COORD1 ];                                                                                    // Сохраняем данные в массиве координат
    coords[ 1 ] = coord2;
    coords[ 2 ] = coord3;
    SetCoords( croupier, croupier.StatBase[ BET_TYPE ], coords );                                                                     // Сохраняем координаты ставки
    len2 = Bets[ croupier.StatBase[ CROUPIER_NUM ] ][ len ].BetCoords.length();                                                       // Получаем количество выигрышных чисел для ставки
    for( uint8 i = 0; i < len2; i++ )                                                                                                 // Проходим по всем выигрышным числам
    {
        bCoord = Bets[ croupier.StatBase[ CROUPIER_NUM ] ][ len ].BetCoords[ i ];                                                     // Получаем выигрышное число
        if( bCoord < 37 )
        {
            sCoords += "" + bCoord;                                                                                                   // Формируем строку выигрышных чисел
        }
        else                                                                                                                          // Если число больше 36, значит игрок поставил на зеро или на двойное зеро
        {
            if( bCoord == NUMBER_ZERO )
            {
                sCoords += "@msg dlg " + DLGSTR( DID, STR_ZERO ) + "@";                                                          // подставляем в строку лексему формирующую слово зеро
            }
            else                                                                                                                 // NUMBER_DOUBLE_ZERO
            {
                sCoords += "@msg dlg " + DLGSTR( DID, STR_DOUBLE_ZERO ) + "@";                                                   // подставляем в строку лексему формирующую слова "двойное зеро"
            }
        }
        if( i != len2 - 1 )                                                                                                      // Если мы не дошли до последнего числа
        {
            sCoords += ", ";                                                                                                     // Ставим запятую между числами
        }
    }
    master.SayMsg( SAY_NETMSG, TEXTMSG_DLG, STR_BETS_COORDS_INTRO );                                                             // Выдаем в статусное окно сообщение "Выигрышные числа" на нужном языке
    master.SayMsg( SAY_NETMSG, TEXTMSG_DLG, STR_BETS_COORDS, "$result" + sCoords );                                              // Выдаем в статусное окно выигрышные числа
    master.SayMsg( SAY_NETMSG, TEXTMSG_DLG, STR_CURENT_BET_SIZE, "$betsize" + AllBetSize[ croupier.StatBase[ CROUPIER_NUM ] ] ); // Выдаем в статусное окно сумму всех поставленных денег
}

void r_SetCurBetType( Critter& master, Critter@ croupier, int betType )                                                          // Сохраняем в памяти текущий тип ставки
{
    CurBetType[ croupier.StatBase[ CROUPIER_NUM ] ] = betType;                                                                   // Сохраняем тип ставки
    DialogAnswerPageIndex[ croupier.StatBase[ CROUPIER_NUM ] ] = 0;                                                              // Обнуляем номер страницы координат
    DialogAnswerNum[ croupier.StatBase[ CROUPIER_NUM ] ] = 0;                                                                    // Обнуляем счетчик прошедших проверку реплик ответов игрока
}

void r_StartGame( Critter& master, Critter@ croupier )                                                                           // Начинаем новую игру
{
    EndGame( croupier );                                                                                                         // Для начала игры обнулим все важные переменные, а для этого завершим все предыдущие игры.
}
