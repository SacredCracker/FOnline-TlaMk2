#include "_macros.fos"
#include "_teams.fos"
#include "_bags.fos"
#include "worldmap_h.fos"
#include "_msgstr.fos"

import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";
import void GenerateItems( Map& map, Critter@[] @  grp ) from "encounter_items";
import void GenerateCavernEncounter( Map@ map, Critter@[] @ critters ) from "cave_mobs";
import void initEvents( Map& map, bool firstTime ) from "events_in_encaunter";
import void InitRandomisationItem( Item& item, bool isCrafted, Critter& cr, string sufix ) from "Mk2";

uint[][] PositionDirs =
{
    { 0 },                                     // POSITION_NONE
// Steps Path 1       Path 2
    { 1, 4, 3, 2, 1, 0, 5, 2, 3, 4, 5, 0, 1 }, // POSITION_SURROUNDING
    { 1, 5, 0, 1, 2, 3, 4, 1, 0, 5, 4, 3, 2 }, // POSITION_HUDDLE
    { 1, 4,           2 },                     // POSITION_WEDGE
    { 1, 5,           1 },                     // POSITION_CONE
    { 2, 1, 2,         4, 5 },                 // POSITION_DOUBLE_LINE
    { 2, 1, 2,         4, 5 } // POSITION_STRAIGHT_LINE
};

class CEncounterObject
{
    uint   ObjectType;
    uint16 Pid;                 // Proto id
    uint   DialogId;
    string ScriptName;
    uint   DistanceLength;      // Distance from players
    CEncounterObject@[] Childs; // Items in inventory or container
    CCheck[] Checks;
    // Only for critter
    uint RatioValue;
    bool IsDead;
    // Only for item
    uint Minimum;
    uint Maximum;
    uint InvSlot;
    uint Chance;     // Ўанс(измер€етс€ в тыс€чных, или 0.1%)


    CEncounterObject()
    {
        ObjectType = 0;
        Pid = 0;
        DialogId = 0;
        ScriptName = "";
        DistanceLength = 0;
        RatioValue = 0;
        IsDead = false;
        Minimum = 0;
        Maximum = 0;
        InvSlot = 0;
        Chance = 1000;
    }

    CEncounterObject@ NewCheck( uint type, uint index, uint8 operator, int value )
    {
        Checks.grow( 1 );
        Checks.last().Set( type, index, operator, value );
        return this;
    }

    CEncounterObject@ Dialog( uint dialog ) { DialogId = dialog;
                                              return this; }
    CEncounterObject@ Script( string& script ) { ScriptName = script;
                                                 return this; }
    CEncounterObject@ Distance( uint distance ) { DistanceLength = distance;
                                                  return this; }
    CEncounterObject@ CheckRandom( int value ) { NewCheck( CHECK_RANDOM, 0, 0, value );
                                                 return this; }
    CEncounterObject@ CheckParamLeader( uint index, uint8 operator, int value ) { NewCheck( CHECK_PARAM_LEADER, index, operator, value );
                                                                                  return this; }
    CEncounterObject@ CheckIsPlayer() { NewCheck( CHECK_IS_PLAYER, 0, 0, 0 );
                                        return this; }
    CEncounterObject@ CheckParamAny( uint index, uint8 operator, int value ) { NewCheck( CHECK_PARAM_ANY, index, operator, value );
                                                                               return this; }
    CEncounterObject@ CheckLVar( uint index, uint8 operator, int value ) { NewCheck( CHECK_LVAR, index, operator, value );
                                                                           return this; }
    CEncounterObject@ CheckLVarAny( uint index, uint8 operator, int value ) { NewCheck( CHECK_LVAR_ANY, index, operator, value );
                                                                              return this; }
    CEncounterObject@ CheckParam( uint index, uint8 operator, int value ) { NewCheck( CHECK_PARAM, index, operator, value );
                                                                            return this; }
    CEncounterObject@ CheckGVar( uint index, uint8 operator, int value ) { NewCheck( CHECK_GVAR, index, operator, value );
                                                                           return this; }
    CEncounterObject@ CheckHour( uint8 operator, int value ) { NewCheck( CHECK_HOUR, 0, operator, value );
                                                               return this; }
    CEncounterObject@ Ratio( uint ratio ) { RatioValue = ratio;
                                            return this; }
    CEncounterObject@ Dead( bool dead ) { IsDead = dead;
                                          return this; }
    // CEncounterObject@ Minimum(uint minimum){Minimum=minimum; return this;}
    // CEncounterObject@ Maximum(uint maximum){Maximum=maximum; return this;}
    CEncounterObject@ Slot( uint slot ) { InvSlot = slot;
                                          return this; }

    CEncounterObject@ AddItem( uint16 pid, uint min, uint max, uint slot )
    {
        CEncounterObject new_child;
        Childs.insertLast( @new_child );
        new_child.Pid = pid;
        new_child.Minimum = min;
        new_child.Maximum = max;
        new_child.InvSlot = slot;
        return this;
    }

    CEncounterObject@ AddItem( uint16 pid, uint min, uint max, uint slot, uint chance )
    {
        CEncounterObject new_child;
        Childs.insertLast( @new_child );
        new_child.Pid = pid;
        new_child.Minimum = min;
        new_child.Maximum = max;
        new_child.InvSlot = slot;
        new_child.Chance = chance;
        return this;
    }

}

class CEncounterGroup
{
    uint TeamNum;
    uint Position;
    uint Spacing;
    uint Distance;
    CEncounterObject[] Objects;

    CEncounterGroup()
    {
        TeamNum = 0;
        Position = 0;
        Spacing = 0;
        Distance = 0;
    }

    CEncounterObject@ NewObject()
    {
        Objects.grow( 1 );
        return Objects.last();
    }

    CEncounterObject@ AddCritter( uint16 pid )
    {
        CEncounterObject@ obj = NewObject();
        obj.ObjectType = ENCOUNTER_OBJECT_CRITTER;
        obj.Pid = pid;
        return obj;
    }

    CEncounterObject@ AddItem( uint16 pid )
    {
        CEncounterObject@ obj = NewObject();
        obj.ObjectType = ENCOUNTER_OBJECT_ITEM;
        obj.Pid = pid;
        return obj;
    }
}

class CHidingPlace
{
    uint16 LocPid;
    uint32 Cost;
    uint8  Offset;
    // string ScriptName;

    CHidingPlace()
    {
        LocPid = 0;
        Cost = 8000;
        Offset = 0;
        // ScriptName="";
    }

    CHidingPlace@ LocationPid( uint16 locationPid ) { LocPid = locationPid;
                                                      return this; }
    CHidingPlace@ LocationCost( uint16 cost ) { Cost = cost;
                                                return this; }
    CHidingPlace@ LocationOffset( uint8 offset ) { Offset = offset;
                                                   return this; }
}

/*class CHidingPlaceTable
   {
        CHidingPlace[] HidingPlace;

        CHidingPlace@ AddHidingPlace(uint16 cost)
        {
                HidingPlace.grow(1);
                HidingPlace.last().Cost=cost;
                return @HidingPlace.last();
        }
   }*/

class CEncounterTable
{
    uint16[] LocationPids;
    CEncounter[] Encounters;
    CHidingPlace[] HidingPlace;

    void AddLocationPid( uint16 locationPid )
    {
        LocationPids.insertLast( locationPid );
    }

    CEncounter@ AddEncounter( uint chance, uint strNum )
    {
        Encounters.grow( 1 );
        Encounters.last().Chance = chance;
        Encounters.last().StrNum = strNum;
        return @Encounters.last();
    }

    CHidingPlace@ AddHidingPlace( uint32 cost )
    {
        HidingPlace.grow( 1 );
        HidingPlace.last().Cost = cost;
        return @HidingPlace.last();
    }

    CHidingPlace@ AddHidingPlace( uint32 cost, uint8 offset )
    {
        HidingPlace.grow( 1 );
        HidingPlace.last().Cost = cost;
        HidingPlace.last().Offset = offset;
        return @HidingPlace.last();
    }
}

class CZone
{
    int              Difficulty;
    uint             Terrain;
    uint             MorningChance;
    uint             AfternoonChance;
    uint             NightChance;
    CEncounterTable@ Table;

    CZone()
    {
        Difficulty = 0;
        Terrain = 0;
        MorningChance = 0;
        AfternoonChance = 0;
        NightChance = 0;
        @Table = null;
    }
}

CEncounterGroup[] EncounterGroups( GROUP_MAX );
CEncounterTable[] EncounterTables( TABLE_MAX );
CZone@[]          WorldmapGround( ZONE_COUNT_X* ZONE_COUNT_Y );
CZone@[]          WorldmapWater( ZONE_COUNT_X* ZONE_COUNT_Y );

void FindEncByGroup( Critter& cr, int id, int, int )
{
    for( uint n = 0; n < TABLE_MAX; n++ )
    {
        CEncounterTable@ table = EncounterTables[ n ];
        for( uint e = 0; e < table.Encounters.length(); e++ )
        {
            CEncounter@ enc = table.Encounters[ e ];
            for( uint g = 0; g < enc.Groups.length(); g++ )
            {
                if( enc.Groups[ g ] == uint( id ) )
                {
                    cr.Say( SAY_NETMSG, "table index: " + n + ", enc index: " + e );
                }
            }
        }
    }
}

void CreateEncByIndex( Critter& cr, int tableIndex, int encIndex, int )
{
    CEncounter@        enc = EncounterTables[ tableIndex ].Encounters[ encIndex ];
    CFoundedEncounter@ fe = CreateFoundedEncounter( false, cr.WorldX, cr.WorldY, enc, EncounterTables[ tableIndex ].LocationPids, cr.Id, false );
    Critter@[] group = { cr };
    uint               mapId = 0;
    uint16             hexX = 0, hexY = 0;
    uint8              dir = 0;
    InviteToEncounter( group, null, fe.Index, COMBAT_MODE_REAL_TIME, mapId, hexX, hexY, dir );
    cr.TransitToMap( mapId, hexX, hexY, dir );
}

//
// Zone
//

void SetZone( uint zx, uint zy, uint table, int difficulty, uint terrain, uint morningChance, uint afternoonChance, uint nightChance )
{
    CZone@ zone = CZone();
    @zone.Table = EncounterTables[ table ];
    zone.Difficulty = difficulty;
    zone.Terrain = terrain;
    zone.MorningChance = morningChance;
    zone.AfternoonChance = afternoonChance;
    zone.NightChance = nightChance;

    if( terrain != TERRAIN_Water )
        @WorldmapGround[ zy * ZONE_COUNT_X + zx ] = zone;
    else
        @WorldmapWater[ zy * ZONE_COUNT_X + zx ] = zone;
}

void SetZone( uint zx, uint zy, uint table, int difficulty, uint terrain, uint chance )
{
    SetZone( zx, zy, table, difficulty, terrain, chance, chance, chance );
}

//
// Tables
//

void AddTableToAllTables( CEncounterTable& globalTable )
{
    for( uint i = 0; i < TABLE_MAX; i++ )
    {
        if( i != TABLE_Ocean1_O && i != TABLE_Ocean2_O )
        {
            CEncounterTable@ table = EncounterTables[ i ];

            for( uint j = 0; j < globalTable.LocationPids.length(); j++ )
            {
                table.LocationPids.grow( 1 );
                table.LocationPids.last() = globalTable.LocationPids[ j ];
            }

            for( uint j = 0; j < globalTable.Encounters.length(); j++ )
            {
                table.Encounters.grow( 1 );
                table.Encounters.last() = globalTable.Encounters[ j ];
            }
        }
    }
}

//
// Checks
//

bool CheckCompare( int val1, uint8 operator, int val2 )
{
    if( operator == '>' )
        return val1 > val2;
    if( operator == '<' )
        return val1 < val2;
    if( operator == '=' )
        return val1 == val2;
    Log( "Unknown operator." );
    return false;
}

bool CheckCompareAnyParam( CCheck& check, Critter@[]& critters )
{
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( CheckCompare( critters[ i ].Param[ check.Index ], check.Operator, check.Value ) )
            return true;
    }
    return false;
}

bool CheckCompareAnyVar( CCheck& check, Critter@[]& critters )
{
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        GameVar@ lvar = GetLocalVar( check.Index, critters[ i ].Id );
        if( valid( lvar ) )
        {
            if( CheckCompare( lvar.GetValue(), check.Operator, check.Value ) )
                return true;
        }
    }
    return false;
}

bool CheckCompareHour( int val1, int val2, int val3 )
{
    if( val2 > val3 )
        return ( val1 > val2 || val1 < val3 );
    if( val2 < val3 )
        return ( val1 > val2 && val1 < val3 );

    /*if(operator=='>') return val1>val2;
       if(operator=='<') return val1<val2;
       if(operator=='=') return val1==val2;*/
    Log( "Unknown operator." );
    return false;
}

void CheckAssignVar( GameVar& val1, uint8 operator, int val2 )
{
    if( operator == '=' )
        val1 = val2;
    else if( operator == '+' )
        val1 += val2;
    else if( operator == '-' )
        val1 -= val2;
    else if( operator == '*' )
        val1 *= val2;
    else if( operator == '/' )
        val1 /= val2;
    else
        Log( "Unknown operator." );
}

bool CheckChecks( CCheck[]& checks, Critter@[]& critters )
{
    bool checkOk = false;
    for( int ichecks = 0, checks_max = checks.length(); ichecks < checks_max; ichecks++ )
    {
        CCheck@ check = checks[ ichecks ];
        switch( check.Type )
        {
        case CHECK_IS_PLAYER:
            if( critters[ 0 ].IsNpc() )
                return false;
            break;
        case CHECK_RANDOM:
            if( Random( 1, 100 ) > check.Value )
                return false;
            break;
        case CHECK_HOUR:
            if( not CheckCompareHour( __Hour, check.ValueMin, check.ValueMax ) )
                return false;
            break;
        case CHECK_PARAM:
            for( uint i = 0, j = critters.length(); i < j; i++ )
                if( not CheckCompare( critters[ i ].Param[ check.Index ], check.Operator, check.Value ) )
                    return false;
            break;
        case CHECK_PARAM_LEADER:
            if( not CheckCompare( critters[ 0 ].Param[ check.Index ], check.Operator, check.Value ) )
                return false;
            break;
        case CHECK_PARAM_ANY:
            if( not CheckCompareAnyParam( check, critters ) )
                return false;
            break;
        case CHECK_LVAR:
            // Log("Checking var"+check.Index);
            for( uint i = 0, j = critters.length(); i < j; i++ )
            {
                GameVar@ lvar = GetLocalVar( check.Index, critters[ i ].Id );
                if( not valid( lvar ) )
                {
                    // Log("Local var not found.");
                    return false;
                }
                // Log("Var val"+lvar.GetValue()+"cr id");
                if( not CheckCompare( lvar.GetValue(), check.Operator, check.Value ) )
                    return false;
            }
            break;
        case CHECK_LVAR_ANY:
            if( not CheckCompareAnyVar( check, critters ) )
                return false;
            break;
        case CHECK_GVAR:
        {
            GameVar@ gvar = GetGlobalVar( check.Index );
            if( not valid( gvar ) )
            {
                // Log("Global var not found.");
                return false;
            }
            if( not CheckCompare( gvar.GetValue(), check.Operator, check.Value ) )
                return false;
        }
        break;
        default:
            continue;
        }
    }
    return true;
}

void AssignChecks( CCheck[]& checks, Critter@[]& critters )
{
    for( int ichecks = 0, checks_max = checks.length(); ichecks < checks_max; ichecks++ )
    {
        CCheck@ check = checks[ ichecks ];
        if( check.Type == ASSIGN_LVAR )
        {
            for( uint i = 0, j = critters.length(); i < j; i++ )
            {
                GameVar@ lvar = GetLocalVar( check.Index, critters[ i ].Id );
                CheckAssignVar( lvar, check.Operator, check.Value );
            }
        }
    }
}

//
// Stored founded encounters
//

#define FOUNDED_ENCOUNTER_LIVE_TIME    ( REAL_MINUTE( 10 ) ) // 10 real minutes


CFoundedEncounter[] FoundedEncounters( 1000 );
uint FoundedEncountersLastIndex = 0;

CFoundedEncounter@ CreateFoundedEncounter( bool isWater, uint x, uint y, CEncounter@ encounter, uint16[]& locationPids, uint ownerId, bool ownerGroup )
{
    for( int i = 0, j = FoundedEncounters.length(); i < j; i++ )
    {
        CFoundedEncounter@ ge = FoundedEncounters[ i ];
        if( ge.Index == 0 || __FullSecond - ge.FullSecond >= FOUNDED_ENCOUNTER_LIVE_TIME + REAL_MINUTE( 1 ) )
        {
            FoundedEncountersLastIndex++;
            ge.Index = FoundedEncountersLastIndex;
            ge.LocationPids = locationPids;
            @ge.Encounter = encounter;
            ge.IsGenerated = false;
            ge.FullSecond = __FullSecond;
            ge.PositionX = x;
            ge.PositionY = y;
            ge.OwnerId = ownerId;
            ge.OwnerGroup = ownerGroup;
            ge.LocationId = 0;
            ge.IsWater = isWater;
            for( uint k = 0; k < 6; k++ )
                ge.DirBusy[ k ] = false;
            return ge;
        }
    }

    // Grow buffer and refind
    FoundedEncounters.resize( FoundedEncounters.length() * 2 );
    return CreateFoundedEncounter( isWater, x, y, encounter, locationPids, ownerId, ownerGroup );
}

CFoundedEncounter@ GetFoundedEncounter( uint index )
{
    for( int i = 0, j = FoundedEncounters.length(); i < j; i++ )
    {
        CFoundedEncounter@ ge = FoundedEncounters[ i ];
        if( ge.Index == index )
            return ge;
    }
    return null;
}

CFoundedEncounter@ GetNearFoundedEncounter( bool isWater, Critter@[] @ group, uint x, uint y, uint radius )
{
    // int combatMode=group[0].Mode[MODE_DEFAULT_COMBAT];
    for( int i = 0, j = FoundedEncounters.length(); i < j; i++ )
    {
        CFoundedEncounter@ ge = FoundedEncounters[ i ];
        if( ge.Index == 0 )
            continue;
        // if(ge.TurnBased && combatMode==COMBAT_MODE_REAL_TIME) continue;
        /*if(not ge.TurnBased && combatMode==COMBAT_MODE_TURN_BASED) continue;*/
        if( ge.IsWater != isWater )
            continue;
        if( __FullSecond - ge.FullSecond >= FOUNDED_ENCOUNTER_LIVE_TIME )
            continue;
        if( not ge.IsGenerated )
            continue;
        if( valid( ge.Encounter ) && ge.Encounter.IsSpecial && not CheckChecks( ge.Encounter.Checks, group ) )
            continue;
        if( POW2( ge.PositionX - x ) + POW2( ge.PositionY - y ) > POW2( radius ) )
            continue;
        if( group[ 0 ].Id == ge.OwnerId )
            continue;
        if( not valid( GetLocation( ge.LocationId ) ) )
            continue;

        return ge;
    }
    return null;
}

uint GetFreeDir( bool[]& dirBysy )
{
    // Try find random
    uint dir = Random( 0, 5 );
    if( not dirBysy[ dir ] )
    {
        dirBysy[ dir ] = true;
        return dir;
    }

    // Try find any free
    for( uint i = 0; i < 6; i++ )
    {
        if( not dirBysy[ i ] )
        {
            dirBysy[ i ] = true;
            return i;
        }
    }

    // Any busy
    return Random( 0, 5 );
}

void RotatePosition( uint toDir, uint[]& positionsDirs )
{
    for( uint i = 1, j = positionsDirs.length(); i < j; i++ ) // Skip Steps
    {
        positionsDirs[ i ] += toDir;
        if( positionsDirs[ i ] > 5 )
            positionsDirs[ i ] -= 6;
    }
}

void MovePositionPoint( Map& map, uint16& pointX, uint16& pointY, uint[]& positionDirs, uint pathIndex, uint count, uint spacing )
{
    uint steps = positionDirs[ 0 ];
    uint pathLen = ( positionDirs.length() - 1 ) / 2;
    count *= steps;
    count %= pathLen;
    if( steps > 1 )
    {
        for( uint i = 0; i < spacing; i++ )
        {
            for( uint j = 0; j < steps; j++ )
            {
                uint dir = positionDirs[ 1 + pathLen * pathIndex + count + j ];
                map.MoveHexByDir( pointX, pointY, dir, 1 );
            }
        }
    }
    else
    {
        uint dir = positionDirs[ 1 + pathLen * pathIndex + count ];
        map.MoveHexByDir( pointX, pointY, dir, spacing );
    }
}

void ParseEncounterObject( CEncounterObject@ obj, Map@ map, uint16 posX, uint16 posY, uint8 reversDir, Critter@[]& crittersGrouop, uint teamId )
{
    if( obj.ObjectType == ENCOUNTER_OBJECT_CRITTER )
    {
        if( not map.IsHexPassed( posX, posY ) )
        {
            uint16 posX_ = 0, posY_ = posY;
            for( uint i = 0; i < 31; i++ )
            {
                if( i < 15 )
                    posX_ = posX + 1;
                else if( posX > 2 )
                {
                    posX_ = posX - 1;
                }
                posY_ += Random( -5, 5 );
                if( map.IsHexPassed( posX_, posY_ ) )
                {
                    posX = posX_;
                    posY = posY_;
                    break;
                }
                if( i == 29 )
                    return;
            }
        }

        int[] items;
        if( obj.Childs.length() > 0 )
        {
            for( uint i = 0, j = obj.Childs.length(); i < j; i++ )
            {
                CEncounterObject@ child = obj.Childs[ i ];
                uint              count = Random( child.Minimum, child.Maximum );
                if( count > 0 && uint( Random( 1, 1000 ) ) <= child.Chance )
                {
                    items.insertLast( child.Pid );
                    items.insertLast( count );
                    items.insertLast( child.InvSlot );
                }
            }
        }

        int[] params =
        {
            ST_DIALOG_ID, obj.DialogId,
            ST_BAG_ID, BAG_Empty,
            ST_TEAM_ID, teamId,
            ST_REPLICATION_TIME, -1,
            MODE_ENCAUNTER_MOB, 1
        };
        Critter@ npc = map.AddNpc( obj.Pid, posX, posY, reversDir, params, items, obj.ScriptName );

        // Log("ƒобавлен Ќѕ÷");
        // Critter@ merc=map.AddNpc(497, posX, posY, reversDir, null, null, null);
        // merc.MercBase[MERC_MASTER_DIST]=6;
        // Merc2Player(cr, merc, 4); // ќхранник по умолчанию. «ащищает хоз€ина
        if( not valid( npc ) )
            return;

        if( items.length() > 0 && Random( 1, 100 ) == 1 )
        {
            Item@[] rItems;
            npc.GetItemsByType( ITEM_TYPE_WEAPON, rItems );
            npc.GetItemsByType( ITEM_TYPE_ARMOR, rItems );
            if( rItems.length() > 0 )
                InitRandomisationItem( rItems[ Random( 0, rItems.length() - 1 ) ], false, npc, "" );
        }

        if( obj.IsDead )
            npc.ToDead( Random( 0, 1 ) == 0 ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK, null );
        else
            crittersGrouop.insertLast( @npc );
    }
    else if( obj.ObjectType == ENCOUNTER_OBJECT_ITEM )
    {
        Item@ item = map.AddItem( posX, posY, obj.Pid, 1 );
        if( not valid( item ) )
            return;

        if( obj.Childs.length() > 0 && item.GetType() == ITEM_TYPE_CONTAINER )
        {
            for( uint i = 0, j = obj.Childs.length(); i < j; i++ )
            {
                CEncounterObject@ child = obj.Childs[ i ];
                uint              count = Random( child.Minimum, child.Maximum );
                if( count > 0 && uint( Random( 1, 1000 ) ) <= child.Chance )
                    item.AddItem( child.Pid, count, 0 );
            }
        }
    }
    else
        Log( "Unknown object type<" + obj.ObjectType + ">." );
}

void ActionFighting( Critter@[]& npcL, Critter@[]& npcR )
{
    for( int i = 0, j = npcL.length(); i < j; i++ )
    {
        Critter@ nl = npcL[ i ];
        bool     nlIsNpc = nl.IsNpc();
        for( int k = 0, l = npcR.length(); k < l; k++ )
        {
            Critter@ nr = npcR[ k ];
            if( nlIsNpc )
            {
                AddAttackPlane( nl, 0, nr );
                nl.AddEnemyInStack( nr.Id );
                nl.Wait( Random( 4000, 5000 ) );
            }
            if( nr.IsNpc() )
            {
                AddAttackPlane( nr, 0, nl );
                nr.AddEnemyInStack( nl.Id );
                nr.Wait( Random( 4000, 5000 ) );
            }
        }
    }
}

Map@ GenerateEncounter( CFoundedEncounter@ fe, Critter@[] @ critters )
{
    CEncounter@ encounter = fe.Encounter;
    uint16 locPid = ( valid( encounter ) ? encounter.LocPid : 0 );
    if( locPid == 0 )
        locPid = fe.LocationPids[ Random( 0, fe.LocationPids.length() - 1 ) ];

    fe.LocationId = CreateLocation( locPid, fe.PositionX, fe.PositionY, null );
    if( fe.LocationId == 0 )
    {
        Log( "CreateLocation fail, location pid<" + locPid + ">." );
        return null;
    }

    Location@ location = GetLocation( fe.LocationId );
    if( not valid( location ) )
    {
        Log( "GetLocation fail." );
        return null;
    }
    GameVar@ isEncounter = GetLocalVar( LLVAR_is_encounter, fe.LocationId );
    if( valid( isEncounter ) )
    {
        isEncounter = 1;
    }
    // √енераци€ итемов на всех картах энкаунтера
    for( uint i = 0, l = location.GetMapCount(); i < l; i++ )
    {
        Map@ m = location.GetMapByIndex( i );
        if( valid( m ) )
        {
            GenerateItems( m, critters );
            if( i > 0 )
            {
                GenerateCavernEncounter( m, critters );
            }
        }
    }

    Map@ map = location.GetMapByIndex( 0 );
    if( not valid( map ) )
    {
        Log( "GetMapByIndex fail." );
        return null;
    }

    if( map.GetScriptId() == 0 )
        map.SetScript( "events_in_encaunter@initEvents" );

    uint16 startX = 0, startY = 0;
    if( not map.GetEntireCoords( 0, 0, startX, startY ) )
    {
        Log( "Default entire not found." );
        return null;
    }

    fe.StartHexX = startX;
    fe.StartHexY = startY;

    // Log("1 sX="+startX);
    // Log("1 sY="+startY);

    if( not valid( encounter ) ) // Empty map
    {
        fe.IsGenerated = true;
        return map;
    }

    Critter@ leader = critters[ 0 ];
    Critter@[][] crittersGrouops( encounter.Groups.length() );

    uint bufer = 0;
    uint bufer2 = 0;

    for( uint igroup = 0, groupmax = encounter.Groups.length(); igroup < groupmax; igroup++ )
    {
        uint groupNum = encounter.Groups[ igroup ];

        if( groupNum == GROUP_Player )
        {
            Critter@[] @ crGroup = crittersGrouops[ igroup ];
            crGroup.resize( critters.length() );
            for( uint k = 0, l = critters.length(); k < l; k++ )
                @crGroup[ k ] = critters[ k ];
            continue;
        }

        if( groupNum >= GROUP_MAX )
        {
            Log( "Invalid group number." );
            continue;
        }

        CEncounterGroup@ group = EncounterGroups[ groupNum ];

        uint ratio = Random( encounter.RatioMin[ igroup ], encounter.RatioMax[ igroup ] );
        uint distance = group.Distance;
        if( distance == 0 )
            distance = 7 + leader.Stat[ ST_PERCEPTION ] + leader.Perk[ PE_CAUTIOUS_NATURE ] * 3;
        uint teamId = group.TeamNum;
        if( teamId == 0 )
            teamId = TEAM_Mob0 + igroup;

        uint position = group.Position;
        uint spacing = group.Spacing;
        if( position == POSITION_SURROUNDING )
            spacing = leader.Stat[ ST_PERCEPTION ] + leader.Perk[ PE_CAUTIOUS_NATURE ] * 3;

        uint[] positionDirs = PositionDirs[ position ];
        uint steps = positionDirs[ 0 ];
        uint dirsCount = 0;

        uint freeDir = GetFreeDir( fe.DirBusy );
        if( freeDir != 0 )
            RotatePosition( freeDir, positionDirs );
        uint reversDir = freeDir + 3;
        if( reversDir > 5 )
            reversDir -= 6;

        // Get start point for group
        uint16[] pointX = { startX, startY };
        uint16[] pointY = { startX, startY };
        if( position != POSITION_NONE )
        {
            uint16 hx = pointX[ 0 ], hy = pointY[ 0 ];
            map.MoveHexByDir( pointX[ 0 ], pointY[ 0 ], freeDir, position != POSITION_SURROUNDING ? distance : spacing );
            map.GetHexCoord( hx, hy, pointX[ 0 ], pointY[ 0 ], 0.0f, 0 );  // Check for barrier
            pointX[ 1 ] = pointX[ 0 ];
            pointY[ 1 ] = pointY[ 0 ];
            MovePositionPoint( map, pointX[ 1 ], pointY[ 1 ], positionDirs, 1, 0, spacing );
        }

        bool trigger = false;
        uint realCount = 0;

        for( uint k = 0, l = group.Objects.length(); k < l; k++ )
        {
            CEncounterObject@ obj = group.Objects[ k ];

            if( not CheckChecks( obj.Checks, critters ) )
                continue;
            uint otherDistance = obj.DistanceLength;

            bufer += ( obj.RatioValue * ratio / 10 ) % 10;
            bufer2 += ( obj.RatioValue * ratio ) % 10;
            // Log("bufer: "+bufer);
            // Log("bufer2: "+bufer2);
            uint count = obj.RatioValue * ratio / 100;
            if( bufer2 >= 10 )
            {
                bufer += bufer2 / 10;
                bufer2 = bufer2 % 10;
                // Log("bufer2 после вз€ти€ остатка: "+bufer2);
            }
            if( bufer >= 10 )
            {
                // 10*(30+10)/1000
                count += bufer / 10;
                bufer = bufer % 10;
                // Log("bufer после вз€ти€ остатка: "+bufer);
            }

            if( obj.RatioValue == 0 )
                count = 1;
            realCount += count;

            uint16 oldPosX = startX, oldPosY = startY;

            uint   scatter = ratio > 5 ? ratio : 5;
            for( uint n = 0; n < count; n++ )
            {
                uint16 posX, posY;
                if( otherDistance > 0 || position == POSITION_NONE )
                {
                    posX = startX + Random( -scatter, scatter );
                    posY = startY + Random( -scatter, scatter );
                    map.MoveHexByDir( posX, posY, freeDir, otherDistance > 0 ? otherDistance : distance );
                    // Log("-2-1 pX="+posX);
                    // Log("-2-1 pY="+posY);
                }
                else
                {
                    uint pathIndex = dirsCount % 2;
                    // Log("-2 pointX="+pointX[pathIndex]);
                    // Log("-2 pointX="+pointY[pathIndex]);
                    posX = pointX[ pathIndex ] + ( position == POSITION_SURROUNDING ? Random( -3, 0 ) : 0 );
                    posY = pointY[ pathIndex ] + ( position == POSITION_SURROUNDING ? Random( -3, 0 ) : 0 );
                    // Log("-2-2-1 pX="+posX);
                    // Log("-2-2-1 pY="+posY);
                    MovePositionPoint( map, pointX[ pathIndex ], pointY[ pathIndex ], positionDirs, pathIndex, dirsCount, spacing );
                    dirsCount++;
                }

                // map.GetHexCoord(oldPosX,oldPosY,posX,posY,0.0f,0); // Check for barrier
                // Log("-3 pX="+posX);
                // Log("-3 pY="+posY);
                // Log("=====================");
                oldPosX = posX;
                oldPosY = posY;
                ParseEncounterObject( obj, map, posX, posY, reversDir, crittersGrouops[ igroup ], teamId );
            }
        }
    }

    for( uint i = 0, j = encounter.Actions.length(); i < j; i += 3 )
    {
        uint fromGroup = encounter.Actions[ i ];
        uint toGroup = encounter.Actions[ i + 1 ];
        uint action = encounter.Actions[ i + 2 ];

        if( action == ACTION_FIGHTING && fromGroup < crittersGrouops.length() && toGroup < crittersGrouops.length() )
            ActionFighting( crittersGrouops[ fromGroup ], crittersGrouops[ toGroup ] );
    }

    fe.IsGenerated = true;
    return map;
}

//
// Imports
//
// void FindEncounter(Critter@[]@ critters, uint zx, uint zy) return foundedEncounterIndex
// bool InviteToEncounter(uint foundedEncounterIndex, Critter@[]@ critters) invite critters to encounter
// void WorldmapInit() call on start server

/*const int[] ScanOffsX={-1,0,1,-1,0,1,-1,0,1};
   const int[] ScanOffsY={-1,0,1,-1,0,1,-1,0,1};
   void ScanZone(Critter& cr, uint zx, uint zy)
   {
        uint zoneX=cr.WorldX/__GlobalMapZoneLength;
        uint zoneY=cr.WorldY/__GlobalMapZoneLength;

        cr.SetFog(zoneX,zoneY,FOG_NONE);
        cr.SetFog(zoneX-1,zoneY-1,FOG_SELF);
        cr.SetFog(zoneX  ,zoneY-1,FOG_SELF);
        cr.SetFog(zoneX+1,zoneY-1,FOG_SELF);
        cr.SetFog(zoneX-1,zoneY  ,FOG_SELF);
        cr.SetFog(zoneX+1,zoneY  ,FOG_SELF);
        cr.SetFog(zoneX-1,zoneY+1,FOG_SELF);
        cr.SetFog(zoneX  ,zoneY+1,FOG_SELF);
        cr.SetFog(zoneX+1,zoneY+1,FOG_SELF);

        for(int ox=-1;ox<2;ox++)
        {
                for(int oy=-1;oy<2;oy++)
                {

                }
        }
   }*/

void FindEncounter( Critter@[]& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer, bool empty )
{
    encounterDescriptor = 0;
    waitForAnswer = false;

    uint zx = x / ZONE_LENGTH;
    uint zy = y / ZONE_LENGTH;
    if( zx >= ZONE_COUNT_X || zy >= ZONE_COUNT_Y )
    {
        // Log("Invalid zones coordinates."); in faction mod size is greather than ZONE_COUNT_X, ZONE_COUNT_Y.
        return;
    }

    bool isWater = ( GetGlobalMapRelief( x, y ) == 0 );
    int  walkType = ( valid( car ) ? car.Proto.Car_MovementType : GM_WALK_GROUND );
    bool walkWaterOrFly = ( walkType == GM_WALK_WATER || walkType == GM_WALK_FLY );
    if( walkType == GM_WALK_GROUND && isWater )
        return;

    if( walkType == GM_WALK_UNDERGROUND )
        return;                                   // ћетро

    CZone@ zone = ( isWater ? WorldmapWater[ zy * ZONE_COUNT_X + zx ] : WorldmapGround[ zy * ZONE_COUNT_X + zx ] );
    if( not valid( zone ) )
        return;
    Critter@ leader = group[ 0 ];

    // Create empty map
    if( empty )
    {
        CFoundedEncounter@ fe = CreateFoundedEncounter( isWater, x, y, null, zone.Table.LocationPids, leader.Id, group.length() > 1 );
        if( not valid( fe ) )
            return;
        waitForAnswer = false;
        encounterDescriptor = fe.Index;
        return;
    }

    // Check chance
    uint chance;
    if( IS_MORNING( __Hour ) )
        chance = zone.MorningChance;
    if( IS_AFTERNOON( __Hour ) )
        chance = zone.AfternoonChance;
    else
        chance = zone.NightChance;

    Item@ sensor = _CritGetItemHand( leader );
    if( @sensor == null || sensor.GetProtoId() != PID_ACTIVE_MOTION_SENSOR )
        @sensor = _CritGetItemBonus( leader );
    if( valid( sensor ) && sensor.GetProtoId() == PID_ACTIVE_MOTION_SENSOR )
        chance *= 2;
    if( uint( Random( 1, 100 ) ) > chance )
        return;

    // Try find already founded encounter
    CFoundedEncounter@ feAlready = GetNearFoundedEncounter( isWater, group, x, y, ZONE_LENGTH / 2 );
    if( valid( feAlready ) )
    {
        int outdoorsman = leader.Skill[ SK_OUTDOORSMAN ];
        int maxLevel = 1;
        for( uint i = 1, iMax = group.length(); i < iMax; i++ )
        {
            if( group[ i ].IsPlayer() && group[ i ].Skill[ SK_OUTDOORSMAN ] < outdoorsman )
                outdoorsman = group[ i ].Skill[ SK_OUTDOORSMAN ];
            if( group[ i ].IsPlayer() && group[ i ].Stat[ ST_LEVEL ] > maxLevel )
                maxLevel = group[ i ].Stat[ ST_LEVEL ];
        }
        int minSkil = outdoorsman;
        outdoorsman += zone.Difficulty;
        outdoorsman = CLAMP( outdoorsman, 6, 95 );
        if( int( CLAMP( outdoorsman, 6, 95 ) ) >= Random( 1, 100 ) || walkWaterOrFly )
        {
            if( valid( feAlready.Encounter ) )
            {
                Critter@ ow = GetCritter( feAlready.OwnerId );

                if( valid( ow ) && ow.IsPlayer() )
                {
                    Critter@[] group2;
                    ow.GetFollowGroup( FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, group2 );
                    int maxLevel2 = ow.Stat[ ST_LEVEL ];
                    for( uint n = 0; n < group2.length(); n++ )
                    {
                        if( group2[ n ].IsPlayer() && group2[ n ].Stat[ ST_LEVEL ] > maxLevel2 )
                            maxLevel2 = group2[ n ].Stat[ ST_LEVEL ];
                    }
                    if( maxLevel <= maxLevel2 )
                        leader.SayMsg( SAY_ENCOUNTER_RT, TEXTMSG_GM, feAlready.OwnerGroup ? STR_QUESTION_WITH_PLAYERS : STR_QUESTION_WITH_PLAYER,
                                       "$who @msg gm " + feAlready.Encounter.StrNum + "@$player" + GetPlayerName( feAlready.OwnerId ) );
                }
            }
            else
            {
                Critter@ ow = GetCritter( feAlready.OwnerId );
                if( valid( ow ) && ow.IsPlayer() )
                {
                    Critter@[] group2;
                    ow.GetFollowGroup( FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, group2 );
                    int maxLevel2 = ow.Stat[ ST_LEVEL ];
                    for( uint n = 0; n < group2.length(); n++ )
                    {
                        if( group2[ n ].IsPlayer() && group2[ n ].Stat[ ST_LEVEL ] > maxLevel2 )
                            maxLevel2 = group2[ n ].Stat[ ST_LEVEL ];
                    }
                    if( maxLevel <= maxLevel2 )
                    {
                        Critter@ target = GetCritter( feAlready.GlobalPvp_TargetId );
                        if( valid( target ) && target.IsPlayer() )
                        {
                            leader.SayMsg( SAY_ENCOUNTER_RT, TEXTMSG_GM, feAlready.OwnerGroup ? STR_QUESTION_WITH_PLAYERS : STR_QUESTION_WITH_PLAYER,
                                           "@$who" + GetPlayerName( feAlready.GlobalPvp_TargetId ) + " @$player" + GetPlayerName( feAlready.OwnerId ) );
                        }
                        else
                            leader.SayMsg( SAY_ENCOUNTER_RT, TEXTMSG_GM, feAlready.OwnerGroup ? STR_QUESTION_ONLY_PLAYERS : STR_QUESTION_ONLY_PLAYER,
                                           "$player" + GetPlayerName( feAlready.OwnerId ) );
                    }
                }
            }
            waitForAnswer = true;

            if( not walkWaterOrFly )
            {
                GameVar@ outdoorsmaTimeout = GetLocalVar( LVAR_outdoorsman_timeout, leader.Id );
                GameVar@ outdoorsmanDiv = GetLocalVar( LVAR_outdoorsman_div, leader.Id );
                if( valid( outdoorsmaTimeout ) && valid( outdoorsmanDiv ) )
                {
                    if( uint( outdoorsmaTimeout.GetValue() ) > __FullSecond )
                        outdoorsmanDiv += 1;
                    else
                        outdoorsmanDiv -= 2 * ( __FullSecond - outdoorsmaTimeout.GetValue() ) / TIMEOUT_OUTDOORSMAN;
                    if( outdoorsmanDiv.GetValue() < 1 )
                        outdoorsmanDiv = 1;
                    outdoorsmaTimeout = __FullSecond + TIMEOUT_OUTDOORSMAN;

                    if( minSkil <= 95 )
                        leader.StatBase[ ST_EXPERIENCE ] += ( 100 - minSkil - zone.Difficulty ) * NUMERATOR_OUTDOORSMAN / ( NUMERATOR_OUTDOORSMAN - 1 + outdoorsmanDiv.GetValue() );
                    else
                        leader.StatBase[ ST_EXPERIENCE ] += ( 5 - zone.Difficulty ) * NUMERATOR_OUTDOORSMAN / ( NUMERATOR_OUTDOORSMAN - 1 + outdoorsmanDiv.GetValue() );
                }
            }
        }

        for( uint i = 0, j = group.length(); i < j; i++ )
            group[ i ].Say( SAY_FLASH_WINDOW, "" );
        encounterDescriptor = feAlready.Index;
        return;
    }

    // Try find new encounter
    int luck = 0;
    for( uint i = 0, j = group.length(); i < j; i++ )
        luck += group[ i ].Stat[ ST_LUCK ];
    luck /= group.length();

    int roll = Random( 0, 100 ) + luck - 5 + 2 * leader.Perk[ PE_EXPLORER ] + leader.Perk[ PE_RANGER ] + leader.Perk[ PE_SCOUT ];
    if( roll < 0 )
        roll = 0;
    int maxRoll = 0;

    CEncounter[] @ encounters = zone.Table.Encounters;
    CEncounter@[] encountersThru( encounters.length() );
    for( uint i = 0, j = encounters.length(); i < j; i++ )
    {
        CEncounter@ enc = encounters[ i ];
        if( CheckChecks( enc.Checks, group ) )
        {
            maxRoll += enc.Chance;
            @encountersThru[ i ] = encounters[ i ];
        }
        else
        {
            @encountersThru[ i ] = null;
        }
    }

    roll = roll * maxRoll / 100;
    for( uint ienc = 0, iencmax = encountersThru.length(); ienc < iencmax; ienc++ )
    {
        CEncounter@ enc = encountersThru[ ienc ];

        if( not valid( enc ) )
            continue;
        if( uint( roll ) > enc.Chance && ienc < iencmax - 1 )
        {
            roll -= enc.Chance;
            continue;
        }

        CFoundedEncounter@ fe = CreateFoundedEncounter( isWater, x, y, enc, zone.Table.LocationPids, leader.Id, group.length() > 1 );
        if( not valid( fe ) )
            return;

        int outdoorsman = leader.Skill[ SK_OUTDOORSMAN ];
        for( uint16 i = 1, iMax = group.length(); i < iMax; i++ )
        {
            if( group[ i ].IsPlayer() && group[ i ].Skill[ SK_OUTDOORSMAN ] < outdoorsman )
                outdoorsman = group[ i ].Skill[ SK_OUTDOORSMAN ];
        }
        int minSkil = outdoorsman;
        outdoorsman += zone.Difficulty;
        outdoorsman = CLAMP( outdoorsman, 6, 95 );
        if( outdoorsman >= Random( 1, 100 ) || walkWaterOrFly )
        {
            leader.SayMsg( SAY_ENCOUNTER_RT, TEXTMSG_GM, STR_QUESTION, "$who @msg gm " + enc.StrNum + "@" );
            waitForAnswer = true;

            if( not walkWaterOrFly )
            {
                GameVar@ outdoorsmaTimeout = GetLocalVar( LVAR_outdoorsman_timeout, leader.Id );
                GameVar@ outdoorsmanDiv = GetLocalVar( LVAR_outdoorsman_div, leader.Id );
                if( valid( outdoorsmaTimeout ) && valid( outdoorsmanDiv ) )
                {
                    if( uint( outdoorsmaTimeout.GetValue() ) > __FullSecond )
                        outdoorsmanDiv += 1;
                    else
                        outdoorsmanDiv -= 2 * ( __FullSecond - outdoorsmaTimeout.GetValue() ) / TIMEOUT_OUTDOORSMAN;
                    if( outdoorsmanDiv.GetValue() < 1 )
                        outdoorsmanDiv = 1;
                    outdoorsmaTimeout = __FullSecond + TIMEOUT_OUTDOORSMAN;

                    if( minSkil <= 95 )
                        leader.StatBase[ ST_EXPERIENCE ] += ( 100 - minSkil - zone.Difficulty ) * NUMERATOR_OUTDOORSMAN / ( NUMERATOR_OUTDOORSMAN - 1 + outdoorsmanDiv.GetValue() );
                    else
                        leader.StatBase[ ST_EXPERIENCE ] += ( 5 - zone.Difficulty ) * NUMERATOR_OUTDOORSMAN / ( NUMERATOR_OUTDOORSMAN - 1 + outdoorsmanDiv.GetValue() );
                }
            }
        }

        for( uint i = 0, j = group.length(); i < j; i++ )
            group[ i ].Say( SAY_FLASH_WINDOW, "" );
        encounterDescriptor = fe.Index;
        break;
    }
}

void InviteToEncounter( Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir )
{
    CFE_InviteToEncounter( group, car, encounterDescriptor, combatMode, mapId, hexX, hexY, dir );
}

CFoundedEncounter@ CFE_InviteToEncounter( Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir )
{
    mapId = 0;

    CFoundedEncounter@ fe = GetFoundedEncounter( encounterDescriptor );
    if( not valid( fe ) )
    {
        Log( "GetFoundedEncounter fail." );
        return null;
    }

    bool isGenerated = fe.IsGenerated;
    Map@ map = null;
    if( isGenerated )
    {
        Location@ location = GetLocation( fe.LocationId );
        if( not valid( location ) )
        {
            // Log("Location not found.");
            return null;
        }

        @map = location.GetMapByIndex( 0 );
    }
    else
    {
        @map = GenerateEncounter( fe, group );
    }

    if( not valid( map ) )
    {
        Log( "Map not found." );
        return null;
    }

    /*if(not isGenerated && combatMode==COMBAT_MODE_TURN_BASED) //|| (combatMode==COMBAT_MODE_ANY && Random(0,1)==0)))
       {
        map.SetTurnBasedAvailability(true);
            fe.TurnBased=true;
       }*/

    Critter@ leader = group[ 0 ];
    mapId = map.Id;
    hexX = fe.StartHexX;
    hexY = fe.StartHexY;
    if( isGenerated )
    {
        if( valid( car ) )
        {
            // Place critters near his car
            hexX = uint16( -1 );
            hexY = uint16( -1 );
        }
        else
        {
            dir = GetFreeDir( fe.DirBusy );
            map.MoveHexByDir( hexX, hexY, dir, leader.Stat[ ST_PERCEPTION ] + leader.Perk[ PE_CAUTIOUS_NATURE ] * 3 );
            dir += 3;
            if( dir > 5 )
                dir = dir % 6;
        }
    }
    else
    {
        if( valid( car ) )
        {
            // Place critters near his car
            hexX = uint16( -1 );
            hexY = uint16( -1 );
        }

        dir = Random( 0, 5 );
    }

    if( isGenerated || valid( fe.Encounter ) )
    {
        for( uint i = 0, j = group.length(); i < j; i++ )
        {
            Critter@ cr = group[ i ];
            if( not isGenerated )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GM, STR_VIEW, "$who @msg gm " + fe.Encounter.StrNum + "@" );
            else if( valid( fe.Encounter ) )
            {
                Critter@ ow = GetCritter( fe.OwnerId );
                if( valid( ow ) && ow.IsPlayer() )
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GM, fe.OwnerGroup ? STR_VIEW_WITH_PLAYERS : STR_VIEW_WITH_PLAYER, "$who @msg gm " + fe.Encounter.StrNum + "@$player" + GetPlayerName( fe.OwnerId ) );
            }
            else
            {
                Critter@ ow = GetCritter( fe.OwnerId );
                if( valid( ow ) && ow.IsPlayer() )
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GM, fe.OwnerGroup ? STR_VIEW_ONLY_PLAYERS : STR_VIEW_ONLY_PLAYER, "$player" + GetPlayerName( fe.OwnerId ) );
            }
        }
    }
    if( valid( fe.Encounter ) )
        AssignChecks( fe.Encounter.Checks, group );
    return fe;
}

uint GetGlobalMapRelief( uint x, uint y )
{
    // Used low four bits of image
    // Zero is water
    return GetImageColor( IMAGE_RELIEF, x, y ) & 0xF;
}

#include "hiding_place_dlg.fos"

void WorldmapInit()
{
    LoadImage( IMAGE_RELIEF, "relief_tla.png", 1, PT_SERVER_MAPS );
    #include "worldmap_init.fos"
}
