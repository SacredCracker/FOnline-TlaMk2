// специализированный инструмент для настройки поведения нпц в команде на конкретной карте

#include "_macros.fos"
#include "_animation.fos"


#define _CanGenStim								StatBase[ST_VAR4] // признак: может создать стимпак
#define _AllyAssistRadius						StatBase[ST_VAR5] // радиус, на котором моб ищет напарников при попадании игрока в область видимости
#define _AssistAlliesNum						StatBase[ST_VAR6] // число напарников, которые будут вызваны на помощь
#define _MustHealLvl							StatBase[ST_VAR7] // когда использовать стимпаки
#define _LocalAlarmDeads						StatBase[ST_VAR8] // локальная тревога
#define _GlobalAlarmDeads						StatBase[ST_VAR9] // глобальная тревога
#define _EnemySpotted							GetData(1) // признак - уже кто-то заметил игрока

#define _DeadAllies #(teamId)					GetData(teamId)// число убитых напарников

#define TeamId									StatBase[ST_TEAM_ID]


#define MSG_KILLEM							(17)// код сообщения "убить гада"

import void UseDrugOn(Critter& cr, Critter& onCr, Item& drug) from "drugs";

// счетчик убитых напарников (с тем же TeamID)
int DeadAllyCounter(Critter & cr)
{
	if (!valid(cr.GetMap())) return 0;

	if(cr.IsPlayer()) return 0;

	if(cr.TeamId==0) return 0;

	return cr.GetMap()._DeadAllies (cr.TeamId);

}

void AddDeadAlly (Critter & cr)
{
	if (!valid(cr.GetMap())) return;

	if(cr.IsPlayer()) return;

	if(cr.TeamId==0) return;

	cr.GetMap().SetData(cr.TeamId, DeadAllyCounter(cr) + 1);
}



// map карта с мобами
// teamId - номер команды моббов
// aDist - дистанция атаки видимого игрока
// alRadius - радиус реакции нпц на нападение моба из группы
// alNum - число мобов, которые подключаются к атаке
// hLvl - значение здоровья, при котором моб будет лечиться стимпаками
// locAlarm - число смертей мобов после которого остальные подходят к нападающему
// globAlarm - число смертей мобов, после которого все мобы на карте присоединяются к бою
// fArmLvl - коэффициент усиления брони и резистов моба
void SetMapMobsTemplate(Map & map, uint teamId, int aDist, int alRadius, int alNum, int hLvl, int locAlarm, int globAlarm, int fArmLvl)
{
	FighterPattern @ fp=FighterPattern();
	fp.AttackDist=aDist;
	fp.AllyAssistRadius=alRadius;
	fp.AssistAlliesNum=alNum;
	fp.MustHealLvl=hLvl;
	fp.LocalAlarmDeads=locAlarm;
	fp.GlobalAlarmDeads=globAlarm;
	fp.ForceArmourLvl=fArmLvl;

	Critter @ [] critters;
	map.GetCritters(0,FIND_LIFE|FIND_ONLY_NPC, critters);

	for(uint i=0, iMax=critters.length(); i<iMax;i++)
	{
		if(uint(critters[i].TeamId)!=teamId) continue;
		fp.InitPattern(critters[i]);
	}
	map.SetEvent (MAP_EVENT_CRITTER_DEAD, "e_OnMapCritterDead");
}

class FighterPattern
{
	FighterPattern()
	{
	}


	int AttackDist; // расстояние, на котором начинается атака
	int AllyAssistRadius; // радиус, в котором ищем членов группы
	int AssistAlliesNum; // число членов группы, которым отправится призыв о помощи
	int MustHealLvl; // уровень в процентах от макс хп, после которого нпц пытается полечиться
	int LocalAlarmDeads;// число смертей, после которых на помощь приходят все криттеры видящие нпц
	int GlobalAlarmDeads; // число смертей, после которых призыв о помощи пойдет по всей карте
	int ForceArmourLvl;// уровень усиления брони и резистов криттера 0 - базовый


	void InitPattern(Critter & cr)
	{
		cr.ShowCritterDist1=this.AttackDist;
		//DL("cr,GlobAl" +cr._GlobalAlarmDeads);
		cr._AllyAssistRadius=this.AllyAssistRadius;
		cr._AssistAlliesNum=this.AssistAlliesNum;
		cr._MustHealLvl=this.MustHealLvl;
		cr._LocalAlarmDeads=this.LocalAlarmDeads;
		cr._GlobalAlarmDeads=this.GlobalAlarmDeads;
		//DL("this.GlobalAlarmDeads;" + this.GlobalAlarmDeads+"cr,GlobAl" +cr._GlobalAlarmDeads);


		_SetOnDeadEvents(cr);
		_SetOnAttackedEvents(cr);
		_SetSeeEnemyEvents(cr);
		_SetOnItemDroppedEvents(cr);
		_SetOnMessageEvents(cr);
		_SetOnIddleEvents(cr);

		ForceCritterArmour(cr);
	}

	void ForceCritterArmour(Critter & cr)
	{

		if(this.ForceArmourLvl>3&&Random(1,3)==1)
		{
			cr.StatBase[ST_CRITICAL_RESISTANCE]=85;
			cr.StatBase[ST_STRENGTH]=10;
			cr.StatBase[ST_ENDURANCE]=Random(9,10);
			DL("Terminator");
		}

		for(int i=ST_NORMAL_RESIST; i<=ST_EXPLODE_RESIST;i++)
		{
			cr.StatBase[i]=Random(1,this.ForceArmourLvl)*20;
			cr.StatBase[i]=CLAMP(cr.StatBase[i], 30, 180);
		}
		//DL("-ForceArmourLvl" +this.ForceArmourLvl+ "startHealth="+cr.StatBase[ST_MAX_LIFE]+" hp "+cr.StatBase[ST_CURRENT_HP]);
		cr.StatBase[ST_MAX_LIFE]=CLAMP(cr.StatBase[ST_MAX_LIFE]+this.ForceArmourLvl*30, 50, 250);
		cr.StatBase[ST_CURRENT_HP]=CLAMP(cr.StatBase[ST_CURRENT_HP]+this.ForceArmourLvl*30, 50, 250);
		//DL("+ForceArmourLvl" +this.ForceArmourLvl+ "startHealth="+cr.StatBase[ST_MAX_LIFE]+" hp "+cr.StatBase[ST_CURRENT_HP]);

		//
	}

	void _SetOnAttackedEvents(Critter & cr)
	{
		cr._CanGenStim=Random(1,5);
		cr.SetEvent(CRITTER_EVENT_ATTACKED, "e_CritterAttacked");
	}

	void _SetSeeEnemyEvents(Critter & cr)
	{
		cr.SetEvent(CRITTER_EVENT_SHOW_CRITTER_1, "e_ShowCritter1");
	}

	void _SetOnItemDroppedEvents(Critter & cr)
	{

	}

	void _SetOnDeadEvents(Critter & cr)
	{
		//cr.SetEvent(CRITTER_EVENT_DEAD,"e_CritterDead");
		//cr.SetEvent(CRITTER_EVENT_SMTH_DEAD,"e_CritterSmthDead");
	}

	void _SetOnMessageEvents(Critter & cr)
	{
		cr.SetEvent(CRITTER_EVENT_MESSAGE,"e_CritterMessage");
	}

	void _SetOnIddleEvents(Critter & cr)
	{

	}


}
	/************************Обработка событий*************************/
	void e_OnMapCritterDead(Map& map, Critter& cr, Critter@ killer)
	{
		if(cr.IsPlayer())
		{
			if(map.GetCritters(0,FIND_LIFE|FIND_ONLY_PLAYERS, null)==0)
			{
				map.SetData(1,0);
				DL("All players dead");
			}
		}
		else
		{
			AddDeadAlly(cr);
			if (!valid(killer)) return;
			if (!killer.IsPlayer()) return;
			if(DeadAllyCounter(cr)>=cr._GlobalAlarmDeads)
			{
				cr.SendMessage(MSG_KILLEM, killer.Id, MESSAGE_TO_ALL_ON_MAP);
				DL("Global alarm called"+ DeadAllyCounter(cr)+"cr deads=_GlobalAlarmDeads"+cr._GlobalAlarmDeads);
				return;
			}
			if(DeadAllyCounter(cr)>=cr._LocalAlarmDeads)
			{
				cr.SendMessage(MSG_KILLEM, killer.Id, MESSAGE_TO_WHO_SEES_ME);
				DL("Local alarm called" + DeadAllyCounter(cr));
				return;
			}
		}
	}

	void e_ShowCritter1(Critter& cr, Critter& showCrit)
	{

		if (!showCrit.IsPlayer()) return;
		//DL("see player");
		// на появление игроков реагируют только первые заметивщие
		if(cr.GetMap()._EnemySpotted>0) return;
		cr.GetMap().SetData(1,1);

		//DL("See Critter mydist"+cr.ShowCritterDist1 + " and dist "+ GetCrittersDistantion(cr, showCrit));
		if (!showCrit.IsLife()) return;
		if(cr.CheckEnemyInStack(showCrit.Id)) return;
		//DL("will attack Critter");
		e_CritterMessage(cr, cr, MSG_KILLEM, showCrit.Id);
		uint dist=GetCrittersDistantion(cr, showCrit);
		if(cr.ShowCritterDist1  >=dist)
		{

			Map @ map=cr.GetMap();
			if (!valid(map)) return;

			Critter @ [] critters;

			if(map.GetCrittersHex(cr.HexX, cr.HexY, cr._AllyAssistRadius, FIND_LIFE|FIND_ONLY_NPC, critters)==0) return;

			for(uint i=0, iMax=critters.length(); i<iMax; i++)
			{
				if(i>=uint(cr._AssistAlliesNum))  break;
				e_CritterMessage(critters[i], cr, MSG_KILLEM, showCrit.Id);
			}
		}
	}
	bool e_CritterAttacked(Critter& cr, Critter& attacker)
	{
		DL("try heal");
		if(cr.Stat[ST_CURRENT_HP]*100>cr._MustHealLvl*cr.Stat[ST_MAX_LIFE])
		{
			DL("Heal not needed");
			return false;
		}
		_TryHeal(cr);
		return false;
	}
	void e_CritterMessage(Critter& cr, Critter& fromCr, int message, int value)
	{
		switch(message)
		{
			case MSG_KILLEM:
				if(_IsAlly(cr, fromCr))
				{
					if (!cr.IsLife()) return;
					if (!valid(GetCritter(value))) return;
					if (!cr.CheckEnemyInStack(value))
					{
						cr.AddEnemyInStack(value);
						DL("Added enemy: "+value);
					}else{
						DL("Enemy already in stack: "+ value);
					}
				}
				break;
			default:
				break;
		}
	}



	/********************Вспомогательные функции***********************/
	// попытка полечиться, если криттер жив и есть стимпаки
	bool _TryHeal(Critter & cr)
	{
		if (!cr.IsLife()) return false;
		if(cr.CountItem(PID_SUPER_STIMPAK)==0&&Random(1,6)==1&&cr._CanGenStim>1)
		{
			cr.AddItem(PID_SUPER_STIMPAK,1);
			cr._CanGenStim--;
			cr._CanGenStim--;
		}
		if(cr.CountItem(PID_SUPER_STIMPAK)>0)
		{
			Item @ item=cr.GetItem(PID_SUPER_STIMPAK, -1);
			UseDrugOn(cr, cr, item) ;
			_CritAnimateUse(cr);
			DL("SuperStim used");
			return true;
		}
		if(cr.CountItem(PID_STIMPAK)==0&&Random(1,4)==1&&cr._CanGenStim>0)
		{
			cr.AddItem(PID_STIMPAK,1);
			cr._CanGenStim--;
		}
		if(cr.CountItem(PID_STIMPAK)>0)
		{
			Item @ item=cr.GetItem(PID_STIMPAK, -1);
			UseDrugOn(cr, cr, item) ;
			_CritAnimateUse(cr);
			DL("Stim used");
			return true;
		}
		DL("no Stim in bag");

		return false;

	}
	// признак=это свой (та же группа)
	bool _IsAlly(Critter & cr1, Critter & cr2)
	{
		return cr1.TeamId!=0&&cr1.TeamId==cr2.TeamId;
	}
	void DL(string msg)
	{
		//Log(msg);
	}
