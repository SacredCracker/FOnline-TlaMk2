// Author: Atom, cvet, Team mk2
// 21-08-2010 05:09
// vanilla

#include "_macros.fos"
#include "_animation.fos"
#include "_msgstr.fos"
#include "_colors.fos"
#include "_npc_pids.fos"
#include "linetracer_h.fos"

#define ATACK_WAIT_TIME         ( 6 )
#define TIMEOUT_RESTORE_DOOR    ( REAL_MINUTE( 12 ) )
#define HP_DOOR                 ( 250 )
#define HP_SANDBAD              ( 100 )
#define isWeaponPerk            # (i)       ( weaponPerkFirst == i || weaponPerkSecond == i || ammoPerk == i )

#ifdef __CLIENT
# define CritterMutual          CritterCl
# define ItemMutual             ItemCl
# define MapGetCrittersPath     GetCrittersPath
#endif

// Server
#ifndef __CLIENT
# define CritterMutual          Critter
# define ItemMutual             Item
# define MapGetCrittersPath     map.GetCrittersPath
# include "_upgrade_item_defines.fos"

# include "critical_table.fos"
# include "combat_msg.fos"
# include "npc_ai.fos"
# include "combat_h.fos"

// Штраф на процент потенциальных критических пуль
import void critter_attack( Critter& critter, Critter& target ) from "main";
import void DeteriorateItem( Critter& critter, Item& item, int deteriorateCount ) from "Mk2";
import void AffectPoison( Critter& critter, int value ) from "Mk2";
import void AffectRadiation( Critter& critter, int value ) from "Mk2";
import void QuakeScreen( Map& map ) from "effects";
import void FlushScreen( Map& map, uint fromColor, uint toColor, uint timeMs ) from "effects";
import uint GetSmokePenalty( Map& map, Critter& attacker, Critter@ target, uint16 hexX, uint16 hexY ) from "Mk2";
import void SmokeBlast( Map& map, uint16 hexX, uint16 hexY, uint16 smokePid, uint ownerId ) from "Mk2";
import bool reload_weapon( Critter@ critter, Item@ weapon ) from "merc";
import void put_down_weapon( Critter@ critter )  from "merc";
import void lightning_attack( Critter& critter, Critter& target, const ProtoItem& weapon, uint8 weaponMode ) from "lightning_weapon";
import void Explode( Map@ map, uint16 hexX, uint16 hexY, Critter@ critter, uint16 explodePid, uint ownerId, int bonusDamage, int bonusRadius ) from "explode";
import void ChangePlayerScore( Critter& player, uint scoreIndex, int value ) from "Mk2";
import void SetDeleteItem( Item& item, uint delHours ) from "Mk2";
import void SetFire( Map& map, uint16 hx, uint16 hy, uint16 radius, uint16 damage, Critter@ critter ) from "Mk2";

// CTE_END_BATTLE
uint cte_EndBattle( Critter& critter, int identifier, int& rate, int& )
{
    critter.RefreshSpeed();
    return 0;
}

enum ETypeAttack
{
    TypeAttack_None,
    TypeAttack_Melee,
    TypeAttack_Normal,
    TypeAttack_Flame,
    TypeAttack_Burst,
    TypeAttack_RocketsThrowing,
    TypeAttack_End
}

CombatProccess@ GetCombatProccess( )
{
	return null;
}

void EventSmthAttack( Critter@ attacker, Critter@ target )
{
	if( attacker.Id != target.Id )
	{						
		Critter@ lookCritter = null;
		Critter@[] lookCritters;
		for( uint i = 0, iMax = attacker.GetCritters( true, FIND_ALL, @lookCritters ); i < iMax; i++ )
		{
			@lookCritter = lookCritters[ i ];
			lookCritter.EventSmthAttack( attacker, target );
			lookCritter.EventSmthAttacked( target, attacker );
		}
	}
}

CombatAlgoritm@ GetCombatAlgoritm( CombatProccess@ proccess )
{
	CombatAlgoritm@ result = null;
	
	if( proccess.ScoreUnarmed)
	{
		@result = CombatAlgoritm_Unarmed();
	}
	else switch( proccess.WeaponSubtype )
	{
		case WS_GUN:
			if( proccess.IsBurst )
				@result = CombatAlgoritm_Burst();
			else	@result = CombatAlgoritm_GunNormal();
			break;
		
		case WS_THROWING:
			@result = CombatAlgoritm_Throwing();
			break;
			
		default: break;
	}
	
	@result.proccess = proccess;
	return result;
}

class CombatAlgoritm
{
	void Proccess()
	{
		@normalTarget = null;
	}

	uint rounds;
	Critter@ realTarget;
	Critter@ normalTarget;
	uint8 weaponUse;
	uint8 weaponMode;
	int baseToHit;
	int distmod1;
	int distmod2;
	int accloss;
	bool isCritical;
	bool isHit;
	CombatRes[]@ results;
	bool changedTarget;
	bool useHex;
	bool useNormal;
	CombatProccess@ proccess;
}

class CombatAlgoritm_GunNormal : CombatAlgoritm
{
	void Proccess()
	{
		uint countShot = proccess.IsWeaponPerk( WEAPON_PERK_DOUBLE_SHOT ) ? 2 : 1;
		ProtoItem@ weapon = GetProtoItem( proccess.WeaponPid );
		uint16 ammoRound = _WeaponRound( weapon, weaponUse ) * countShot;
		int dist = proccess.Distantion;
		Map@ map = realTarget.GetMap();
        if( isHit || changedTarget )
        {
            if( proccess.IsWeaponPerk( WEAPON_PERK_LIGHTNING_WEAPON ) )
                lightning_attack( proccess.Attacker, realTarget, weapon, weaponMode );
            if( proccess.IsWeaponPerk( WEAPON_PERK_LIGHTNING_WEAPON ) || !proccess.IsLeon( realTarget, dist ) )
            {
                if( proccess.TypeDamage == DAMAGE_EXPLODE )
                    map.RunEffect( PID_EXPLODE_ROCKET, realTarget.HexX, realTarget.HexY, 0, 0 );
                ApplyDamage( proccess, realTarget, countShot, isCritical && isHit, !changedTarget, results );
            }
            else
                proccess.startLeon( realTarget, results );
        }
        else             // standard miss here
        {
            Critter@[] critsLine;
            proccess.Aim = HIT_LOCATION_UNCALLED;
            int  bl = 0;
            bool anyHit = false;
			Critter@ crForI = null;
			int acc = 0;
			int toHit = 0;
			int perception = proccess.Attacker.Stat[ST_PERCEPTION];
			int sharpshooter = 4 * proccess.Attacker.Perk[ PE_SHARPSHOOTER ];
			bool eyeDamage = proccess.Attacker.Damage[ DAMAGE_EYE ] != 0;
			
			Critter@ target = GetCritter( proccess.TargetId );
			int bonusToHit = weapon.Weapon_BonusToHit;
			if( validEngineObject( proccess.RealWeapon ) )
				bonusToHit += proccess.RealWeapon.WeaponBonus_ToHit;
			int wpnMaxDist = ( _WeaponSkill( weapon, weaponUse ) == SK_THROWING ) ? ( MIN( int( _WeaponMaxDist( weapon, weaponUse ) ), 3 * MIN( int(10), ( proccess.Attacker.Stat[ ST_STRENGTH ] + 2 * proccess.Attacker.Perk[ PE_HEAVE_HO ] ) ) ) ) : ( _WeaponMaxDist( weapon, weaponUse ) );
			for( int i = 0, iMax = map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine ); ( i < iMax ) && !anyHit; i++ )
            {
				@crForI = critsLine[ i ];
				if( proccess.IsLeon( crForI, dist ) )
				{
					proccess.startLeon( crForI, results );
					continue;
				}
				if( crForI.Id == realTarget.Id )
				{
					bl++;
					continue;
				}                                             // skip the primary target
				// adjust tohit
				dist = GetDistantion( proccess.Hx, proccess.Hy, crForI.HexX, crForI.HexY );
				acc = dist;
				toHit = baseToHit;
				if( dist < distmod2 )
					acc += distmod2;
				else
					acc -= accloss;
				if( -2 * perception > acc )
					acc = -2 * perception;
				acc -= sharpshooter;
				if( acc > 0 && eyeDamage )
					acc *= 3;
				acc *= -4;
				toHit += acc;
				toHit -= 10 * bl;
				if( crForI.IsKnockout() )
					toHit += 40;
				else
					bl++;
				if( crForI.GetMultihex() > 0 )
					toHit += 15;
				toHit += bonusToHit;
				toHit = CLAMP( toHit, 5, 95 );
				toHit /= 3;                   // after clamp
				if( Random( 1, 100 ) <= toHit )
				{
					NotifyOops( proccess.Attacker, target, crForI, results );
					@normalTarget = crForI;
					useNormal = true;
					ApplyDamage( proccess, normalTarget, countShot, false, false, results );
					anyHit = true;
				}
			}
			if( !anyHit )
				NotifyMiss( proccess.Attacker, results );
		}
	}
}

class CombatAlgoritm_Throwing : CombatAlgoritm
{
	void Proccess()
	{
		ProtoItem@ weapon = GetProtoItem( proccess.WeaponPid );
		int dist = proccess.Distantion;
		int sharpshooter = 4 * proccess.Attacker.Perk[ PE_SHARPSHOOTER ];
		Map@ map = realTarget.GetMap();
		int wpnMaxDist = ( _WeaponSkill( weapon, weaponUse ) == SK_THROWING ) ? ( MIN( int( _WeaponMaxDist( weapon, weaponUse ) ), 3 * MIN( int(10), ( proccess.Attacker.Stat[ ST_STRENGTH ] + 2 * proccess.Attacker.Perk[ PE_HEAVE_HO ] ) ) ) ) : ( _WeaponMaxDist( weapon, weaponUse ) );
		if( proccess.IsLeon( realTarget, dist ) )
            proccess.startLeon( realTarget, results );
        else if( isHit || changedTarget )
            ApplyDamage( proccess, realTarget, 1, isCritical && isHit, !changedTarget, results );
        else
        {
            proccess.Aim = HIT_LOCATION_UNCALLED;
            sharpshooter = 0;
            uint16 bx = 0,
                   by = 0,
                   pbx = 0,
                   pby = 0;
            Critter@[] critsLine;

            int  bl = 0;
            bool anyHit = false;
			Critter@ crForI = null;
			int acc = 0;
			int toHit = 0;
			int perception = proccess.Attacker.Stat[ST_PERCEPTION];
			bool eyeDamage = proccess.Attacker.Damage[ DAMAGE_EYE ] != 0;
			int bonusToHit = weapon.Weapon_BonusToHit;
			Critter@ target = GetCritter( proccess.TargetId );
			if( validEngineObject( proccess.RealWeapon ) )
				bonusToHit += proccess.RealWeapon.WeaponBonus_ToHit;
            for( int i = 0, iMax = map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine, pbx, pby, bx, by ); ( i < iMax ) && !anyHit; i++ )
            {
                @crForI = critsLine[ i ];

                if( crForI.Id == realTarget.Id )
                {
                    bl++;
                    continue;
                }                                                              // skip the primary target

                if( proccess.IsLeon( crForI, dist ) )
                {
                    proccess.startLeon( crForI, results );
                    continue;
                }

                // adjust tohit
                dist = GetDistantion( proccess.Hx, proccess.Hy, crForI.HexX, crForI.HexY );
                acc = dist;
                toHit = baseToHit;
                if( dist < distmod2 )
                    acc += distmod2;
                else
                    acc -= accloss;
                if( -2 * perception > acc )
                    acc = -2 * perception;
                acc -= sharpshooter;
                if( acc > 0 && eyeDamage )
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                toHit -= 10 * bl;
                if( crForI.IsKnockout() )
                    toHit += 40;
                else
                    bl++;
                if( crForI.GetMultihex() > 0 )
                    toHit += 15;
                toHit += bonusToHit;
                toHit = CLAMP( toHit, 5, 95 );
                toHit /= 3;               // after clamp
                if( Random( 1, 100 ) <= toHit )
                {
                    proccess.TargetHx = crForI.HexX;
                    proccess.TargetHy = crForI.HexY;
                    @normalTarget = crForI;
                    anyHit = true;
                }
            }
            if( anyHit )
            {
                NotifyOops( proccess.Attacker, target, normalTarget, results );
                useNormal = true;
                ApplyDamage( proccess, normalTarget, 1, false, false, results );
            }
            else
            {
                useHex = true;
                NotifyMiss( proccess.Attacker, results );
                proccess.TargetHx = pbx;
                proccess.TargetHy = pby;
            }
        }                                     // miss
	}
}

class CombatAlgoritm_Unarmed : CombatAlgoritm
{
	void Proccess()
	{
		int dist = proccess.Distantion;
		if( proccess.IsLeon( realTarget, dist ) )
            proccess.startLeon( realTarget, results );  // TabaK. Уворот от рукопашной атаки. хз, надо ли.
        else if( isHit )
        {
			Critter@ target = GetCritter( proccess.TargetId );
            if( proccess.Attacker.Mode[ MODE_HIDE ] != 0 && proccess.Attacker.Perk[ PE_SILENT_DEATH ] != 0 && ( proccess.Attacker.Dir == target.Dir || ( ( proccess.Attacker.Dir + 1 ) % 6 ) == target.Dir || ( ( proccess.Attacker.Dir + 5 ) % 6 ) == target.Dir ) )
            {
                proccess.Attacker.ModeBase[ MODE_HIDE ] = 0;
                proccess.DmgMul *= 2;
            }
            ApplyDamage( proccess, realTarget, 1, isCritical && isHit, true, results );
        }
        else
        {
            if( changedTarget )
                ApplyDamage( proccess, realTarget, 1, false, false, results );
            else
                NotifyMiss( proccess.Attacker, results );
        }
	}
}

class BurstHitData
{
	uint rounds = 0;
	uint leon = 0;
}

class CombatAlgoritm_Burst : CombatAlgoritm
{
	uint countHitTargets;
	Critter@[] critsHit;
    BurstHitData@[] critsHitBullets;;

	uint StartRounds;

	float penaltySecondTargets = 0.6;
	float penaltyEffectSecondTargets = 1.0;
    int modeToHitForNextBulets = 8;
		
	CombatAlgoritm_Burst()
	{
		Clear();
		rounds = 0;
	}
		
	void Clear( )
	{
		countHitTargets = 0;
		critsHit.resize(0);
		critsHitBullets.resize(0);
	}
		
	void AddTarget( Critter& critter, BurstHitData& data )
	{
		critsHit.insertFirst( critter );
        critsHitBullets.insertFirst( data );
        countHitTargets++;
		rounds -= data.rounds;
	}
	
	bool CritterIsTarget( Critter& critter )
	{
		return FindCritterInArray( critsHit, critter ) != -1;
	}

	void Proccess( )
	{
		Clear();
        bool criticalHit = isCritical && isHit;
		// adjust toHit if random hit

		ProtoItem@ weapon = GetProtoItem( proccess.WeaponPid );
		int bonusToHit = weapon.Weapon_BonusToHit + proccess.RealWeapon.WeaponBonus_ToHit;
		
		if( rounds > _WeaponRound( weapon, weaponUse ) )
			rounds = _WeaponRound( weapon, weaponUse );
		
		// proceed with the burst proccess
		if( proccess.RealWeapon.AmmoCount < rounds )
			rounds = proccess.RealWeapon.AmmoCount;
		StartRounds = rounds;
		
		Map@ map = proccess.Attacker.GetMap();
		
        if( realTarget !is null )
		{
			if( !ParseTarget( realTarget, map, bonusToHit, penaltyEffectSecondTargets, false ) )
				criticalHit = false;
		}
		
		uint8 angle_effect = _WeaponAngleEffective( weapon, weaponUse );
		uint8 angle_second = _WeaponAngleSecond( weapon, weaponUse );
		
		int wpnMaxDist = ( _WeaponSkill( weapon, weaponUse ) == SK_THROWING ) ? ( MIN( int( _WeaponMaxDist( weapon, weaponUse ) ), 3 * MIN( int(10), ( proccess.Attacker.Stat[ ST_STRENGTH ] + 2 * proccess.Attacker.Perk[ PE_HEAVE_HO ] ) ) ) ) : ( _WeaponMaxDist( weapon, weaponUse ) );
        ParseAngle( map, bonusToHit, penaltyEffectSecondTargets, 0 - angle_effect, angle_effect, wpnMaxDist, false );
		if( angle_second > angle_effect )
		{
			ParseAngle( map, bonusToHit, penaltySecondTargets, Random( 0 - angle_second, -1 - angle_effect ), 0 - angle_effect, wpnMaxDist, false );
			ParseAngle( map, bonusToHit, penaltySecondTargets, angle_effect, Random( angle_effect + 1, angle_second ), wpnMaxDist, false );
		}
        Damage( map, criticalHit );
		
        if( !proccess.TargetHit && proccess.TargetId != 0 )
            NotifyMiss( proccess.Attacker, results );
	}

	void ParseAngle( Map@ map, int bonusToHit, float hitModule, int angleBegin, int angleEnd, int distance, bool stopBurst )
	{
		Critter@[] sTargets;
		
		angleEnd++;
		for( int angle = angleBegin; angle < angleEnd; angle++ )
			map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, float( angle ), distance, FIND_LIFE_AND_KO, sTargets );
		
        Parse( map, sTargets, bonusToHit, penaltySecondTargets, stopBurst );
	}
	
	void Damage( Map@ map, bool criticalHit )
	{
		Critter@ target = GetCritter( proccess.TargetId );
		Critter@ crForI = null;
		const uint realTargId = realTarget is null ? 0 : realTarget.Id;
		DebugTraccer traccer;
		traccer.AttackerId = proccess.Attacker.Id;
		traccer.CountRounds = StartRounds;
        for( uint i = 0; i < countHitTargets; i++ )
        {
            @crForI = critsHit[ i ];
            if( proccess.TypeDamage == DAMAGE_EXPLODE )
                map.RunEffect( PID_EXPLODE_ROCKET, crForI.HexX, crForI.HexY, 0, 0 );

			BurstHitData@ data = critsHitBullets[ i ];
			traccer.TargetId = crForI.Id;
			traccer.HitRounds = data.rounds;
			traccer.LeonRounds = data.leon;
			
			if( proccess.Attacker.IsPlayer() )
				proccess.Attacker.Send( traccer );
			if( crForI.IsPlayer() )
				crForI.Send( traccer );
			
			if( data.rounds != 0 )
			{
				if( target !is null && target.Id == crForI.Id ) proccess.TargetHit = true;
				ApplyDamage( proccess, crForI, data.rounds, ( realTargId == crForI.Id ) && criticalHit, ( proccess.Attacker.IsPlayer() && !changedTarget ) || ( !proccess.Attacker.IsPlayer() && target !is null && target.Id == crForI.Id ), results );
			}
        }
	}
	
	bool ParseTarget( Critter& target, Map@ map, int bonusToHit, float hitModule, bool stopBurst )
	{
		if( CritterIsTarget( target) )
			return false;
	
		const int perception = proccess.Attacker.Stat[ST_PERCEPTION] * -2;
		const int sharpshooter = 4 * proccess.Attacker.Perk[ PE_SHARPSHOOTER ];
		const bool eyeDamage = proccess.Attacker.Damage[ DAMAGE_EYE ] != 0;
		// adjust tohit
        int toHit = baseToHit * hitModule;
		int distantion = GetDistantion( proccess.Hx, proccess.Hy, target.HexX, target.HexY );
		int acc = distantion;
		if( distantion < distmod2 )
			acc += distmod2;
		else
			acc -= accloss;
		if( perception > acc )
			acc = perception;
		acc -= sharpshooter;
		if( acc > 0 && eyeDamage )
			acc *= 3;
		acc *= -4;
		toHit += acc;
		toHit += bonusToHit;
		if( target.IsKnockout() )
			toHit += 40;
				
		if( target.GetMultihex() > 0 )
			toHit += 15;
					
		toHit -= 10 * map.GetCrittersPath( proccess.Hx, proccess.Hy, target.HexX, target.HexY, 0.0f, distantion, FIND_LIFE, null );
					
		int penalty = GetSmokePenalty( map, proccess.Attacker, target, 0, 0 );
		penalty += int( log( float(distantion) ) / log( 2.0f ) ) * 15;
			
		uint curRounds = 0;
		BurstHitData data;
		LeonHash leon( target, distantion );
		
		for( ;curRounds < rounds;)
		{
			curRounds++;
			if( Random( 0, 99 ) <= CLAMP( toHit - modeToHitForNextBulets * curRounds, 5, 95 - penalty ) )
			{
				if( !leon.Is( ) )
					data.rounds++;
				else data.leon++;
			}
			else if( stopBurst || baseToHit * 0.1 + 50 < Random( 0, 99 ) )
				break;
		}
			
		if( data.rounds != 0 || data.leon != 0 )
		{
			AddTarget( target, data );
			return true;
		}
		return false;
	}
	
	void Parse( Map@ map, Critter@[]& sTargets, int bonusToHit, float hitModule, bool stopBurst )
	{
		uint countTargets = sTargets.length();
		Critter@ crForI = null;
        for( uint i = Random( 0, countTargets - 1 ); countTargets > 0 && rounds > 0; i = Random( 0, countTargets - 1 ) )
        {
            @crForI = sTargets[ i ];
			sTargets.removeAt(i);
			countTargets--;
			ParseTarget( crForI, map, bonusToHit, hitModule, stopBurst);
        }
	}
}

void startCombatTimeout( Critter& target, bool sneak = true )
{
	if( target.IsNpc() || target.GetAccess() != ACCESS_ADMIN )
	{
		int targetTimeout = BATTLE_TIMEOUT( target );
		Item@ targetArmor = _CritGetItemArmor( target );

		if( validEngineObject( targetArmor ) )
			targetTimeout -= REAL_SECOND( targetArmor.Proto.BonusForOutOfCombat );

		if( __FullSecond + REAL_SECOND( 5 ) > uint( targetTimeout ) )
			targetTimeout = __FullSecond + REAL_SECOND( 5 );
		if( target.Timeout[ TO_BATTLE ] < targetTimeout - __FullSecond )
		{
			target.TimeoutBase[ TO_BATTLE ] = targetTimeout;
			uint[] indexes;
			if( target.GetTimeEvents( CTE_END_BATTLE, indexes ) > 0 )
				target.ChangeTimeEvent( indexes[ 0 ], targetTimeout - __FullSecond, 0, 0 );
			else
				target.AddTimeEvent( "cte_EndBattle", targetTimeout - __FullSecond, CTE_END_BATTLE );
		}
		target.RefreshSpeed();
		if( sneak )
			target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
	}
}

void CombatAttack( Critter& attacker, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo ) // Export
{
    CombatProccess@ proccess = CombatProccess();
    @proccess.Attacker = attacker;

    uint8 use = _WeaponModeUse( weaponMode );

	if( ammo is null )
	{
		proccess.TypeDamage = _WeaponDmgType( weapon, use );
		proccess.AmmoPid = 0;
	}
	else
	{
		proccess.TypeDamage = ammo.Ammo_DmgType != 0 ? ammo.Ammo_DmgType : _WeaponDmgType( weapon, use );
		proccess.AmmoPid = ammo.ProtoId;
	}
    

    int skillNum = _WeaponSkill( weapon, use ),
        wpnMaxDist = ( skillNum == SK_THROWING ) ? ( MIN( int( _WeaponMaxDist( weapon, use ) ), 3 * MIN( int(10), ( proccess.Attacker.Stat[ ST_STRENGTH ] + 2 * proccess.Attacker.Perk[ PE_HEAVE_HO ] ) ) ) ) : ( _WeaponMaxDist( weapon, use ) ),
        criticalChance = 0,
        baseToHit = proccess.Attacker.Skill[ skillNum ];

    proccess.WeaponSubtype =
        ( skillNum == SK_DOCTOR || skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS )
        ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );

    proccess.ScoreUnarmed = ( proccess.WeaponSubtype == WS_UNARMED );
    uint16 ammoRound = _WeaponRound( weapon, use );

    proccess.Hx = proccess.Attacker.HexX;
    proccess.Hy = proccess.Attacker.HexY;
    proccess.TargetHx = target.HexX;
    proccess.TargetHy = target.HexY;

    proccess.Attacker.SetDir( GetDirection( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy ) );

    bool isHit = false,
         isGrenade = proccess.WeaponSubtype == WS_THROWING && proccess.TypeDamage != DAMAGE_NORMAL,
         isCritical = false,
         hitRandomly = false,
         eyeDamage = proccess.Attacker.Damage[ DAMAGE_EYE ] != 0,
         crIsPlayer = proccess.Attacker.IsPlayer();

    proccess.IsBurst = ( ammoRound > 1 ) && _WeaponNoBrust( weapon, use ) != 1;

    proccess.Aim = proccess.IsBurst ? HIT_LOCATION_UNCALLED : ( ( _WeaponModeAim( weaponMode ) == HIT_LOCATION_EYES && ( proccess.Attacker.Dir + 3 ) % 6 != target.Dir ) ? HIT_LOCATION_HEAD : _WeaponModeAim( weaponMode ) );

    Critter@ realTarget = null;

    // main proccess structure
    @proccess.RealWeapon = _CritGetItemHand( proccess.Attacker );
    proccess.WeaponPid = weapon.ProtoId;
    proccess.BloodyMess = proccess.Attacker.Trait[ TRAIT_BLOODY_MESS ] != 0;
    proccess.CombatMessage = true;
    proccess.FirstWeaponPerk = ( proccess.ScoreUnarmed && weapon.Weapon_UnarmedArmorPiercing ) ? WEAPON_PERK_PENETRATE : weapon.Weapon_Perk;
    proccess.SecondWeaponPerk = ( proccess.ScoreUnarmed && weapon.Weapon_UnarmedArmorPiercing ) ? WEAPON_PERK_PENETRATE : weapon.Weapon_SecondPerk;
    proccess.AmmoPerk = ( ammo !is null ) ? int(ammo.Ammo_Perk) : -1;
    proccess.DmgMin = _WeaponDmgMin( weapon, use );
    proccess.DmgMax = _WeaponDmgMax( weapon, use );
    proccess.BonusDmg = 0;

    if( !proccess.IsBurst && validEngineObject( proccess.RealWeapon ) && ammoRound > proccess.RealWeapon.AmmoCount )
    {
        proccess.Attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_OUT_OF_AMMO );
        return;
    }

    if( ( proccess.WeaponPid == PID_FLAMER ) || ( proccess.WeaponPid == PID_IMPROVED_FLAMETHROWER ) || ( proccess.WeaponPid == PID_FIRE_GECKO_FLAME_WEAPON ) || ( proccess.WeaponPid == PID_FLAMER_MK3 ) || ( proccess.WeaponPid == PID_FIRE_GECKO_FLAME_WEAPON_LIGHT ) )
        proccess.TypeAttack = ETypeAttack::TypeAttack_Flame;

    CombatRes[] results;
    if( target.IsNpc() || ( target.IsPlayer() && target.GetAccess() != ACCESS_ADMIN ) )
        target.ModeBase[ MODE_HIDE ] = 0;

    startCombatTimeout( proccess.Attacker, false );

    proccess.Attacker.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( proccess.Attacker );

    if( crIsPlayer )   // leaderboard
    {
        if( proccess.WeaponSubtype == WS_GUN )
            ChangePlayerScore( proccess.Attacker, SCORE_SHOOTER, 1 );
        else if( skillNum == SK_UNARMED || skillNum == SK_THROWING )
            ChangePlayerScore( proccess.Attacker, SCORE_UNARMED, 1 );
    }
    else
        AI_TrySayCombatText( proccess.Attacker, COMBAT_TEXT_ATTACK );  // Npc proccess text

    target.EventAttacked( proccess.Attacker );                         // Add event, always
    // baseToHit used for all targets, adjusted for distance and other target-dependent qualities every time it is necessary
    if( eyeDamage )
        baseToHit -= 25;
    if( proccess.Attacker.Perk[ PE_VAMPIRE_ACCURACY ] > 0 && IS_NIGHT( __Hour ) )
        baseToHit += 13;                                                      // Quest perk

    if( !proccess.ScoreUnarmed )
    {
        if( proccess.Attacker.Trait[ TRAIT_ONE_HANDER ] != 0 )
            baseToHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );
        int handlingStrength = proccess.Attacker.Stat[ ST_STRENGTH ] + proccess.Attacker.Perk[ PE_WEAPON_HANDLING ] * 3 +
                               ( ( proccess.Attacker.Trait[ TRAIT_ONE_HANDER ] != 0 && !FLAG( weapon.Flags, ITEM_TWO_HANDS ) ) ? 1 : 0 ) -
                               proccess.Attacker.Trait[ TRAIT_SMALL_FRAME ] * 2,
            reqStrength = weapon.Weapon_MinStrength;
        if( handlingStrength < reqStrength )
            baseToHit -= ( reqStrength - handlingStrength ) * 20;
    }

    if( proccess.RealWeapon !is null )
    {
        proccess.DmgMin += proccess.RealWeapon.WeaponBonus_MinDamage;
        proccess.DmgMax += proccess.RealWeapon.WeaponBonus_MaxDamage;
    }

    // proccess.ReasonMiss=missSkill?MissReason_SkillLionhead:MissReason_None;
    if( proccess.ScoreUnarmed )
    {
        proccess.BonusDmg += proccess.Attacker.Stat[ ST_MELEE_DAMAGE ];
        proccess.TypeAttack = ETypeAttack::TypeAttack_Melee;
    }
    else if( proccess.WeaponSubtype == WS_THROWING )
        proccess.BonusDmg += proccess.Attacker.Stat[ ST_THROWING_DAMAGE ];
    else if( proccess.WeaponSubtype == WS_GUN )
        proccess.BonusDmg += proccess.Attacker.Perk[ PE_BONUS_RANGED_DAMAGE ] * 2;

    // Ammo
    if( ammo !is null )
    {
        proccess.DRMod = ammo.Ammo_DrMod;
        proccess.DMMod = ammo.Ammo_DmgMult;
        proccess.DDMod = ammo.Ammo_DmgDiv;
        proccess.TDMod = ammo.Ammo_DTDiv;
    }
    proccess.DmgMul = proccess.DMMod;

    // to check if the target was hit:
    proccess.TargetId = target.Id;

    // here we're deciding the real toHit;
    int  dist = proccess.Distantion;

    Map@ map = proccess.Attacker.GetMap();
    if( validEngineObject( map ) )
        if( dist > 1 )
        {
            uint16 _hx = proccess.TargetHx, _hy =  proccess.TargetHy;
            map.MoveHexByDir( _hx, _hy, GetDirection( proccess.TargetHx, proccess.TargetHy, proccess.Hx, proccess.Hy ), 1 );
            if( !map.IsHexPassed( _hx, _hy ) )
            {
                baseToHit -= 120;
            }
            else if( dist > 2 )
            {
                _hx = proccess.TargetHx;
                _hy = proccess.TargetHy;
                map.MoveHexByDir( _hx, _hy, GetDirection( proccess.TargetHx, proccess.TargetHy, proccess.Hx, proccess.Hy ), 2 );
                if( !map.IsHexPassed( _hx, _hy ) )
                {
                    baseToHit -= 85;
                }
                else if( dist > 3 )
                {
                    _hx = proccess.TargetHx;
                    _hy = proccess.TargetHy;
                    map.MoveHexByDir( _hx, _hy, GetDirection( proccess.TargetHx, proccess.TargetHy, proccess.Hx, proccess.Hy ), 3 );
                    if( !map.IsHexPassed( _hx, _hy ) )
                    {
                        baseToHit -= 50;
                    }
                }
            }
        }

    int toHit = baseToHit,
        bonusToHit = weapon.Weapon_BonusToHit,
    // range considerations, we're storing everything for a later use
        distmod1 = 2, // used for initial weapon bonus
        distmod2 = 0; // minimal distance
    if( validEngineObject( proccess.RealWeapon ) )
        bonusToHit += proccess.RealWeapon.WeaponBonus_ToHit;

    toHit -= proccess.ScoreUnarmed ? ( GetHitAim( proccess.Aim ) * 0.5 ) : GetHitAim( proccess.Aim );

    if( proccess.IsWeaponPerk( WEAPON_PERK_LONG_RANGE ) )
        distmod1 = 4;
    else if( proccess.IsWeaponPerk( WEAPON_PERK_SCOPE_RANGE ) )
    {
        distmod1 = 5;
        distmod2 = 5;
    }

    int perception = proccess.Attacker.Stat[ ST_PERCEPTION ],
        acc = dist,
        accloss = ( crIsPlayer ? ( perception - 2 ) * distmod1 : ( perception * distmod1 ) ),
        sharpshooter = 4 * proccess.Attacker.Perk[ PE_SHARPSHOOTER ];

    if( !proccess.ScoreUnarmed )
    {
        if( dist < distmod2 )
            acc += distmod2;
        else
            acc -= accloss;
        if( -2 * perception > acc )
            acc = -2 * perception;
        acc -= sharpshooter;
        if( acc > 0 && eyeDamage )
            acc *= 3;
        acc *= -4;
        toHit += acc;
        int blockers = map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0.0f, dist, FIND_LIFE, null );
        if( !target.IsKnockout() )
            blockers--;
        toHit -= 10 * blockers;
    }

    if( target.IsKnockout() )
        toHit += 40;
    if( target.GetMultihex() > 0 )
        toHit += 15;

    toHit += bonusToHit;
    toHit = CLAMP( toHit, 5, 95 );

    // smoke penalty
    if( !proccess.ScoreUnarmed && proccess.TypeAttack != ETypeAttack::TypeAttack_Flame )
        toHit -= GetSmokePenalty( map, proccess.Attacker, target, 0, 0 );
    // main roll
    int margin = toHit - Random( 1, 100 );

    // Дополнительная обработка трейта Jinxed
    if( margin > 0 && ( proccess.Attacker.Trait[ TRAIT_JINXED ] != 0 || proccess.Attacker.Perk[ PE_JINXED_II ] != 0 || target.Trait[ TRAIT_JINXED ] != 0 || target.Perk[ PE_JINXED_II ] != 0 ) && Random( 1, 100 ) <= 5 )
    {
        margin = -1;
        isCritical = true;
    }
	
    uint     critfailFlags = 0;
    if( margin < 0 ) // if missed
    {
        // not setting isHit, we try a critical failure
        if( proccess.Attacker.Mode[ MODE_INVULNERABLE ] == 0 )
        {
            if( !isCritical )
                isCritical = ( ( -margin ) * 0.1 >= Random( 1, 100 ) );
            if( isCritical )
            {
                int roll = Random( 1, 100 ) - 5 * ( proccess.Attacker.Stat[ ST_LUCK ] - 5 );
                if( roll <= 20 )
                    roll = 0;
                else if( roll <= 50 )
                    roll = 1;
                else if( roll <= 75 )
                    roll = 2;
                else if( roll <= 95 )
                    roll = 3;
                else
                    roll = 4;
                critfailFlags = CriticalFailureTable[ 5 * weapon.Weapon_CriticalFailture + roll ];
                if( critfailFlags == 0 )
                    isCritical = false;
                hitRandomly = FLAG( critfailFlags, MF_HIT_RANDOMLY );
            }
        }
    }     //
    else  // if hit
    {
        isHit = true;
        // неприцельный выстрел
        if( proccess.Aim == HIT_LOCATION_UNCALLED || proccess.Aim == HIT_LOCATION_NONE || proccess.Aim == HIT_LOCATION_TORSO )
            criticalChance = proccess.Attacker.Stat[ ST_CRITICAL_CHANCE ];
        // прицельный выстрел
        else
        {
            criticalChance = proccess.Attacker.Stat[ ST_CRITICAL_CHANCE ] + proccess.Attacker.Stat[ ST_LUCK ] * 2 + ( ( ( proccess.WeaponSubtype == WS_GUN && proccess.Attacker.Perk[ PE_SNIPER ] != 0 ) ||
                                                                                          ( ( proccess.ScoreUnarmed || proccess.WeaponSubtype == WS_THROWING ) && proccess.Attacker.Perk[ PE_SLAYER ] != 0 ) ) ? GetBonusCriticalChanceForHitAim( proccess.Aim ) : 0 );
            if( proccess.ScoreUnarmed )
                criticalChance += proccess.Attacker.Stat[ ST_LUCK ] * 2;                           // Повышенный бонус шанса за крит при рукопашной атаке
        }
        switch( skillNum )
        {
        case SK_SMALL_GUNS:
        case SK_BIG_GUNS:
        case SK_ENERGY_WEAPONS:
            criticalChance += proccess.Attacker.BookBonus[ BB_RANGED_CRIT ];
            break;                                                                                   // бонус от книг. ++Cracker
        case SK_UNARMED:
        case SK_THROWING:
            criticalChance += proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT ];
            break;                                                                                          // бонус от книг. ++Cracker
        default:
            break;
        }
        if( weapon.Weapon_UnarmedCriticalBonus > 0 )
            criticalChance += ( weapon.Weapon_UnarmedCriticalBonus );
        if( proccess.IsWeaponPerk( WEAPON_PERK_SCOPE_RANGE ) )
            criticalChance += 15;
        if( validEngineObject( proccess.RealWeapon ) )
            criticalChance += proccess.RealWeapon.WeaponBonus_CritChance + weapon.Weapon_CriticalBonus;
        int critRand = Random( 1, 100 ), critResRand = Random( 1, 100 );
        isCritical = ( critRand <= criticalChance );
        if( isCritical && critResRand <= target.Stat[ ST_CRITICAL_RESISTANCE ] - ( criticalChance > 100 ? ( criticalChance - 100 ) : 0 ) )
            isCritical = false;

        /*if(	target.Stat[ST_CURRENT_ARMOR_PERK]==ARMOR_PERK_POWERED ||
                target.Stat[ST_CURRENT_ARMOR_PERK]==ARMOR_PERK_POWERED_II ||
                target.Stat[ST_CURRENT_ARMOR_PERK]==ARMOR_PERK_ADVANCED_I ||
                target.Stat[ST_CURRENT_ARMOR_PERK]==ARMOR_PERK_ADVANCED_II ||
                target.Stat[ST_CURRENT_ARMOR_PERK]==ARMOR_PERK_SENTRY_BOTS )
                        Log( "Crit param check:	criticalChance " + criticalChance +
                                                                    " target.Stat[ST_CRITICAL_RESISTANCE] " + target.Stat[ST_CRITICAL_RESISTANCE] +
                                                                        " isCritical " +(  isCritical ? "yes" : "no" ) +
                                                                        " critResRand " + critResRand +
                                                                        " critRand " + critRand );*/
    }

    if( hitRandomly )
    {
        Critter@ randomTarget = ChooseRandomTarget( map, proccess.Attacker, target, wpnMaxDist );
        if( validEngineObject( randomTarget ) )
        {
            @realTarget = randomTarget;
            proccess.TargetHx = realTarget.HexX;
            proccess.TargetHy = realTarget.HexY;
            proccess.Aim = HIT_LOCATION_UNCALLED;
            if( realTarget.IsNpc() || realTarget.GetAccess() != ACCESS_ADMIN )
                realTarget.ModeBase[ MODE_HIDE ] = 0;             // done here to allow combat notifications later
            NotifyOops( proccess.Attacker, target, realTarget, results );
        }
    }
    else
        @realTarget = target;

    // initial animations
    proccess.Attacker.Action( ACTION_USE_WEAPON, ( ( ( !isHit && isCritical && !hitRandomly ) ? 1 : 0 ) << 8 ) | ( proccess.Aim << 4 ) | use, proccess.RealWeapon );

    // animations are now played, and we're updating the hit randomly status now
    bool changedTarget = ( hitRandomly && validEngineObject( realTarget ) );

    // commencing critical failures
    if( !isHit && isCritical && ( !hitRandomly  || !validEngineObject( realTarget ) ) )
    {
        if( proccess.Attacker.IsPlayer() )
            proccess.Attacker.Say( SAY_NETMSG, "CriticalFailure. Your proccess cancelled" );
        CriticalFailure( proccess.Attacker, weapon, use, ammo, critfailFlags, results );
        return;
    }

    // commencing proccess, various instances
    int  crDir = proccess.Attacker.Dir,
         tDir = realTarget.Dir;
    bool criticalHit = isHit && isCritical,
         isSilentAtack = ( crDir == tDir || ( ( crDir + 1 ) % 6 ) == tDir || ( ( crDir + 5 ) % 6 ) == tDir );

    // always unsneak
    if( proccess.Attacker.Mode[ MODE_HIDE ] != 0 && !( proccess.IsWeaponPerk( WEAPON_PERK_SOUNDLESS ) && ( ( proccess.Attacker.Perk[ PE_SILENT_DEATH ] != 0 && isSilentAtack ) || proccess.Distantion > 5 ) ) && ( proccess.Attacker.IsNpc() || proccess.Attacker.GetAccess() != ACCESS_ADMIN ) )
        proccess.Attacker.ModeBase[ MODE_HIDE ] = 0;
    if( realTarget.IsNpc() || realTarget.GetAccess() != ACCESS_ADMIN )
        realTarget.ModeBase[ MODE_HIDE ] = 0;
	
	CombatAlgoritm@ algoritm = GetCombatAlgoritm( proccess );
	if( algoritm !is null )
	{
		@algoritm.realTarget = realTarget;
		@algoritm.results = results;
		algoritm.weaponUse = use;
		algoritm.baseToHit = baseToHit;
		algoritm.distmod1 = distmod1;
		algoritm.distmod2 = distmod2;
		algoritm.accloss = accloss;
		algoritm.isCritical = isCritical;
		algoritm.isHit = isHit;
		algoritm.changedTarget = changedTarget;
		algoritm.useHex = false;
		algoritm.useNormal = false;
		algoritm.weaponMode = weaponMode;
		algoritm.rounds = _WeaponRound( weapon, use );
		algoritm.Proccess( );
	}
    else proccess.Attacker.Say( SAY_NETMSG, "Combat error: weapon PID=" + proccess.WeaponPid + " not handled, please send bug report." );  // combat messages
    FlushResults( results );
    // Shoot
    if( _WeaponEffect( weapon, use ) != 0 )
    {
        if( algoritm.useHex )
            map.RunFlyEffect( _WeaponEffect( weapon, use ), proccess.Attacker, null, proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0 );  // yeah, the target can be null (see: grenades, rocket launcher)
        else
            map.RunFlyEffect( _WeaponEffect( weapon, use ), proccess.Attacker, ( algoritm.useNormal ? algoritm.normalTarget : realTarget ), proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0 );
    }
    if( validEngineObject( proccess.RealWeapon ) )
    {
        if( ammoRound > 0 && proccess.Attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
        {
            if( proccess.RealWeapon.AmmoCount <= ammoRound )
                proccess.RealWeapon.AmmoCount = 0;
            else
                proccess.RealWeapon.AmmoCount -= ammoRound;
            proccess.RealWeapon.Update();
        }

        if( proccess.RealWeapon.IsDeteriorable() && proccess.Attacker.IsPlayer() && proccess.Attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
            DeteriorateItem( proccess.Attacker, proccess.RealWeapon, ( ( ( MAX_SKILL_VAL - ( ( proccess.Attacker.Skill[ skillNum ] * 90 ) * 0.01 ) ) / 3 ) * ( 90 + weapon.BrokenCoefficient * 10 ) ) * ( proccess.IsBurst ? 0.03 : 0.01 ) );

        // One time weapon, erase current and push next (if exist)
        if( _WeaponRemove( weapon, use ) && proccess.Attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
        {
			{
				int slot = proccess.RealWeapon.CritSlot;
				Item@ stack = proccess.Attacker.GetStackItem( proccess.RealWeapon, true );
				if( stack is null )
				{
					uint16 protoid = proccess.RealWeapon.GetProtoId();
					if( skillNum == SK_THROWING && !isGrenade )
					{
						proccess.RealWeapon.EventDrop( proccess.Attacker );
						MoveItem( proccess.RealWeapon, 1, map, proccess.TargetHx, proccess.TargetHy );
					}
					else DeleteItem( proccess.RealWeapon );
					
					Item@[] items;
					for( uint i = 0, iEnd = proccess.Attacker.GetItems( SLOT_INV, items ); i < iEnd; i++ )
						if( validEngineObject( items[ i ] ) && items[ i ].GetProtoId() == protoid )
						{
							proccess.Attacker.MoveItem( items[ i ].Id, 1, slot );
							//items[ i ].Mode = weaponMode;
							items[ i ].Update( );
							// Mode
							break;
						}
				}
				else
				{
					if( skillNum == SK_THROWING && !isGrenade )
					{
						stack.EventDrop( proccess.Attacker );
						MoveItem( stack, 1, map, proccess.TargetHx, proccess.TargetHy );
					}
					else
					{
						uint count = stack.GetCount();
						if( count > 1 )
						{
							stack.SetCount( count - 1 );
							stack.Update();
						}
						else DeleteItem( stack );
					}
				}
			}
        }
    }
    if( !proccess.TargetHit )    // Npc miss text
    {
        if( target.IsNpc() )
            AI_TrySayCombatText( target, COMBAT_TEXT_MISS );
        target.Action( ACTION_DODGE, 0, null );     // Todo: type front/back
    }
}

void ApplyDamage( CombatProccess& proccess, Critter& target, uint rounds, bool isCritical, bool intentionally, CombatRes[]& results )
{
    Map@ map = target.GetMap();
	proccess.DropDamage();
	
    if( target.IsDead() || !( validEngineObject( map ) ) )
        return;

    if( !__NewbieLocationIsPvp && validEngineObject( proccess.Attacker ) && proccess.Attacker.IsPlayer() && target.IsPlayer() && map.GetLocation().GetProtoId() == LOCATION_NewbieLocation )
    {
        proccess.Attacker.Say( SAY_NETMSG, "Oh-oh! Not this time, my friend!" );
        return;         // НоПвп в Нубке.
    }

    if( validEngineObject( proccess.Attacker ) && intentionally && target.Id != proccess.TargetId )
        target.EventAttacked( proccess.Attacker );

    startCombatTimeout( target );
    uint             countMissAc = 0;
    const ProtoItem@ ammo = validEngineObject( proccess.RealWeapon ) ? GetProtoItem( proccess.RealWeapon.AmmoPid ) : null;
    int              bonusAc = ( ammo !is null ) ? ( 0 - ammo.Ammo_AcMod ) : 0;
    if( !isCritical )
    {
        for( uint i = 0; i < rounds; i++ )
            if( Random( 0, 99 ) < target.Stat[ ST_ARMOR_CLASS ] + bonusAc )
                countMissAc++;

        if( countMissAc == rounds )
        {
            NotifyMissAc( target, results );
            return;
        }
    }
    rounds -= countMissAc;

    uint eff = 0,
         msgEff = 0,
         extraMessage = 0,
         extraMessageSelf = 0,
         CountOfCriticalsBulets = 0;

    @proccess.ArmorTarget = _CritGetItemArmor( target );

    uint8 MortirFD = validEngineObject( proccess.RealWeapon ) ? proccess.RealWeapon.Proto.Weapon_FlyingDistance : 0;

    bool  isGrenade = proccess.WeaponSubtype == WS_THROWING && proccess.TypeDamage != DAMAGE_NORMAL,
          isPowerArmor = (  target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_POWERED ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_POWERED_II ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_ADVANCED_I ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_ADVANCED_II ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_SENTRY_BOTS || target.Perk[ PE_STONEWALL ] != 0 );

    if( target.IsNpc() && ( target.Stat[ ST_BASE_CRTYPE ] == CRTYPE_PA || target.Stat[ ST_BASE_CRTYPE ] == CRTYPE_PA_NO_HEAD || target.Stat[ ST_BASE_CRTYPE ] == CRTYPE_APA ) )
        isPowerArmor = true;

	if( target.Id == proccess.TargetId )
		proccess.TargetHit = true;
	
    // Check no PvP
    if( target.IsPlayer() )
    {
        if( validEngineObject( proccess.Attacker ) )
        {
            if( proccess.Attacker.IsPlayer() && ( proccess.Attacker.Mode[ MODE_NO_PVP ] != 0 || target.Mode[ MODE_NO_PVP ] != 0 ) )
            {
                proccess.Attacker.Say( SAY_NETMSG, "No PvP." );
                target.Say( SAY_NETMSG, "No PvP." );
                return;
            }
        }
    }

    if( target.IsNpc() || target.GetAccess() != ACCESS_ADMIN )
        target.ModeBase[ MODE_HIDE ] = 0;

    int bonusChance = 0;

    // определение количества критических попаданий в очереди
    if( validEngineObject( proccess.RealWeapon ) )
        bonusChance = proccess.RealWeapon.WeaponBonus_CritChance + proccess.RealWeapon.Proto.Weapon_CriticalBonus;
    if( rounds > 1 && intentionally )
    {
        int critChance = proccess.Attacker.Stat[ ST_CRITICAL_CHANCE ] + bonusChance,
            antiCritRes = critChance > 100 ? critChance - 100 : 0;
        for( uint i = 0; i < rounds; i++ )
        {
            int rand = Random( 1, 100 ),
                rand2 = Random( 1, 100 );

            if( rand <= critChance && rand2 > ( target.Stat[ ST_CRITICAL_RESISTANCE ] - antiCritRes ) )
                CountOfCriticalsBulets++;
        }
        if( CountOfCriticalsBulets > 0 )
            isCritical = true;
    }
    else if( isCritical )
        CountOfCriticalsBulets = 1;

    uint[] dmgMulForCriticalsHits( CountOfCriticalsBulets, 1 );    // массив множителей урона, для каждой пули в очереди
    /*for( uint i = 0; i < CountOfCriticalsBulets; i++ )
    {
        dmgMulForCriticalsHits[ i ] = 1;
    }*/

    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
        isCritical = false;
    else if( isCritical || proccess.ForceFlags != 0 )
    {
        if( isCritical )
        {
            int aim_ = proccess.Aim,
                roll = 0;
            if( aim_ == HIT_LOCATION_NONE )
                aim_ = HIT_LOCATION_UNCALLED;
            aim_--;
            uint offset = 0;

            for( uint i = 0; i < CountOfCriticalsBulets; i++ )
            {
                roll = Random( 0, 90 ) + ( validEngineObject( proccess.Attacker ) ? ( ( proccess.Attacker.Perk[ PE_BETTER_CRITICALS ] != 0 ? 10 : 0 ) +
                                                                                    ( ( proccess.Attacker.Trait[ TRAIT_FAST_SHOT ] != 0 && proccess.WeaponSubtype == WS_GUN ) ? -25 : 0 ) +
                                                                                    ( proccess.Attacker.Trait[ TRAIT_HEAVY_HANDED ] != 0 ? -15 : 0 ) +
                                                                                    ( proccess.IsWeaponPerk( WEAPON_PERK_BETTER_CRITICALS ) ? 10 : 0 ) ) : 0 ) - target.Perk[ PE_TOUGHNESS ] * 4;
                if( validEngineObject( proccess.Attacker ) )
                {
                    if( validEngineObject( proccess.RealWeapon ) )
                    {
                        roll += proccess.RealWeapon.WeaponBonus_Critroll + proccess.RealWeapon.Proto.Weapon_BonusCritRoll;
                        uint use = 0;
                        int  skillWeapon = _WeaponSkill( proccess.RealWeapon.Proto, use );
                        switch( skillWeapon )
                        {
                        case SK_UNARMED:
                        case SK_THROWING:
                            roll += proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT_ROLL ];
                            break;
                        case SK_ENERGY_WEAPONS:
                        case SK_SMALL_GUNS:
                        case SK_BIG_GUNS:
                            roll += proccess.Attacker.BookBonus[ BB_RANGED_CRIT_ROLL ];
                            break;
                        default:
                            break;
                        }
                    }
                    else if( proccess.ScoreUnarmed )
                        roll += proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT_ROLL ];
                }
                if( roll <= 20 )
                    roll = 0;
                else if( roll <= 45 )
                    roll = 1;
                else if( roll <= 70 )
                    roll = 2;
                else if( roll <= 90 )
                    roll = 3;
                else if( roll <= 100 )
                    roll = 4;
                else
                    roll = 5;
                offset = target.Stat[ ST_BODY_TYPE ] * 9 * 6 * 7 + aim_ * 6 * 7 + roll * 7;
                dmgMulForCriticalsHits[ i ] = CriticalTable[ offset ];
            }

// 0x00000001 - knockout
// 0x00000002 - knockdown
// 0x00000004 - crippled left leg
// 0x00000008 - crippled right leg
// 0x00000010 - crippled left arm
// 0x00000020 - crippled right arm
// 0x00000040 - blinded
// 0x00000080 - death
// 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug) // not used now
// 0x00000800 - bypass armor
// 0x00004000 - dropped weapon (doesn't work) // haha, really?
// 0x00008000 - lose next turn
// 0x00200000 - random

            eff = CriticalTable[ offset + 1 ];
            int stat = CriticalTable[ offset + 2 ],
                statMod = CriticalTable[ offset + 3 ];

            uint cMessage = CriticalTable[ offset + 5 ],
                 cFailureMessage = CriticalTable[ offset + 6 ];

            extraMessage = cMessage;

            if( stat != -1 && ( Random( 1, 10 ) > ( target.Stat[ stat ] + statMod ) ) )
            {
                eff |= CriticalTable[ offset + 4 ];
                extraMessage = cFailureMessage;
            }

            if( target.Mode[ MODE_NO_KNOCK ] != 0 )
                UNSETFLAG( eff, HF_KNOCKDOWN );
        }

        if( proccess.ForceFlags != 0 )
        {
            eff |= proccess.ForceFlags;
            isCritical = true;
        }

        // in the following: in no lose limbs, then clear the effects and set msgEff
        // otherwise set msgEff first, then check for HF_RANDOM
        if( target.Mode[ MODE_NO_LOOSE_LIMBS ] != 0 )
        {
            UNSETFLAG( eff, ( HF_CRIPPLED_LEFT_LEG | HF_CRIPPLED_RIGHT_LEG | HF_CRIPPLED_LEFT_ARM | HF_CRIPPLED_RIGHT_ARM | HF_RANDOM ) );
            msgEff = eff;
        }
        else
        {
            msgEff = eff;

            if( FLAG( eff, HF_RANDOM ) )
            {
                UNSETFLAG( eff, HF_RANDOM );
                switch( Random( 1, 4 ) )
                {
                case 1:
                    SETFLAG( eff, HF_CRIPPLED_LEFT_LEG );
                    break;
                case 2:
                    SETFLAG( eff, HF_CRIPPLED_RIGHT_LEG );
                    break;
                case 3:
                    SETFLAG( eff, HF_CRIPPLED_LEFT_ARM );
                    break;
                case 4:
                    SETFLAG( eff, HF_CRIPPLED_RIGHT_ARM );
                    break;
                default:
                    break;
                }
            }
        }

        if( validEngineObject( proccess.Attacker ) && proccess.Attacker.IsPlayer() )
            ChangePlayerScore( proccess.Attacker, SCORE_SNIPER, 1 );
    }     // end isCritical

    proccess.TargetDR = target.Stat[ ST_NORMAL_RESIST + proccess.TypeDamage - 1 ];
    proccess.TargetDT = target.Stat[ ST_NORMAL_ABSORB + proccess.TypeDamage - 1 ];

    if( proccess.TypeDamage == DAMAGE_EMP && target.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
    {
        proccess.TargetDR = 0;
        proccess.TargetDT = 0;
    }
    else
    {
        if( proccess.IsWeaponPerk( WEAPON_PERK_PENETRATE ) )
            proccess.TargetDR -= 15;
        if( FLAG( eff, HF_BYPASS_ARMOR ) && proccess.TypeDamage != DAMAGE_EMP )
        {
            proccess.TargetDT *= 0.2;
            proccess.TargetDR *= 0.5;
            proccess.TargetDR -= ( validEngineObject( proccess.Attacker ) ? ( proccess.Attacker.Trait[ TRAIT_FINESSE ] != 0 ? 30 : 0 ) : 0 );
        }
        if( isGrenade && validEngineObject( proccess.Attacker ) && proccess.Attacker.Perk[ PE_ARMOR_BUSTER ] != 0 )
            proccess.TargetDR -= 25;

        proccess.TargetDR += ( validEngineObject( proccess.Attacker ) ? ( proccess.Attacker.Trait[ TRAIT_FINESSE ] != 0 ? 30 : 0 ) : 0 );
        if( proccess.IsWeaponPerk( WEAPON_PERK_FLAMEBOY ) )
            proccess.TargetDR -= 10;
        // Log("targetDR1="+targetDR);
        proccess.TargetDR += proccess.DRMod;       // always
        // Log("targetDR2="+targetDR);
    }

    proccess.TargetDR = CLAMP( proccess.TargetDR, 0, 100 );
    if( proccess.TDMod != 0 )
        proccess.TargetDT /= proccess.TDMod;
    proccess.DmgMin += proccess.BonusDmg;
    proccess.DmgMax += proccess.BonusDmg;
    int rawDmg = 0,
        typeDamage = proccess.TypeDamage,
        totalDmg = 0;

	Mk2::CombatTargetPacket@ scriptTarget = cast<Mk2::CombatTargetPacket>(@target.ScriptDescriptor);		
    {
        // некритические попадания в очереди
        bool argIsCrit = false;
        uint damageMulCrit = 1;

        for( uint i = 0; i < ( rounds - CountOfCriticalsBulets ); i++ )
        {
            typeDamage = proccess.TypeDamage;

            {
                if( !scriptTarget.FormatDamage( proccess, rawDmg, typeDamage, argIsCrit, damageMulCrit, i ) )
                    break;
            }

            if( rawDmg > 0 )
            {
                proccess.Damage[ typeDamage ] = proccess.Damage[ typeDamage ] + rawDmg;
                // totalDmg+=rawDmg;
            }
        }

        uint bulleti = rounds - CountOfCriticalsBulets;
        // критические попадания в очереди
        argIsCrit = true;
        for( uint i = 0; i < CountOfCriticalsBulets; i++ )
        {
            typeDamage = proccess.TypeDamage;

            {
                if( !scriptTarget.FormatDamage( proccess, rawDmg, typeDamage, argIsCrit, dmgMulForCriticalsHits[ i ], bulleti++ ) )
                    break;
            }

            if( rawDmg > 0 )
                proccess.Damage[ typeDamage ] = proccess.Damage[ typeDamage ] + rawDmg;
        }
    }

    // 0x00000001 - knockout
    // 0x00000002 - knockdown
    // 0x00000004 - crippled left leg
    // 0x00000008 - crippled right leg
    // 0x00000010 - crippled left arm
    // 0x00000020 - crippled right arm
    // 0x00000040 - blinded
    // 0x00000080 - death
    // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug)
    // 0x00000800 - bypass armor
    // 0x00004000 !- dropped weapon (doesn't work)
    // 0x00008000 - lose next turn

    // code for dropping weapon, adapted from critical failures

    bool isKo = false,
         knockDown = false,
         knockOut = false,
         isDead = false,
         loseTurn = false,
         isBelow = false;

    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
        eff = 0;
    // Knock down
    if( FLAG( eff, HF_KNOCKDOWN ) )
    {
        isKo = true;
        knockDown = true;
    }
    else if( ( proccess.TypeDamage == DAMAGE_EXPLODE && proccess.Damage[ DAMAGE_EXPLODE ] > 9 ) || ( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 8 ) )
        isKo = true;

    // Clipped LLeg
    if( FLAG( eff, HF_CRIPPLED_LEFT_LEG ) )
        target.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
    // Clipped RLeg
    if( FLAG( eff, HF_CRIPPLED_RIGHT_LEG ) )
        target.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
    // Clipped LArm
    if( FLAG( eff, HF_CRIPPLED_LEFT_ARM ) )
        target.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
    // Clipped RArm
    if( FLAG( eff, HF_CRIPPLED_RIGHT_ARM ) )
        target.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
    // Blinded
    if( FLAG( eff, HF_BLINDED ) )
        target.DamageBase[ DAMAGE_EYE ] = 1;

    // Lose turn
    if( FLAG( eff, HF_LOST_NEXT_TURN ) )
    {
        isKo = true;
        loseTurn = true;
    }
    // Knock out
    if( FLAG( eff, HF_KNOCKOUT ) )
    {
		if( !isPowerArmor || Random( 1, 100 ) >= 40 )
		{
			isKo = false;
			knockDown = false;
			knockOut = false;
			loseTurn = false;
		}
		else
		{
			isKo = true;
			knockOut = true;
			loseTurn = false;       // overridden
		}
    }

    if( target.Mode[ MODE_NO_DROP ] != 0 )
    {
        UNSETFLAG( eff, HF_DROPPED_WEAPON );
        UNSETFLAG( msgEff, HF_DROPPED_WEAPON );
    }

    if( validEngineObject( proccess.Attacker ) )
    {
        if( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 5 )
            proccess.Damage = proccess.Damage * 1.4;                                                                                                                                        // Усиленный урон дробовиком
        if( proccess.Attacker.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( target.Stat[ ST_BODY_TYPE ] == BT_ALIEN || target.Stat[ ST_BODY_TYPE ] == BT_ROBOT ) )
            proccess.Damage = proccess.Damage + Random( 10, 20 );                                                                                                                           // yes, pulse grenade works
        if( proccess.Attacker.Perk[ PE_PYROMANIAC ] != 0 && ( proccess.TypeDamage == DAMAGE_FIRE || proccess.Damage[ DAMAGE_FIRE ] > 0 ) )
            proccess.Damage[ DAMAGE_FIRE ] = proccess.Damage[ DAMAGE_FIRE ] + Random( 10, 30 );
    }
	
	totalDmg = proccess.TotalDamage;
    if( totalDmg > 0 )
    {
        if( target.Mode[ MODE_INVULNERABLE ] == 0 )
        {
            if( validEngineObject( proccess.Attacker ) )
            {
                if( validEngineObject( proccess.RealWeapon ) )
                {
                    int skillWeapon = _WeaponSkill( proccess.RealWeapon.Proto, proccess.RealWeapon.Mode );
                    switch( skillWeapon )
                    {
                    case SK_UNARMED:
                    case SK_THROWING:
                        proccess.Damage = proccess.Damage + proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_DAMAGE ];
                        break;
                    case SK_ENERGY_WEAPONS:
                        proccess.Damage = proccess.Damage + int(totalDmg * 0.01 * proccess.Attacker.BookBonus[ BB_ENERGY_DAMAGE ]);
                        break;
                    case SK_SMALL_GUNS:
                        proccess.Damage = proccess.Damage + int(totalDmg * 0.01 * proccess.Attacker.BookBonus[ BB_SMALL_DAMAGE ]);
                        break;
                    case SK_BIG_GUNS:
                        proccess.Damage = proccess.Damage + int(totalDmg * 0.01 * proccess.Attacker.BookBonus[ BB_BIG_DAMAGE ]);
                        break;

                    default:
                        break;
                    }
                }
                else if( proccess.ScoreUnarmed )
                    proccess.Damage = proccess.Damage + proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_DAMAGE ];
            }
           
            proccess.IsCritical = isCritical;

            if( scriptTarget !is null )
                scriptTarget.TakeDamage( proccess, 1, totalDmg );

            if( target.Stat[ ST_CURRENT_HP ] < 1 )
            {
                isKo = true;
                isBelow = true;

                int DeadHitPoints = target.Stat[ ST_DEAD_HIT_POINTS ];
                if( ( DeadHitPoints == __DeadHitPoints && ( target.Stat[ ST_BODY_TYPE ] != BT_MEN && target.Stat[ ST_BODY_TYPE ] != BT_WOMEN &&
                                                            target.Stat[ ST_BODY_TYPE ] != BT_CHILDREN && target.Stat[ ST_BODY_TYPE ] != BT_SUPER_MUTANT && target.Stat[ ST_BODY_TYPE ] != BT_GHOUL && target.Stat[ ST_BODY_TYPE ] != BT_BRAHMIN && target.Stat[ ST_BODY_TYPE ] != BT_DOG ) ) ||
                    target.Mode[ MODE_NO_KNOCK ] != 0 )
                    DeadHitPoints = 0;
                if( target.Stat[ ST_CURRENT_HP ] <= DeadHitPoints )
                    isDead = true;
            }
        }
        // Score
        if( proccess.ScoreUnarmed && validEngineObject( proccess.Attacker ) && proccess.Attacker.IsPlayer() )
            ChangePlayerScore( proccess.Attacker, SCORE_UNARMED_DAMAGE, totalDmg );
    }
    else
    {
        proccess.IsCritical = isCritical;
			
        if( scriptTarget !is null )
            scriptTarget.TakeDamage( proccess, 2, totalDmg );
    }
	
    bool attackFront = true;
    {
        uint dir = GetDirection( proccess.Hx, proccess.Hy, target.HexX, target.HexY );
        if( ( dir == target.Dir || ( ( dir + 1 ) % 6 ) == target.Dir || ( ( dir + 5 ) % 6 ) == target.Dir ) )
            attackFront = false;
    }

    if( validEngineObject( proccess.ArmorTarget ) && target.IsPlayer() )
        DeteriorateItem( target, proccess.ArmorTarget, ( ( ( ( 100 - ( target.Stat[ ST_NORMAL_RESIST + proccess.TypeDamage - 1 ] ) ) * rounds + ( totalDmg < 10 ? 10 : totalDmg ) ) / 3 ) * ( 65 + proccess.ArmorTarget.Proto.BrokenCoefficient * 8 ) ) / 100  );

    if( proccess.IsWeaponPerk( WEAPON_PERK_ELECTRIC_SHOCK ) )
        target.StatBase[ ST_CURRENT_AP ] -= Random( 1, 2 ) * 100;

    // Dead
    if( isDead )
    {
        bool  burst = proccess.IsBurst;
        uint8 anim2Dead = 0;

        if( target.IsKnockout() && proccess.TypeDamage != DAMAGE_EXPLODE )
        {
            if( target.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT )
                anim2Dead = ANIM2_DEAD_PRONE_FRONT;
            else
                anim2Dead = ANIM2_DEAD_PRONE_BACK;
        }
        else
        {
            anim2Dead = attackFront ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK;

            switch( proccess.TypeDamage )
            {
            case DAMAGE_UNCALLED:
                break;
            case DAMAGE_NORMAL:
                if( burst )
                {
                    if( isCritical || proccess.BloodyMess )
                        anim2Dead = ANIM2_DEAD_BLOODY_BURST;
                    else
                        anim2Dead = ANIM2_DEAD_BURST;
                }
                else if( isCritical || proccess.BloodyMess )
                    anim2Dead = ANIM2_DEAD_BLOODY_SINGLE;
                else
                {
                    if( isKo || ( MortirFD != 0 && !isPowerArmor ) )
                    {
                        if( ( isBelow || knockOut || ( ( MortirFD != 0 || knockDown || proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) )  && !isPowerArmor ) ) && !target.IsKnockout() && target.Mode[ MODE_NO_KNOCK ] == 0 )
                        {
                            int knockDist = totalDmg;
                            if( ( ( proccess.WeaponPid >= PID_CLUB && proccess.WeaponPid <= PID_SUPER_SLEDGE ) || ( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 8 ) || MortirFD != 0 || proccess.TypeDamage == DAMAGE_EXPLODE ) && target.IsCanWalk() )
                            {
                                if( proccess.IsWeaponPerk( WEAPON_PERK_KNOCKBACK ) )
                                    knockDist *= 0.2;
                                else if( MortirFD != 0 )
                                {
                                    knockDist *= 0 * 33;
                                    if( knockDist > MortirFD )
                                        knockDist = MortirFD;
                                }
                                else if( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) )
                                {
                                    knockDist *= 0.17;
                                    if( knockDist > 7 )
                                        knockDist = 7;
                                }
                                else
                                    knockDist *= 0.1;
                                knockDist--;
                                if( knockDist > 10 && MortirFD == 0 )
                                    knockDist = 10;
                                uint16 knockHx = proccess.Hx,
                                       knockHy = proccess.Hy;
                                if( knockDist > 0 )
                                {
                                    if( knockHx == target.HexX && knockHy == target.HexY && validEngineObject( proccess.Attacker ) )
                                    {
                                        knockHx = proccess.Attacker.HexX;
                                        knockHy = proccess.Attacker.HexY;
                                    }
                                    map.GetHexCoordWall( target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist );
                                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, knockHx, knockHy );
                                }
                                else
                                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
                            }
                            else
                                target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
                        }
                    }
                }
                break;
            case DAMAGE_LASER:
                anim2Dead = ANIM2_DEAD_LASER;
                break;
            case DAMAGE_FIRE:
                if( proccess.BloodyMess || Random( 0, 1 ) == 0 )
                    anim2Dead = ANIM2_DEAD_BURN_RUN;
                else
                    anim2Dead = ANIM2_DEAD_BURN;
                break;
            case DAMAGE_PLASMA:
                anim2Dead = ANIM2_DEAD_FUSED;
                break;
            case DAMAGE_ELECTR:
                if( Random( 0, 1 ) == 0 )
                    anim2Dead = ANIM2_DEAD_PULSE;
                else
                    anim2Dead = ANIM2_DEAD_PULSE_DUST;
                break;
            case DAMAGE_EXPLODE:
                anim2Dead = ANIM2_DEAD_EXPLODE;
                break;
            default:
                break;
            }
        }

        if( target.IsPlayer() )
            ChangePlayerScore( target, SCORE_ZOMBY, 1 );

        if( validEngineObject( proccess.Attacker ) )
        {
            if( proccess.Attacker.IsPlayer() )
            {
                ChangePlayerScore( proccess.Attacker, SCORE_KILLER, 1 );
                if( target.IsPlayer() )
                    ChangePlayerScore( proccess.Attacker, SCORE_MANIAC, 1 );
                else if( target.Id == proccess.TargetId )
                    target.AddEnemyInStack( proccess.Attacker.Id );
            }
            else
                proccess.Attacker.EraseEnemyFromStack( target.Id );

            // if(target.ModeBase[MODE_ENCAUNTER_MOB]!=1) attacker.StatBase[ST_EXPERIENCE]+=target.Stat[ST_KILL_EXPERIENCE];
            if( target.IsPlayer() )
                proccess.Attacker.KillBase[ KILL_PLAYERS ]++;
            proccess.Attacker.KillBase[ KILL_BEGIN + target.Stat[ ST_BODY_TYPE ] ]++;
        }
        target.ToDead( anim2Dead, proccess.Attacker );
    }
    else if( isKo || ( MortirFD != 0 && !isPowerArmor ) )
    {
        int maxAp = target.Stat[ ST_ACTION_POINTS ],
            currentAp = target.Stat[ ST_CURRENT_AP ],
            targetAp = currentAp;

        if( loseTurn )
        {
            targetAp = -target.Perk[ PE_QUICK_RECOVERY ] != 0 ? maxAp * 0.5 : maxAp;
            target.StatBase[ ST_MOVE_AP ] = 0;
        }
        if( knockOut )
            targetAp = -Random( maxAp, 2 * maxAp - target.Perk[ PE_QUICK_RECOVERY ] != 0 ? maxAp * 0.5 : 0 );
        if( knockDown && !( target.IsKnockout() && map.IsTurnBased() ) )
            targetAp -= ( target.Perk[ PE_QUICK_RECOVERY ] != 0 ? 1 : 3 );
        if( ( isBelow || knockOut || ( ( MortirFD != 0 || knockDown || proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) || proccess.TypeDamage == DAMAGE_EXPLODE )  && !isPowerArmor ) ) && !target.IsKnockout() && target.Mode[ MODE_NO_KNOCK ] == 0 )
        {
            int knockDist = totalDmg;
            if( ( ( proccess.WeaponPid >= PID_CLUB && proccess.WeaponPid <= PID_SUPER_SLEDGE ) || ( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 8 ) || MortirFD != 0 || proccess.TypeDamage == DAMAGE_EXPLODE ) && target.IsCanWalk() )
            {
                if( proccess.IsWeaponPerk( WEAPON_PERK_KNOCKBACK ) )
                    knockDist *= 0.2;
                else if( MortirFD != 0 )
                {
                    knockDist /= 3;
                    if( knockDist > MortirFD )
                        knockDist = MortirFD;
                }
                else if( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) )
                {
                    knockDist *= 0.16;
                    if( knockDist > 7 )
                        knockDist = 7;
                }
                else
                    knockDist *= 0.1;
                knockDist--;
                if( knockDist > 10 && MortirFD == 0 )
                    knockDist = 10;
                uint16 knockHx = proccess.Hx,
                       knockHy = proccess.Hy;
                if( knockDist > 0 )
                {
                    if( knockHx == target.HexX && knockHy == target.HexY && validEngineObject( proccess.Attacker ) )
                    {
                        knockHx = proccess.Attacker.HexX;
                        knockHy = proccess.Attacker.HexY;
                    }
                    map.GetHexCoordWall( target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist );
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, knockHx, knockHy );
                }
                else
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
            }
            else
                target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
        }
        if( targetAp < currentAp )
            target.StatBase[ ST_CURRENT_AP ] = 100 * targetAp;
    }
    
    // TabaK. Добавил проверку на смерть. Дюп пофикшен???
    if( FLAG( eff, HF_DROPPED_WEAPON ) || ( ( target.Stat[ ST_CURRENT_HP ] < 1 ) && target.IsPlayer() && target.Mode[ MODE_NO_DROP ] == 0 && !isDead ) )
    {
        Item@ realWeaponTarget = _CritGetItemHand( target );
        if( validEngineObject( realWeaponTarget ) )
        {
            if( FLAG( realWeaponTarget.Flags, ITEM_GAG ) )
                DeleteItem( realWeaponTarget );
            else
            {
                MoveItem( realWeaponTarget, 1, map, target.HexX, target.HexY );
                realWeaponTarget.EventDrop( target );
                if( target.IsNpc() )
                {
                    NpcPlane@ plane = CreatePlane();

                    NpcPlane@[] crPlanes( 0 );

                    if( target.GetPlanes( crPlanes ) > 0 )
                        plane.Priority = crPlanes[ 0 ].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = realWeaponTarget.HexX;
                    plane.Pick_HexY = realWeaponTarget.HexY;
                    plane.Pick_Pid = realWeaponTarget.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    target.AddPlane( plane );
                }
            }
        }
    }
    // Damage
    else if( !target.IsKnockout() )
    {
        // Animate hit
        if( proccess.ShowHitAnimForce )
            target.Action( ACTION_DAMAGE_FORCE, attackFront ? 0 : 1, null );
        else
            target.Action( ACTION_DAMAGE, attackFront ? 0 : 1, null );

        // Npc hit message
        if( proccess.CombatMessage && proccess.TypeDamage != DAMAGE_UNCALLED && target.IsNpc() )
        {
            switch( proccess.Aim )
            {
            case HIT_LOCATION_NONE:
            case HIT_LOCATION_UNCALLED:
            case HIT_LOCATION_TORSO:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_TORSO );
                break;
            case HIT_LOCATION_EYES:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_EYES );
                break;
            case HIT_LOCATION_HEAD:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_HEAD );
                break;
            case HIT_LOCATION_LEFT_ARM:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_LEFT_ARM );
                break;
            case HIT_LOCATION_RIGHT_ARM:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_RIGHT_ARM );
                break;
            case HIT_LOCATION_GROIN:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_GROIN );
                break;
            case HIT_LOCATION_RIGHT_LEG:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_RIGHT_LEG );
                break;
            case HIT_LOCATION_LEFT_LEG:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_LEFT_LEG );
                break;
            default:
                break;
            }
        }
    }

    bool isAimed = ( proccess.Aim != HIT_LOCATION_NONE ) && ( proccess.Aim != HIT_LOCATION_TORSO ) && ( proccess.Aim != HIT_LOCATION_UNCALLED );

    uint mainMsg = CMSG_HIT,
         length = 3;

    if( isCritical )
    {
        mainMsg += 2;
        length += 2;
    }
    if( isDead )
    {
        mainMsg += 4;
        if( isCritical )
            length -= 1;
    }
    if( isAimed )
    {
        mainMsg += 1;
        length += 1;
    }

    uint[] sendEff( length );
    sendEff[ 0 ] = mainMsg;
    sendEff[ 1 ] = target.Id;
    uint now = 2;

    if( isAimed )
    {
        sendEff[ 2 ] = proccess.Aim;
        now++;
    }

    sendEff[ now ] = totalDmg;
    now++;

    if( isCritical )
    {
        if( !isDead )
        {
            sendEff[ now ] = msgEff;
            now++;
        }

        sendEff[ now ] = extraMessage;
    }

    Critter@[] crits;

    for( uint i = 0, iMax = target.GetCritters( true, FIND_ALL | FIND_ONLY_PLAYERS, crits ); i < iMax; i++ )
        if( crits[ i ].Id != target.Id )
            AddEff( crits[ i ], sendEff, results );

    if( isCritical )
        sendEff[ now ] = extraMessage + 1500;            // men_player - men_npc

    AddEff( target, sendEff, results );

    // poisoning and irradiating:
    if( validEngineObject( proccess.Attacker ) )
    {
        int poison = ( proccess.IsWeaponPerk( WEAPON_PERK_TOXIC ) ) ? 50 : proccess.Attacker.Stat[ ST_TOXIC ],
            radiation = proccess.Attacker.Stat[ ST_RADIOACTIVE ];

        if( proccess.AmmoPid == PID_50_CAL || proccess.AmmoPid == PID_HN_AP_NEEDLER_CARTRIDGE )
            radiation += rounds * 50;

        if( poison != 0 || radiation != 0 )
        {
            if( Random( 2, 16 ) > target.Stat[ ST_LUCK ] )
            {
                if( poison > 0 )
                    AffectPoison( target, Random( poison / 3, poison ) );
                if( radiation > 0 )
                    AffectRadiation( target, Random( radiation / 3, radiation ) );
            }
        }

        if( proccess.Attacker.Stat[ ST_BODY_TYPE ] == BT_CENTAUR && Random( 2, 16 ) > target.Stat[ ST_LUCK ] )
            AffectRadiation( target, Random( 10, 20 ) );
    }

    if( proccess.ArmorTarget !is null && target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_TESLA && ( proccess.TypeDamage == DAMAGE_ELECTR || proccess.TypeDamage == DAMAGE_LASER || proccess.TypeDamage == DAMAGE_PLASMA ) )
    {
        int cunsumedDmg = proccess.DmgMax - totalDmg;
        if( cunsumedDmg > 0 )
            proccess.ArmorTarget.Charge = CLAMP( proccess.ArmorTarget.Charge + cunsumedDmg, 0, 100 );
    }
}

void CriticalFailure( Critter& attacker, ProtoItem& weapon, uint8 weaponUse, ProtoItem@ ammo, uint eff, CombatRes[]& results )
{

    // 0x00000100 hit self OK
    // 0x00100000 weapon exploded OK

    // 0x00000200 lost rest of ammo OK
    // 0x00000400 fired dud shot OK?
    // 0x00000800 hurt self OK
    // 0x00001000 hit randomly ~OK, TODO
    // 0x00002000 crippled random limb OK
    // 0x00040000 on fire NOT USED NOW, TODO?

    // 0x00200000 weapon destroyed OK
    // 0x00400000 weapon dropped OK
    // 0x00800000 lost next turn OK
    // 0x02000000 knocked down OK


    int  totalDmg = 0;

    bool tookDamage = false,
         wpnIsRemoved = _WeaponRemove( weapon, weaponUse );

    Item@ realWeapon = _CritGetItemHand( attacker );
    Map@  map = attacker.GetMap();

    if( attacker.Mode[ MODE_NO_DROP ] != 0 )
        UNSETFLAG( eff, MF_WEAPON_DROPPED );

    if( FLAG( eff, MF_HIT_SELF ) || FLAG( eff, MF_WEAPON_EXPLODED ) ) // only one bullet because burst weapons do not have the ability
    {
        bool validAmmo = ammo !is null;

        int  dmgType = _WeaponDmgType( weapon, weaponUse ),
             targetDR = attacker.Stat[ ST_NORMAL_RESIST + dmgType - 1 ],
             targetDT = attacker.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ],
             dmgMin = _WeaponDmgMin( weapon, weaponUse ),
             dmgMax = _WeaponDmgMax( weapon, weaponUse ),
             dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1, // technically, should be *2
             dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;  // technically, should be *2

        if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
            targetDT /= 5;
        targetDR += ( ( attacker.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
        if( attacker.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
            totalDmg += Random( 10, 30 );
        if( validAmmo )
            targetDR += ammo.Ammo_DrMod;
        targetDR = CLAMP( targetDR, 0, 100 );

        totalDmg = Random( dmgMin, dmgMax ) + 2 * attacker.Perk[ PE_BONUS_RANGED_DAMAGE ];
        totalDmg *= dmgMul;
        if( dmgDiv != 0 )
            totalDmg /= dmgDiv;
        totalDmg -= targetDT;
        totalDmg -= ( totalDmg * targetDR ) * 0.01;
        if( totalDmg < 0 )
            totalDmg = 0;
        if( attacker.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( attacker.Stat[ ST_BODY_TYPE ] == BT_ALIEN || attacker.Stat[ ST_BODY_TYPE ] == BT_ROBOT ) )
            totalDmg += Random( 10, 20 );
        if( attacker.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
            totalDmg += Random( 10, 30 );
        totalDmg -= ( totalDmg * attacker.Perk[ PE_TOUGHNESS ] * 5 ) * 0.01;
        tookDamage = true;
    }

    uint16 ammoRound = _WeaponRound( weapon, weaponUse );
    if( ammoRound > 0 && validEngineObject( realWeapon ) && attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
    {
        if( realWeapon.AmmoCount <= ammoRound || FLAG( eff, MF_LOST_REST_OF_AMMO ) )
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
    }

    if( attacker.Mode[ MODE_NO_DROP ] != 0 )
        UNSETFLAG( eff, MF_WEAPON_DROPPED );

    if( FLAG( eff, MF_WEAPON_DROPPED ) && validEngineObject( realWeapon ) )
    {
        if( FLAG( realWeapon.Flags, ITEM_GAG ) )
        {
            DeleteItem( realWeapon );
        }
        else
        {
            MoveItem( realWeapon, 0, map, attacker.HexX, attacker.HexY );
            realWeapon.EventDrop( attacker );
            if( attacker.IsNpc() )
            {
                NpcPlane@ plane = CreatePlane();

                NpcPlane@[] crPlanes( 0 );

                if( attacker.GetPlanes( crPlanes ) > 0 )
                    plane.Priority = crPlanes[ 0 ].Priority + 1;
                else
                    plane.Priority = 70;

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = realWeapon.HexX;
                plane.Pick_HexY = realWeapon.HexY;
                plane.Pick_Pid = realWeapon.GetProtoId();
                plane.Pick_UseItemId = 0;
                plane.Pick_ToOpen = false;
                plane.Run = true;
                attacker.AddPlane( plane );
            }
        }
    }

    if( ( FLAG( eff, MF_WEAPON_DESTROYED ) || FLAG( eff, MF_WEAPON_EXPLODED ) ) && validEngineObject( realWeapon ) )
    {
        if( realWeapon.GetCount() > 1 )
            realWeapon.SetCount( realWeapon.GetCount() - 1 );
        else
        {
            DeleteItem( realWeapon );
        }
    }

    if( FLAG( eff, MF_HURT_SELF ) )
    {
        totalDmg += Random( 1, 5 );
        tookDamage = true;
    }

    if( FLAG( eff, MF_LOST_NEXT_TURN ) )
    {
        attacker.StatBase[ ST_CURRENT_AP ] = -100 * attacker.Perk[ PE_QUICK_RECOVERY ] != 0 ? attacker.Stat[ ST_ACTION_POINTS ] * 0.5 : attacker.Stat[ ST_ACTION_POINTS ];
        attacker.StatBase[ ST_MOVE_AP ] = 0;
    }

    if( FLAG( eff, MF_KNOCKED_DOWN ) && !attacker.IsKnockout() )
        attacker.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), attacker.Perk[ PE_QUICK_RECOVERY ] != 0 ? 1 : 3, attacker.HexX, attacker.HexY );

    if( FLAG( eff, MF_CRIPPLED_RANDOM_LIMB ) && attacker.Mode[ MODE_NO_LOOSE_LIMBS ] == 0 )
    {
        switch( Random( 1, 4 ) )
        {
        case 1:
            attacker.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
            break;
        case 2:
            attacker.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
            break;
        case 3:
            attacker.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
            break;
        case 4:
            attacker.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
            break;
        default:
            break;
        }
    }

    if( totalDmg > 0 )
        attacker.StatBase[ ST_CURRENT_HP ] -= totalDmg;

    uint[] allEff = { CMSG_CRIT_MISS, attacker.Id, eff };

    if( tookDamage )
    {
        allEff.resize( 4 );
        allEff[ 3 ] = totalDmg;
        allEff[ 0 ] = CMSG_CRIT_MISS_DAMAGE;
    }

    if( attacker.Stat[ ST_CURRENT_HP ] < 1 )
    {
        if( attacker.Stat[ ST_CURRENT_HP ] > __DeadHitPoints && attacker.Mode[ MODE_NO_KNOCK ] == 0 )
        {
            if( !attacker.IsKnockout() )
                attacker.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 0, attacker.HexX, attacker.HexY );
        }
        else
        {
            uint anim2Dead = ANIM2_DEAD_FRONT;
            if( attacker.IsKnockout() )
            {
                if( attacker.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT )
                    anim2Dead = ANIM2_DEAD_PRONE_FRONT;
                else
                    anim2Dead = ANIM2_DEAD_PRONE_BACK;
            }
            attacker.ToDead( anim2Dead, null );
            allEff[ 2 ] |= MF_WAS_KILLED;
        }
    }

    Critter@[] him = { @attacker },
    crits;
    for( int i = 0, iMax = map.GetCrittersSeeing( him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits ); i < iMax; i++ )
        AddEff( crits[ i ], allEff, results );

    FlushResults( results );

    return;
}

void InjureCritter( Critter& critter, uint damage, uint damageType, uint8 dir, uint attackerId, CombatProccess& combat ) // Export
{
    if( damageType > DAMAGE_EXPLODE )
        return;

    CombatRes[] results;
    ApplyDamage( combat, critter, 1, false, true, results );

    FlushResults( results );
}

void InjureCritter( Critter& critter, uint damage, uint damageType, uint8 dir, uint attackerId ) // Export
{
    if( damageType > DAMAGE_EXPLODE )
        return;

    Critter@ attacker = null;
    if( attackerId != 0 && critter.Id != attackerId )
        @attacker = GetCritter( attackerId );
    CombatProccess@ proccess = CombatProccess();
    @proccess.Attacker = attacker;

    uint16 hx = critter.HexX,
           hy = critter.HexY;
    Map@   map = critter.GetMap();
    if( validEngineObject( map ) )
        map.MoveHexByDir( hx, hy, ( dir + 3 ) % 6, 1 );

    proccess.Hx = hx;
    proccess.Hy = hy;
    proccess.Aim = HIT_LOCATION_UNCALLED;
    proccess.IsBurst = false;
    proccess.BloodyMess = false;
    proccess.CombatMessage = false;
    proccess.WeaponSubtype = 0;
    proccess.DmgMin = damage;
    proccess.DmgMax = damage;
    proccess.TypeDamage = damageType;
    proccess.BonusDmg = 0;
    proccess.DmgMul = 1;
    proccess.DRMod = 0;
    proccess.DMMod = 1;
    proccess.DDMod = 1;
    proccess.TargetId = critter.Id;
    proccess.ShowHitAnimForce = true;

    CombatRes[] results;
    ApplyDamage( proccess, critter, 1, false, true, results );

    FlushResults( results );
}

void InjureCritter( Critter& critter, uint damage, uint damageType, uint8 dir, uint attackerId, uint forceFlags ) // Export
{
    if( damageType > DAMAGE_EXPLODE )
        return;

    Critter@ attacker = null;
    if( attackerId != 0 && critter.Id != attackerId )
        @attacker = GetCritter( attackerId );

    CombatProccess@ proccess = CombatProccess();
    @proccess.Attacker = attacker;

    uint16 hx = critter.HexX,
           hy = critter.HexY;
    Map@   map = critter.GetMap();
    if( validEngineObject( map ) )
        map.MoveHexByDir( hx, hy, ( dir + 3 ) % 6, 1 );

    proccess.Hx = hx;
    proccess.Hy = hy;
    proccess.Aim = HIT_LOCATION_UNCALLED;
    proccess.IsBurst = false;
    proccess.BloodyMess = false;
    proccess.CombatMessage = false;
    proccess.WeaponSubtype = 0;
    proccess.DmgMin = damage;
    proccess.DmgMax = damage;
    proccess.TypeDamage = damageType;
    proccess.BonusDmg = 0;
    proccess.DmgMul = 1;
    proccess.DRMod = 0;
    proccess.DMMod = 1;
    proccess.DDMod = 1;
    proccess.TargetId = critter.Id;
    proccess.ForceFlags = forceFlags;
    proccess.ShowHitAnimForce = true;

    CombatRes[] results;
    ApplyDamage( proccess, critter, 1, false, true, results );

    FlushResults( results );
}

int FindCritterInArray( Critter@[]& crits, Critter& critter )
{
    uint crId = critter.Id;
    for( uint i = 0, iMax = crits.length(); i < iMax; i++ )
        if( crits[ i ].Id == crId )
            return i;
    return -1;
}

uint GetAimApCost( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __ApCostAimTorso;
    case HIT_LOCATION_EYES:
        return __ApCostAimEyes;
    case HIT_LOCATION_HEAD:
        return __ApCostAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __ApCostAimArms;
    case HIT_LOCATION_GROIN:
        return __ApCostAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __ApCostAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetBonusCriticalChanceForHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes - 25;
    case HIT_LOCATION_HEAD:
        return __HitAimHead - 20;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms - 10;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin - 10;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}

// client only, possible use by AI
int RawToHit( Critter& critter, Critter& target, const ProtoItem@ weapon, uint8 weaponUse, const ProtoItem@ ammo )
{
    uint8 use = weaponUse;

    int   skillNum = SK_UNARMED,
          wpnMaxDist = 0;
    if( weapon !is null )
    {
        skillNum = _WeaponSkill( weapon, use );
        wpnMaxDist = ( skillNum == SK_THROWING ) ? ( MIN( int( _WeaponMaxDist( weapon, use ) ), 3 * MIN( int(10), ( critter.Stat[ ST_STRENGTH ] + 2 * critter.Perk[ PE_HEAVE_HO ] ) ) ) ) : ( _WeaponMaxDist( weapon, use ) );
    }
    int   baseToHit = critter.Skill[ skillNum ];

    uint8 weaponSubtype =
        ( skillNum == SK_DOCTOR || skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS )
        ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );

    uint16 ammoRound = weapon !is null ? _WeaponRound( weapon, use ) : 1,
           weapPid = weapon !is null ? weapon.ProtoId : 0;

    bool isBurst = ( ammoRound > 1 ) && _WeaponNoBrust( weapon, use ) != 1,
         isHthAttack = ( weaponSubtype == WS_UNARMED ),
         eyeDamage = critter.Damage[ DAMAGE_EYE ] != 0,
         crIsPlayer = critter.IsPlayer(),
         isUnarmed = ( weapon !is null && weapon.Weapon_IsUnarmed ) || skillNum == SK_UNARMED;

    uint8 aim = isBurst ? HIT_LOCATION_UNCALLED : ( ( _WeaponModeAim( weaponUse ) == HIT_LOCATION_EYES && ( critter.Dir + 3 ) % 6 != target.Dir ) ? HIT_LOCATION_HEAD : _WeaponModeAim( weaponUse ) );

    // main proccess structure
    CombatProccess@ proccess = CombatProccess();
    @proccess.Attacker = critter;
    @proccess.RealWeapon = _CritGetItemHand( critter );
    proccess.Hx = critter.HexX;
    proccess.Hy = critter.HexY;
    proccess.TargetHx = target.HexX;
    proccess.TargetHy = target.HexY;
    proccess.Aim = aim;
    proccess.IsBurst = isBurst;
    proccess.ScoreUnarmed = ( weaponSubtype == WS_UNARMED );

    if( weapon !is null )
    {
        proccess.WeaponPid = weapon.ProtoId;
        proccess.FirstWeaponPerk = ( isUnarmed && weapon.Weapon_UnarmedArmorPiercing ) ? WEAPON_PERK_PENETRATE : weapon.Weapon_Perk;
        proccess.SecondWeaponPerk = ( isUnarmed && weapon.Weapon_UnarmedArmorPiercing ) ? WEAPON_PERK_PENETRATE : weapon.Weapon_SecondPerk;
        proccess.AmmoPerk = ammo !is null ? int(ammo.Ammo_Perk) : -1;
    }

    if( ( weapPid == PID_FLAMER ) || ( weapPid == PID_IMPROVED_FLAMETHROWER ) || ( weapPid == PID_FIRE_GECKO_FLAME_WEAPON ) || ( weapPid == PID_FLAMER_MK3 ) || ( weapPid == PID_FIRE_GECKO_FLAME_WEAPON_LIGHT ) )
        proccess.TypeAttack = ETypeAttack::TypeAttack_Flame;

    // baseToHit used for all targets, adjusted for distance and other target-dependent qualities every time it is necessary
    if( eyeDamage )
        baseToHit -= 25;
    if( proccess.Attacker.Perk[ PE_VAMPIRE_ACCURACY ] > 0 && IS_NIGHT( __Hour ) )
        baseToHit += 13;                                                      // Quest perk

    if( !isUnarmed )
    {
        if( proccess.Attacker.Trait[ TRAIT_ONE_HANDER ] != 0 )
            baseToHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );
        int handlingStrength = proccess.Attacker.Stat[ ST_STRENGTH ] + proccess.Attacker.Perk[ PE_WEAPON_HANDLING ] * 3 +
                               ( ( proccess.Attacker.Trait[ TRAIT_ONE_HANDER ] != 0 && !FLAG( weapon.Flags, ITEM_TWO_HANDS ) ) ? 1 : 0 ) -
                               proccess.Attacker.Trait[ TRAIT_SMALL_FRAME ] * 2,
            reqStrength = weapon.Weapon_MinStrength;
        if( handlingStrength < reqStrength )
            baseToHit -= ( reqStrength - handlingStrength ) * 20;
    }

    // proccess.ReasonMiss=missSkill?MissReason_SkillLionhead:MissReason_None;
    if( isHthAttack )
        proccess.TypeAttack = ETypeAttack::TypeAttack_Melee;

    // to check if the target was hit:
    proccess.TargetId = target.Id;

    // here we're deciding the real toHit;
    int  dist = proccess.Distantion;

    Map@ map = proccess.Attacker.GetMap();
    if( dist > 1 )
    {
        uint16 _hx = proccess.TargetHx, _hy = proccess.TargetHy;
        map.MoveHexByDir( _hx, _hy, GetDirection( proccess.TargetHx, proccess.TargetHy, proccess.Hx, proccess.Hy ), 1 );
        if( not map.IsHexPassed( _hx, _hy ) )
        {
            baseToHit -= 120;
        }
        else if( dist > 2 )
        {
            _hx = proccess.TargetHx;
            _hy = proccess.TargetHy;
            map.MoveHexByDir( _hx, _hy, GetDirection( proccess.TargetHx, proccess.TargetHy, proccess.Hx, proccess.Hy ), 2 );
            if( not map.IsHexPassed( _hx, _hy ) )
            {
                baseToHit -= 85;
            }
            else if( dist > 3 )
            {
                _hx = proccess.TargetHx;
                _hy = proccess.TargetHy;
                map.MoveHexByDir( _hx, _hy, GetDirection( proccess.TargetHx, proccess.TargetHy, proccess.Hx, proccess.Hy ), 3 );
                if( not map.IsHexPassed( _hx, _hy ) )
                {
                    baseToHit -= 50;
                }
            }
        }
    }

    int toHit = baseToHit,
        bonusToHit = 0,
    // range considerations, we're storing everything for a later use
        distmod1 = 2, // used for initial weapon bonus
        distmod2 = 0; // minimal distance
    if( validEngineObject( proccess.RealWeapon ) )
        bonusToHit += proccess.RealWeapon.WeaponBonus_ToHit;

    if( weapon !is null )
        bonusToHit += weapon.Weapon_BonusToHit;
    toHit -= isHthAttack ? ( GetHitAim( aim ) * 0.5 ) : GetHitAim( aim );

    if( proccess.IsWeaponPerk( WEAPON_PERK_LONG_RANGE ) )
        distmod1 = 4;
    else if( proccess.IsWeaponPerk( WEAPON_PERK_SCOPE_RANGE ) )
    {
        distmod1 = 5;
        distmod2 = 5;
    }

    int perception = proccess.Attacker.Stat[ ST_PERCEPTION ],

        acc = dist,
        accloss = ( crIsPlayer ? ( perception - 2 ) * distmod1 : ( perception * distmod1 ) ),
        sharpshooter = 4 * proccess.Attacker.Perk[ PE_SHARPSHOOTER ];

    if( !isHthAttack )
    {
        if( dist < distmod2 )
            acc += distmod2;
        else
            acc -= accloss;
        if( -2 * perception > acc )
            acc = -2 * perception;
        acc -= sharpshooter;
        if( acc > 0 && eyeDamage )
            acc *= 3;
        acc *= -4;
        toHit += acc;
        int blockers = map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0.0f, dist, FIND_LIFE, null );
        if( !target.IsKnockout() )
            blockers--;
        toHit -= 10 * blockers;
    }

    if( target.IsKnockout() )
        toHit += 40;
    if( target.GetMultihex() > 0 )
        toHit += 15;

    toHit += bonusToHit;
    toHit = CLAMP( toHit, 5, 95 );

    // smoke penalty
    if( !isHthAttack && proccess.TypeAttack != ETypeAttack::TypeAttack_Flame )
        toHit -= GetSmokePenalty( map, proccess.Attacker, target, 0, 0 );
    return toHit;

}

Critter@ ChooseRandomTarget( Map& map, Critter& critter, Critter& target, uint weaponMaxDist )
{
    Critter@[] critters;
    uint16 hx = critter.HexX,
           hy = critter.HexY,
           bx = 0,
           by = 0,
           pbx = 0,
           pby = 0;
    uint n = map.GetCrittersHex( hx, hy, weaponMaxDist, FIND_LIFE_AND_KO, critters );
    if( n == 0 )
        return null;    // should never happen
    uint start = Random( 0, n - 1 );
    Critter@ resultCritter = null;
    for( uint i = start; i < n; i++ )
    {
        @resultCritter = critters[ i ];
        if( resultCritter.Id == critter.Id || resultCritter.Id == target.Id )
            continue;
        // wallcheck:
        map.GetCrittersPath( hx, hy, resultCritter.HexX, resultCritter.HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by );
        if( bx == resultCritter.HexX && by == resultCritter.HexY )
            return resultCritter;
    }
    for( uint i = 0; i < start; i++ )
    {
        @resultCritter = critters[ i ];
        if( resultCritter.Id == critter.Id || resultCritter.Id == target.Id )
            continue;
        // wallcheck:
        map.GetCrittersPath( hx, hy, resultCritter.HexX, resultCritter.HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by );
        if( bx == resultCritter.HexX && by == resultCritter.HexY )
            return resultCritter;
    }

    return null;
}

// //////////////////////////////////////////////////////////////////////////////////
// Погексовая атака v.1///////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////////
/*ВНИМАНИЕ, НПЦ НЕ МОГУТ АТАКОВАТЬ ПОГЕКСОВО.*/
// ///////////////////////////////////////////////////////////////////////////////////
// Имитация сетки стрельбы.

bool Zone_Attack( Critter& critter, uint16 hexX, uint16 hexY, int slot = SLOT_HAND1 )
{
    Map@ map = critter.GetMap();
    if( !validEngineObject( map ) )
        return false;
	
	Item@ item = critter.GetItem( 0, slot );
    if( !validEngineObject( item ) )
        return false;
    const ProtoItem@ proto = item.Proto;
	uint8 use = _WeaponModeUse( item.Mode );
    if( proto is null )
        return false;
    
	bool isDoor = map.GetDoor( hexX, hexY ) !is null;
    uint len = GetDistantion( critter.HexX, critter.HexY, hexX, hexY );
    if( map.IsHexRaked( hexX, hexY ) != true && !isDoor )
        return false; // Гекс непростреливаемый, в него нельзя выстрелить. Выходим из функции.
    bool IsThrowing = ( _WeaponSkill( proto, use ) == SK_THROWING );
    int  WMaxDist = _WeaponMaxDist( proto, use );
    uint dist = ( _WeaponSkill( proto, use ) == SK_THROWING ) ? 
					( MIN( WMaxDist, 3 * MIN( int(10), ( critter.Stat[ ST_STRENGTH ] + 2 * critter.Perk[ PE_HEAVE_HO ] ) ) ) ) : 
						WMaxDist;
						
    if( uint( critter.Stat[ ST_VISIBLE_DIST ] ) < len || dist < len || len == 0 || dist == 0 )
        return false; // Если точка выстрела дальше чем видит персонаж, и не входит в дистанцию атаки оружия, значит не стреляем.

    if( proto.Weapon_ZoneAttackIgnoreNotRaked )
        return true;

    uint16 XP = hexX, YP = hexY;                      // Координаты гекса по X и Y для записи в него гекса занятости.
    map.GetHexCoord( critter.HexX, critter.HexY, XP, YP, 0, 0 ); // Найдем непростреливаемый гекс на пути выстрела.
	if( len <= GetDistantion( critter.HexX, critter.HexY, XP, YP ) )
		return true;
	return isDoor;
}

bool u_Attack( Critter@ critter, int hexX, int hexY, int slot ) // Export
{
	if( critter is null || critter.IsNotValid )
	{
		Log( "critter is null" );
		return false;
	}
	
	if( !critter.IsFree() || !critter.IsLife() )
        return false;
	
    const Item@ item = critter.GetItem( 0, slot );
    if( !validEngineObject( item ) )
        return false;
    if( _ItemIsBroken( item ) )
    {
        if( critter.IsPlayer() )
            critter.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_WEAPON_BROKEN );
        return false;
    }
    const uint8 mode = item.Mode,
			use = _WeaponModeUse( mode );
    const ProtoItem@ weapon = item.Proto,
						 ammo = GetProtoItem( item.AmmoPid );
    if( _WeaponRound( weapon, use ) > 0 && item.AmmoCount == 0 )
        return false;

    if( !Zone_Attack( critter, hexX, hexY, slot ) )
        return false;

    const int skillNum = _WeaponSkill( weapon, use );
    const uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );
    const uint16 apCost = MAX( 1, ( ( _WeaponApCost( weapon, use ) - item.WeaponBonus_AP - critter.Perk[ PE_BONUS_RATE_OF_FIRE ] ) - ( weaponSubtype == WS_GUN ? critter.Trait[ TRAIT_FAST_SHOT ] : 0 ) ) );
    if( !critter.IsAnim1( weapon.Weapon_Anim1 ) || critter.Stat[ ST_CURRENT_AP ] < apCost )
        return false;

    if( Attack( critter, item, mode, hexX, hexY ) )
    {
		// __Breaktime
		uint breaktime = _WeaponBreakAttack( weapon, use );
		if( breaktime == 0 ) breaktime = __Breaktime;
        critter.StatBase[ ST_CURRENT_AP ] -= apCost * 100;         // Отнимает очки действия.
        critter.Wait( breaktime );
        return true;
    }
    return false;
}

void unsafe_Attack( Critter& critter, int hexX, int hexY, int slot, string@, int[] @ )
{
    u_Attack( critter, hexX, hexY, slot );
}

bool Attack( Critter& critter, Item& item, uint8 weaponMode, uint16 defHexX, uint16 defHexY, CombatProccess@ proccess = null ) // ToDo переделать под нпц
{
    const ProtoItem@ weapon = item.Proto;
	
	if( proccess is null ) @proccess = CombatProccess();
    @proccess.Attacker = critter;
    @proccess.RealWeapon = item;
    proccess.WeaponPid = proccess.RealWeapon.GetProtoId();
    proccess.Hx = critter.HexX;
    proccess.Hy = critter.HexY;
    proccess.TargetHx = defHexX;
    proccess.TargetHy = defHexY;

    if( FLAG( proccess.RealWeapon.Flags, ITEM_TWO_HANDS ) )
    {
        if( proccess.Attacker.Damage[ DAMAGE_RIGHT_ARM ] != 0 || proccess.Attacker.Damage[ DAMAGE_LEFT_ARM ] != 0 )
        {
            if( proccess.Attacker.IsPlayer() )
                proccess.Attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_DMG_ARM );
            return false;
        }
    }
    else
    {
        if( proccess.Attacker.Damage[ DAMAGE_RIGHT_ARM ] != 0 && proccess.Attacker.Damage[ DAMAGE_LEFT_ARM ] != 0 )
        {
            if( proccess.Attacker.IsPlayer() )
                proccess.Attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_DMG_TWO_ARMS );
            return false;
        }
    }

	uint8 use = _WeaponModeUse( weaponMode );
    int16 ammoRound = _WeaponRound( weapon, use ) - 1;
    const ProtoItem@ ammo = GetProtoItem( proccess.RealWeapon.AmmoPid );

    proccess.IsBurst = ( ammoRound > 1 && _WeaponNoBrust( weapon, use ) == 0 );
	
    if( !_WeaponeIsPerk( weapon, ammo, WEAPON_PERK_HEX_ATTACKING ) && !proccess.IsBurst )
        return false;
	
    int skillNum = _WeaponSkill( weapon, use ),
        weaponPerkFirst = weapon.Weapon_Perk,
        weaponPerkSecond = weapon.Weapon_SecondPerk,
        ammoPerk = ammo !is null ? ammo.Ammo_Perk : 0,
        dmgType = ( ammo !is null && ammo.Ammo_DmgType != 0 ) ? ammo.Ammo_DmgType : _WeaponDmgType( weapon, use );

    proccess.Aim = _WeaponModeAim( weaponMode );
    proccess.WeaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS || skillNum == SK_TRAPS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );

    bool isUnarmed = weapon.Weapon_IsUnarmed,
         isHthAttack = ( proccess.WeaponSubtype == WS_UNARMED ),
         isGrenade = proccess.WeaponSubtype == WS_THROWING && dmgType != DAMAGE_NORMAL;
		 
    if( proccess.IsBurst ) proccess.Aim = HIT_LOCATION_UNCALLED;
    if( isGrenade )
        ammoRound = 0;

    string@ soundName = "WAXXXXX1.ACM";
    soundName[ 2 ] = _WeaponSoundId( weapon, use );
    soundName[ 3 ] = proccess.IsBurst ? '2' : '1';

    Map@ map = proccess.Attacker.GetMap();
    if( ( !proccess.IsBurst && ammoRound > proccess.RealWeapon.AmmoCount ) || ( proccess.WeaponSubtype != WS_THROWING && proccess.RealWeapon.AmmoCount == 0 ) )
    {
        if( proccess.Attacker.IsPlayer() )
            proccess.Attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_OUT_OF_AMMO );
        soundName[ 1 ] = 'O';
        map.PlaySound( soundName );
        return false;
    }
    map.PlaySound( soundName );
    if( proccess.RealWeapon.IsDeteriorable()  && proccess.Attacker.IsPlayer() && proccess.Attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
        DeteriorateItem( proccess.Attacker, proccess.RealWeapon, ( ( ( MAX_SKILL_VAL - ( ( proccess.Attacker.Skill[ skillNum ] * 90 ) / 100 ) ) / 3 ) * ( 90 + proccess.RealWeapon.Proto.BrokenCoefficient * 10 ) ) / ( proccess.IsBurst ? 33 : 100 ) );

    proccess.BloodyMess = proccess.Attacker.Trait[ TRAIT_BLOODY_MESS ] != 0;
    proccess.CombatMessage = true;
    proccess.ScoreUnarmed = ( proccess.WeaponSubtype == WS_UNARMED );
    proccess.FirstWeaponPerk = ( isUnarmed && weapon.Weapon_UnarmedArmorPiercing ) ? WEAPON_PERK_PENETRATE : weaponPerkFirst;
    proccess.SecondWeaponPerk = weaponPerkSecond;
    proccess.AmmoPerk = ammo !is null ? int(ammo.Ammo_Perk) : -1;
	
    proccess.DmgMin = _WeaponDmgMin( weapon, use );
    proccess.DmgMax = _WeaponDmgMax( weapon, use );
    proccess.AmmoPid = proccess.RealWeapon.AmmoPid;
    if( @proccess.RealWeapon !is null )
    {
        proccess.DmgMin += proccess.RealWeapon.WeaponBonus_MinDamage;
        proccess.DmgMax += proccess.RealWeapon.WeaponBonus_MaxDamage;
    }
    proccess.TypeDamage = dmgType;
    proccess.BonusDmg = 0;

    if( isHthAttack || ( proccess.WeaponSubtype == WS_THROWING && !isGrenade ) )
    {
        proccess.DmgMax += proccess.Attacker.Stat[ ST_MELEE_DAMAGE ];
        proccess.DmgMin += proccess.Attacker.Stat[ ST_MELEE_DAMAGE ];
    }
    if( proccess.WeaponSubtype == WS_GUN )
        proccess.BonusDmg += proccess.Attacker.Perk[ PE_BONUS_RANGED_DAMAGE ] * 2;
    // Ammo
    if( ammo !is null )
    {
        proccess.DRMod = ammo.Ammo_DrMod;
        proccess.DMMod = ammo.Ammo_DmgMult;
        proccess.DDMod = ammo.Ammo_DmgDiv;
        proccess.TDMod = ammo.Ammo_DTDiv;
    }
    proccess.DmgMul = proccess.DMMod;

    startCombatTimeout( proccess.Attacker, false );
	
    // Снимаем сник с стреляющего.
    if( proccess.Attacker.IsNpc() || proccess.Attacker.GetAccess() != ACCESS_ADMIN )
        proccess.Attacker.ModeBase[ MODE_HIDE ] = 0;
    proccess.Attacker.SetDir( GetDirection( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy ) ); // Поворачиваем криттер в сторону выстрела.

    uint ExplodeId = 0;

    bool isRocket = ( proccess.AmmoPid == PID_CANNON_BALLS_FRAG ) || ( proccess.AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( proccess.AmmoPid == PID_ROCKET_AP ) || ( proccess.AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( proccess.AmmoPid == PID_EMP_ROCKET ) || ( proccess.AmmoPid == PID_NUKE_ROCKET ) || ( proccess.AmmoPid == PID_ROCKET_FIRE ),
         Explode = ( ( isRocket ) || ( proccess.WeaponPid == PID_MOLOTOV_COCKTAIL ) || ( proccess.WeaponPid == PID_FRAG_GRENADE ) ||
                     ( proccess.WeaponPid == PID_PULSE_GRENADE ) || ( proccess.WeaponPid == PID_PLASMA_GRENADE ) || ( proccess.WeaponPid == PID_PLASMA_CANNON ) || ( proccess.WeaponPid == PID_GRANADE_REVOLV_I ) || ( proccess.WeaponPid == PID_GRANADE_REVOLV_II ) || ( proccess.WeaponPid == PID_GRANADE_PISTOL ) || ( proccess.WeaponPid == PID_REVOLV_GRENADE ) ||
                     ( proccess.WeaponPid == PID_HOLY_HAND_GRENADE ) ||
                     proccess.WeaponPid == PID_FIRE_GRENADE ),
         _quakeScreen = ( Explode && proccess.WeaponPid != PID_PLASMA_CANNON && proccess.WeaponPid != PID_MOLOTOV_COCKTAIL && proccess.WeaponPid != PID_FIRE_GRENADE && proccess.AmmoPid != PID_ROCKET_FIRE );

    uint16 radius = weapon.HexWeapon_Radius;

    if( Explode || skillNum == SK_TRAPS )
    {
        if( radius == 0 )
        {
            radius = ( proccess.WeaponPid == PID_GRANADE_REVOLV_I || proccess.WeaponPid == PID_GRANADE_REVOLV_II || proccess.WeaponPid == PID_GRANADE_PISTOL || proccess.WeaponPid == PID_REVOLV_GRENADE ) ? 1 : 2;
            if( proccess.AmmoPid == PID_NUKE_ROCKET )
                radius = 35;
        }
        switch( proccess.WeaponPid )
        {
        case PID_MOLOTOV_COCKTAIL:
            ExplodeId = PID_EXPLODE_FIRE_BIG;
            break;
        case PID_FIRE_GRENADE:
            ExplodeId = PID_EXPLODE_FIRE_BIG;
            break;
        case PID_FRAG_GRENADE:
        case PID_HOLY_HAND_GRENADE:
            ExplodeId = PID_EXPLODE_FIRE_SMALL;
            break;
        case PID_PULSE_GRENADE:
            ExplodeId = PID_EXPLODE_EMP;
            break;
        case PID_PLASMA_GRENADE:
        case PID_PLASMA_CANNON:
            ExplodeId = PID_EXPLODE_PLASMA;
            break;

        default:
        {

            if( isRocket )
            {
                if( proccess.AmmoPid == PID_EMP_ROCKET )
                    ExplodeId = PID_EXPLODE_EMP;
                else if( proccess.AmmoPid == PID_NUKE_ROCKET )
                    ExplodeId = PID_EXPLODE_NUKLEAR;
                else
                    ExplodeId = PID_EXPLODE_ROCKET;
            }
            else
                ExplodeId = PID_EXPLODE_FIRE_BIG;
        } break;
        }
    }

	if( !proccess.IsBurst )
	{
		int margin = ToHitMutual( map, proccess.Attacker, weapon, ammo, weaponMode, proccess.TargetHx, proccess.TargetHy, !proccess.IsBurst ) - Random( 1, 100 );
		// Дополнительная обработка трейта Jinxed
		
		if( margin >= 0 && ( proccess.Attacker.Trait[ TRAIT_JINXED ] != 0 || proccess.Attacker.Perk[ PE_JINXED_II ] != 0 ) )
			margin = Random( 1, 100 ) - 10 + proccess.Attacker.Stat[ ST_LUCK ] / 2;

		if( margin < 0 )          // Криттер промазал. Расчитаем куда.
		{
			if( proccess.Attacker.IsPlayer() )
				proccess.Attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, 109 );
			if( Random( proccess.Attacker.Stat[ ST_LUCK ], 100 ) >= 10 )        // Проверяем на удачу, вдруг попал в себя.
				map.GetHexCoord( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, Random( margin, ABS( margin ) ), Random( 1, _WeaponMaxDist( weapon, use ) ) );
			else
			{
				proccess.TargetHx = proccess.Hx;
				proccess.TargetHy = proccess.Hy;
			}
		}
	}

    switch( proccess.WeaponPid )   // Особый эффект оружия(не визуальный)
    {
		case PID_SMOKE_GRENADE:
			SmokeBlast( map, proccess.TargetHx, proccess.TargetHy, PID_SMOKE, proccess.Attacker.Id );
			break;
			
		case PID_MUSTARD_GAS_GRENADE:
			SmokeBlast( map, proccess.TargetHx, proccess.TargetHy, PID_MUSTARD_GAS, proccess.Attacker.Id );
			break;
			
		default:
			break;
    }

	int attack_type = _WeaponAttackType( weapon, use );
	if( proccess.AmmoPerk == WEAPON_PERK_HEX_ATTACKING )
		attack_type = WTA_RADIUS_HEX;

	uint rounds = _WeaponRound( weapon, use );
    switch( attack_type )     // Эффект летящего снаряда
    {
		case WTA_LINE_IGNORED_RAKED:
		{
			CTraceLineIgnoredRaked Trace( proccess, map, proccess.Attacker, proccess.RealWeapon, proccess.TargetHx, proccess.TargetHy );
			LineTracerHex( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, map, _WeaponMaxDist( weapon, use ), Trace );
			Trace.EndTrace( proccess.RealWeapon );
			map.RunFlyEffect( _WeaponEffect( proccess.RealWeapon.Proto, use ), null, null, proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0 );
		} break;
		
		case WTA_LINE_FLAME:
		{
			FlameLine( proccess, proccess.RealWeapon, proccess.TargetHx, proccess.TargetHy );
			uint16 effect = _WeaponEffect( proccess.RealWeapon.Proto, use );
			if( effect != 0 )
				map.RunFlyEffect( effect, null, null, proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0 );                  // Запускаем летящий снаряд.
		} break;

		case WTA_RADIUS_HEX:
		{
			uint16 effect = _WeaponEffect( weapon, use );
			if( effect != 0 )
			{
				const ::ProtoItem@ protoEffect = ::GetProtoItem( effect );		
				if( @protoEffect !is null )
				{
					map.RunFlyEffect( effect, null, null, proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, ExplodeId | radius << 16 ); // Запускаем летящий снаряд.
					
					CTraceTime trace;
					trace.HexX = proccess.TargetHx;
					trace.HexY = proccess.TargetHy;
					trace.Time = protoEffect.EffectSpeed;
					
					int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
					GetHexInterval( proccess.Hx, proccess.Hy, trace.HexX, trace.HexY, x1, y1 );
					GetHexInterval( trace.HexX, trace.HexY, proccess.Hx, proccess.Hy, x2, y2 );
					TimeHexAttackData data;
					@data.proccess = proccess;
					@data.map = map;
					data.radius = radius;
					data.quakeScreen = _quakeScreen;
					CreateTimeEvent( __FullSecond + ( DISTANCE( x1, y1, x2, y2 ) * 0.1/protoEffect.EffectSpeed ), e_TimeHexAttack, data );
				}
			}
			else
				DamageHex( proccess, map, radius, _quakeScreen );


			if( proccess.TypeDamage == DAMAGE_FIRE )
				SetFire( map, proccess.TargetHx, proccess.TargetHy, radius, Random( proccess.DmgMin, proccess.DmgMax ), proccess.Attacker );

			if( ammoRound > 0 && ammoRound < 50 && proccess.IsBurst )
			{
				uint[] values = { ammoRound, map.Id, proccess.Attacker.Id, proccess.RealWeapon.Id, proccess.TargetHx, proccess.TargetHy, radius, dmgType, ( Explode ? ExplodeId : 0 ), _quakeScreen ? 1 : 0 };
				CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME, "e_ReAtack", values, false );
			}
		} break;
		
		default:
		{
			if( ( _WeaponRound( weapon, use ) > 1 && proccess.IsBurst ) || WTA_BURST_REGION == _WeaponAttackType( weapon, use ) )
			{
			
				if( WTA_BURST_REGION == _WeaponAttackType( weapon, use ) )
				{
					FullReplayAttack@ replay = cast<FullReplayAttack@>(@proccess.Context);
					if( replay is null )
					{
						@replay = FullReplayAttack();
						@replay.map = map;
						@replay.proccess = proccess;
						replay.stage = 0;
						replay.weaponMode = weaponMode;
						replay.targetX = defHexX;
						replay.targetY = defHexY;
						@proccess.Context = replay;
					}
					if( proccess.Attacker.TimeAttackId > 0 )
						EraseTimeEvent( proccess.Attacker.TimeAttackId );

					if( weapon.Weapon_BulletProgression != 0 )
						rounds = 1 + replay.stage != 0 ? replay.stage/weapon.Weapon_BulletProgression : 0;
					proccess.Attacker.TimeAttackId = CreateTimeEvent( __FullSecond + REAL_MS( _WeaponTimeAttack( proccess.RealWeapon.Proto, use ) ), e_FullReplayAtack, replay );
				}
				
				CombatAlgoritm@ algoritm = GetCombatAlgoritm( proccess );
				if( algoritm !is null )
				{
					@algoritm.realTarget = null;
					@algoritm.results = CombatRes[](0);
					algoritm.weaponUse = use;
					algoritm.baseToHit = proccess.Attacker.Skill[ skillNum ];
					algoritm.distmod1 = 2;
					algoritm.distmod2 = 0;
					algoritm.accloss = ( proccess.Attacker.IsPlayer() ? ( proccess.Attacker.Stat[ST_PERCEPTION] - 2 ) * algoritm.distmod1 : ( proccess.Attacker.Stat[ST_PERCEPTION] * algoritm.distmod1 ) );
					algoritm.isCritical = false;
					algoritm.isHit = false;
					algoritm.changedTarget = false;
					algoritm.useHex = false;
					algoritm.useNormal = false;
					algoritm.weaponMode = weaponMode;
					algoritm.rounds = rounds;
					
					algoritm.Proccess( );
					FlushResults( algoritm.results );
				}
				else proccess.Attacker.Say( SAY_NETMSG, "Combat error: weapon PID=" + proccess.WeaponPid + " not handled, please send bug report." );  // combat messages
				break;
			}
			
			uint16 effect = _WeaponEffect( weapon, use );
			if( effect != 0 )
			{
				const ::ProtoItem@ protoEffect = ::GetProtoItem( effect );		
				if( @protoEffect !is null )
				{
					map.RunFlyEffect( effect, null, null, proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, ExplodeId | radius << 16 ); // Запускаем летящий снаряд.
					
					CTraceTime trace;
					trace.HexX = proccess.TargetHx;
					trace.HexY = proccess.TargetHy;
					trace.Time = protoEffect.EffectSpeed;
					
					int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
					GetHexInterval( proccess.Hx, proccess.Hy, trace.HexX, trace.HexY, x1, y1 );
					GetHexInterval( trace.HexX, trace.HexY, proccess.Hx, proccess.Hy, x2, y2 );
					TimeHexAttackData data;
					@data.proccess = proccess;
					@data.map = map;
					data.radius = radius;
					data.quakeScreen = _quakeScreen;
					CreateTimeEvent( __FullSecond + ( DISTANCE( x1, y1, x2, y2 ) * 0.1/protoEffect.EffectSpeed ), e_TimeHexAttack, data );
				}
			}
			else
				DamageHex( proccess, map, radius, _quakeScreen );


			if( proccess.TypeDamage == DAMAGE_FIRE )
				SetFire( map, proccess.TargetHx, proccess.TargetHy, radius, Random( proccess.DmgMin, proccess.DmgMax ), proccess.Attacker );

			if( ammoRound > 0 && ammoRound < 50 && proccess.IsBurst )
			{
				uint[] values = { ammoRound, map.Id, proccess.Attacker.Id, proccess.RealWeapon.Id, proccess.TargetHx, proccess.TargetHy, radius, dmgType, ( Explode ? ExplodeId : 0 ), _quakeScreen ? 1 : 0 };
				CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME, "e_ReAtack", values, false );
			}
			
		} break;
    }
	
	// Вычитаем патроны.
    if( proccess.Attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
    {
		int slot = proccess.RealWeapon.CritSlot;
		uint protoid = proccess.RealWeapon.GetProtoId();
        if( !_WeaponRemove( weapon, use ) )
        {
            if( rounds < proccess.RealWeapon.AmmoCount )
                proccess.RealWeapon.AmmoCount -= rounds;
            else
            {
                if( proccess.RealWeapon.AmmoCount > 0 )
                    ammoRound = proccess.RealWeapon.AmmoCount - 1;
                proccess.RealWeapon.AmmoCount = 0;
            }
			
			proccess.RealWeapon.Update( );
        }
        else
        {
			{
				Item@ stack = proccess.Attacker.GetStackItem( proccess.RealWeapon, true );
				if( stack is null )
				{
					if( skillNum == SK_THROWING && !isGrenade )
					{
						proccess.RealWeapon.EventDrop( proccess.Attacker );
						MoveItem( proccess.RealWeapon, 1, map, proccess.TargetHx, proccess.TargetHy );
					}
					else DeleteItem( proccess.RealWeapon );
					
					Item@[] items;
					for( uint i = 0, iEnd = proccess.Attacker.GetItems( SLOT_INV, items ); i < iEnd; i++ )
						if( validEngineObject( items[ i ] ) && items[ i ].GetProtoId() == protoid )
						{
							proccess.Attacker.MoveItem( items[ i ].Id, 1, slot );
							//items[ i ].Mode = weaponMode;
							items[ i ].Update( );
							// Mode
							break;
						}
				}
				else
				{
					if( skillNum == SK_THROWING && !isGrenade )
					{
						stack.EventDrop( proccess.Attacker );
						MoveItem( stack, 1, map, proccess.TargetHx, proccess.TargetHy );
					}
					else
					{
						uint count = stack.GetCount();
						if( count > 1 )
						{
							stack.SetCount( count - 1 );
							stack.Update();
						}
						else DeleteItem( stack );
					}
				}
			}
        }
    }

    proccess.Attacker.Animate( 0, _WeaponAnim2( weapon, use ), null, true, false );

    if( ExplodeId == PID_EXPLODE_NUKLEAR )
    {
        uint[] values = { 22, map.Id, proccess.Attacker.Id, proccess.RealWeapon.Id, proccess.TargetHx, proccess.TargetHy, 1, dmgType, PID_EXPLODE_FIRE_BIG, _quakeScreen ? 1 : 0 };
        CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME * 10, "e_ReAtack", values, false );
    }

    return true;
}

void FlameLine( CombatProccess& proccess, Item& item, uint16 dx, uint16 dy )
{
    Map@     map = proccess.Attacker.GetMap();

    uint16 wx = 0,
             wy = 0;

    uint dist = _WeaponMaxDist( item.Proto, item.Mode );

    uint radius = 1;
    uint dir = 0;
    map.GetHexCoord( proccess.TargetHx, proccess.TargetHy, dx, dy, 0, dist );


    uint[] AllHex, targetIds;
    bool[] isFlameDirect = { true, true, true };

    for( uint n = 0; n < dist; n++ )
    {
        dir = GetDirection( proccess.TargetHx, proccess.TargetHy, dx, dy );
        map.MoveHexByDir( proccess.TargetHx, proccess.TargetHy, dir, 1 );
        wx = proccess.TargetHx;
        wy = proccess.TargetHy;
        if( !map.IsHexRaked( wx, wy ) )
            break;

        uint d = 0;

        for( uint r = 0; r < radius; r++ )
        {
            if( proccess.Attacker.HexX == wx && proccess.Attacker.HexY == wy )
                continue;
            if( map.IsHexRaked( wx, wy ) )
            {
                if( isFlameDirect[ d ] )
                {
                    if( !TargetHex( wy * map.GetWidth() + wx, AllHex ) )
                    {
                        DamageHex( proccess, map, 1, false, targetIds );
                        SetFire( map, wx, wy, 1, Random( proccess.DmgMin, proccess.DmgMax ), proccess.Attacker );
                    }
                }
            }
            else
                isFlameDirect[ d ] = false;
            wx = proccess.TargetHx;
            wy = proccess.TargetHy;
            d = ( r % 2 == 0 ) ? d = 1 : d = 2;
            map.MoveHexByDir( wx, wy, ( r % 2 == 0 ) ? ( dir + 1 ) % 6 : ( dir - 1 ) % 6, r / 2 + 1 );
        }
        if( radius - 1 < item.Proto.HexWeapon_Radius )
            radius++;
    }
}

void DamageHex( CombatProccess& proccess, Map& map, uint16 radius, bool _quakeScreen, uint[]@ target_ids = null )
{
    if( _quakeScreen )
        QuakeScreen( map );

    proccess.Attacker.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( proccess.Attacker );

    Critter@[] critters;
    Critter@ c = null;
    int skillNum = _WeaponSkill( proccess.RealWeapon.Proto, _WeaponModeUse( proccess.RealWeapon.Mode ) );
    {
        int  criticalChanceDef = 0;
        {
            int aAim = proccess.Aim;
            if( aAim == HIT_LOCATION_UNCALLED || aAim == HIT_LOCATION_NONE || aAim == HIT_LOCATION_TORSO )
                criticalChanceDef = proccess.Attacker.Stat[ ST_CRITICAL_CHANCE ] + ( proccess.Attacker.Trait[ TRAIT_FINESSE ] != 0 ? 10 : 0 ) + proccess.Attacker.Perk[ PE_MORE_CRITICALS ] * 5;
            if( proccess.RealWeapon !is null )
            {
                criticalChanceDef += proccess.RealWeapon.WeaponBonus_CritChance + proccess.RealWeapon.Proto.Weapon_CriticalBonus;
                switch( skillNum )
                {
                case SK_SMALL_GUNS:
                case SK_BIG_GUNS:
                case SK_ENERGY_WEAPONS:
                    criticalChanceDef += proccess.Attacker.BookBonus[ BB_RANGED_CRIT ];
                    break;                                                                                              // бонус от книг. ++Cracker
                case SK_UNARMED:
                case SK_THROWING:
                    criticalChanceDef += proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT ];
                    break;                                                                                                     // бонус от книг. ++Cracker
                default:
                    break;
                }
            }
        }
        bool   isCritical = false;
        if( proccess.RealWeapon !is null && proccess.WeaponPid == PID_JACKAL && proccess.RealWeapon.AmmoPid == PID_JACKAL_WALKING_MINE )
        {
            map.GetHexCoord( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0, 0 );
            int[] params = { SK_TRAPS, proccess.Attacker.Skill[ SK_TRAPS ], MODE_HIDE, 1, SK_SNEAK, proccess.Attacker.Skill[ SK_TRAPS ], MERC_MASTER_ID, proccess.Attacker.Id, ST_FACTION, proccess.Attacker.Stat[ ST_FACTION ] };
            Critter@ npc = map.AddNpc( NPC_WALKING_MINE, proccess.TargetHx, proccess.TargetHy, 0, params, null, "walking_mine@_WalkingMineInit" );
            if( npc !is null )
                CreateTimeEvent( __FullSecond + REAL_SECOND( 90 ), "e_EventDead", npc.Id, false );
            return;
        }
        uint iMax = map.GetCrittersHex( proccess.TargetHx, proccess.TargetHy, MAX( 0, int(radius - 1) ), FIND_LIFE_AND_KO, critters );
        for( uint i = 0; i < iMax; i++ )
        {
            @ c = critters[ i ];
            if( c !is null )
            {
				if( target_ids !is null )
				{
					if( target_ids.find( c.Id ) == -1 )
						target_ids.insertLast( c.Id );
					else continue;
				}
				
                uint16 traceHexX = c.HexX,                                                                              // TabaK. Фикс пробивания стен взрывом.
                       traceHexY = c.HexY;
                map.GetHexCoord( proccess.TargetHx, proccess.TargetHy, traceHexX, traceHexY, 0, 0 );
                if( traceHexX != c.HexX || traceHexY != c.HexY )
                    continue;
                if( proccess.WeaponPid == PID_JACKAL )
                {
                    Item@ mine = c.AddItem( PID_JACKAL_MINE_ACTIVE, 1 );
                    if( mine !is null )
                    {
                        mine.LockerId = proccess.RealWeapon.Id;
                        mine.Val2 = proccess.Attacker.Id;
                        mine.Val3 = proccess.Attacker.Skill[ skillNum ];
                        c.EventAttacked( proccess.Attacker );
                        c.PlaySound( "FLRTRAP.ACM", c.IsPlayer() );
                        return;
                    }
                }
                else if( proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
                {
                    MoveItem( proccess.RealWeapon, 1, c );
                    c.PlaySound( "FLRTRAP.ACM", c.IsPlayer() );
                }
                if( !( c.IsDead() ) )
                {
                    /*if( ExplodeId == PID_EXPLODE_NUKLEAR )
                    {
                        AffectRadiation( c, Random( 340, 460 ) );
                        proccess.TypeDamage = DAMAGE_FIRE;
                    }*/
                    if( c.IsNpc() || c.GetAccess() != ACCESS_ADMIN )
                        c.ModeBase[ MODE_HIDE ] = 0;
                    c.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( c );
                    isCritical = ( Random( 1, 100 ) <= criticalChanceDef );
                    int antiCriticalRes = criticalChanceDef > 100 ? criticalChanceDef - 100 : 0;
                    if( isCritical && Random( 1, 100 ) <= ( c.Stat[ ST_CRITICAL_RESISTANCE ] - antiCriticalRes ) )
                        isCritical = false;

					EventSmthAttack( proccess.Attacker, c );
                    CombatRes[] results;
                    critter_attack( proccess.Attacker, c );
                    ApplyDamage( proccess, c, 1, isCritical, true, results );
                    FlushResults( results );
                }
            }
        }
        if( iMax == 0 )
        {
            if( proccess.WeaponPid == PID_JACKAL || proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
            {
                if( !map.IsHexPassed( proccess.TargetHx, proccess.TargetHy ) )
                    map.GetHexCoord( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0, proccess.Distantion );
                Item@ mine = map.GetItem( proccess.TargetHx, proccess.TargetHy, PID_JACKAL_MINE_ACTIVE );
                if( mine !is null )
                {
                    uint duration = 0;
                    uint[] values;
                    if( GetTimeEvent( mine.Val1, duration, values ) )
                    {
                        SetTimeEvent( mine.Val1, 0, values );
                    }
                    else
                        CreateTimeEvent( __FullSecond, "e_Explode", mine.Id, false );
                    if( proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
					{
                        DeleteItem( proccess.RealWeapon );
						@proccess.RealWeapon = null;
                    }
					return;
                }
                else if( proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
                {
                    MoveItem( proccess.RealWeapon, 1, map, proccess.TargetHx, proccess.TargetHy );
                    proccess.RealWeapon.EventDrop( proccess.Attacker );
                    return;
                }
                @mine = map.AddItem( proccess.TargetHx, proccess.TargetHy, PID_JACKAL_MINE_ACTIVE, 1 );
                if( mine !is null )
                {
                    mine.LockerId = proccess.RealWeapon.Id;
                    mine.Val2 = proccess.Attacker.Id;
                    mine.Val3 = proccess.Attacker.Skill[ skillNum ];
                    return;
                }
            }
        }

        /*if( ExplodeId == PID_EXPLODE_NUKLEAR )
        {
            critters.resize( 0 );
            for( uint i = 0, iMax = map.GetCritters( 0, FIND_LIFE_AND_KO, @critters ); i < iMax; i++ )
                AffectRadiation( critters[ i ], Random( 230, 340 ) );
        }*/
    }

    Item@[] items = GetItems( map, proccess.TargetHx, proccess.TargetHy, radius );

    Item@ it = null;
    for( uint i = 0, iMax = items.length(); i < iMax; i++ )
    {
        @ it = items[ i ];
        if( it !is null )
            ItemDamage( it, Random( proccess.DmgMin, proccess.DmgMax ) );
    }
}

Item@[] GetItems( Map& map, uint16 hexX, uint16 hexY, uint radius )
{
    Item@[] items;
    {
        uint16 yMax = hexY + radius,
               yMin = hexY - radius,

               xMax = hexX + radius,
               xMin = hexX - radius,

               MapWidth = map.GetWidth(),
               MapHeight = map.GetHeight();

        if( MapWidth < xMax )
            xMax = MapWidth;
        if( xMin < 0 )
            xMin = 0;
        if( MapHeight < yMax )
            yMax = MapHeight;
        if( yMin < 0 )
            yMin = 0;
		
		uint16 hy = 0,
		         hx = 0;
		
        for( hx = xMin; hx < xMax; hx++ )
            for( hy = yMin; hy < yMax; hy++ )
                map.GetItems( hx, hy, @items );
    }
    return items;
}

void ItemDamage( Item& it, uint TotalDamag )
{
    uint16 x = 0, y = 0, itPid = it.GetProtoId();
    Map@   map = it.GetMapPosition( x, y );
    bool   bVar = false;
    uint   heal = 0;

    switch( itPid )
    {
    // Мешки
    case PID_SANDBAG_1:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_2:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 2 );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_3:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 3 );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_4:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 4 );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_5:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 5 );
            heal = it.CurrentHp;
        }

        if( TotalDamag >= heal )
        {
            DeleteItem( it );
        }
        else
        {
            heal -= TotalDamag;
            if( heal <= 100 )
            {
                if( !ChangeProto( it, PID_SANDBAG_1 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            else if( heal <= 200 )
            {
                if( !ChangeProto( it, PID_SANDBAG_2 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            else if( heal <= 300 )
            {
                if( !ChangeProto( it, PID_SANDBAG_3 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            else if( heal <= 400 )
            {
                if( !ChangeProto( it, PID_SANDBAG_4 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            it.CurrentHp = uint( heal );
        }
    }       break;

    // PID_ACTIVE_MINE
    // 40% что погексовка ущерба не принесёт
    // 30% что мин просто будет уничтожен, без детонации
    // 30% что мин сдетонирует.
    case PID_ACTIVE_MINE:
    {
        uint chance = Random( 1, 100 );
        if( chance >= 70 )
        {
            DeleteItem( it );
        }
        else if( chance >= 40 )
        {
            CreateTimeEvent( __FullSecond, "explode@e_Explode", it.Id, false );
        }
    } break;
    // Пластид.
    // 65% что погексовка ущерба не принесёт
    // 20% что пластид просто будет уничтожен, без детонации
    // 15% что пластид сдетонирует.
    case PID_ACTIVE_PLASTIC_EXPLOSIVE:
    {
        uint chance = Random( 1, 100 );
        if( chance >= 80 )
        {
            DeleteItem( it );
        }
        else if( chance >= 65 )
        {
            Critter@ c = null;
            uint     ownerId = it.Val2;
            int      bD = it.Val3;
            int      bR = it.Val4;
            Explode( map, x, y, c, itPid, ownerId, bD, bR );
            DeleteItem( it );
        }
    } break;

    default:
        break;
    }

    if( it.GetType() == ITEM_TYPE_DOOR )
    {
        if( it.GetScriptId() != 0 ||
            ( ( it.LockerCondition ) & ( LOCKER_NOOPEN | LOCKER_ELECTRO | LOCKER_NOUSE ) ) != 0 ||
            it.LockerComplexity > 299 )
            return;
        if( it.CurrentHp == 0 )
            it.CurrentHp = uint( HP_DOOR );
        heal = it.CurrentHp;
        TotalDamag = ( TotalDamag - ( TotalDamag * it.Proto.Material ) / 10 );
        if( TotalDamag >= heal )
        {
            uint[] values = { map.Id, x, y, it.GetProtoId(), it.LockerComplexity };
            it.LockerOpen();
            DeleteItem( it );
            CreateTimeEvent( __FullSecond + TIMEOUT_RESTORE_DOOR, "e_RestoreDoor", values, true );
        }
        else
        {
            heal -= TotalDamag;
            it.CurrentHp = uint( heal );
        }
    }
}

bool ChangeProto( Item& item, uint pid )
{
	if( @GetProtoItem( pid ) is null )
	{
		Log( "Невалиден прототип предмета под пидом: " + pid );
		return false;
	}
	
	return item.ChangeProto( pid );
}

uint e_ReAtack( uint[] @ values )
{
    Map@     map = GetMap( values[ 1 ] );
    Critter@ critter = GetCritter( values[ 2 ] );
    Item@    item = GetItem( values[ 3 ] );
    if( item is null || critter is null || map is null )
        return 0;

    uint16           ammoPid = item.AmmoPid;

    const ProtoItem@ weapon = item.Proto,
                     ammo = GetProtoItem( ammoPid );
    if( weapon is null )
        return 0;
    int weaponPerkFirst = weapon.Weapon_Perk,
        weaponPerkSecond = weapon.Weapon_SecondPerk,
        ammoPerk = ammo !is null ? ammo.Ammo_Perk : 0;
    if( !isWeaponPerk( WEAPON_PERK_HEX_ATTACKING ) )
    {
        return 0;
    }

    int skillNum = _WeaponSkill( weapon, item.Mode ),
        dmgType = _WeaponDmgType( weapon, item.Mode );

    uint8 aim = _WeaponModeAim( item.Mode ),
          weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );

    bool isHthAttack = ( weaponSubtype == WS_UNARMED ),
         isGrenade = weaponSubtype == WS_THROWING && dmgType != DAMAGE_NORMAL;

    CombatProccess@ proccess = CombatProccess();
    proccess.WeaponPid = weapon.ProtoId;
    @proccess.Attacker = critter;
    @proccess.RealWeapon = item;
    proccess.Hx = critter.HexX;
    proccess.Hy = critter.HexY;
    proccess.TargetHx = values[ 4 ];
    proccess.TargetHy = values[ 5 ];
    proccess.Aim = aim;
    proccess.IsBurst = false;
    proccess.BloodyMess = critter.Trait[ TRAIT_BLOODY_MESS ] != 0;
    proccess.CombatMessage = true;
    proccess.ScoreUnarmed = ( weaponSubtype == WS_UNARMED );
    proccess.WeaponSubtype = weaponSubtype;
    proccess.DmgMin = _WeaponDmgMin( weapon, item.Mode );
    proccess.DmgMax = _WeaponDmgMax( weapon, item.Mode );
    proccess.DmgMin += item.WeaponBonus_MinDamage;
    proccess.DmgMax += item.WeaponBonus_MaxDamage;
    proccess.TypeDamage = dmgType;
    proccess.BonusDmg = 0;

    if( isHthAttack || ( weaponSubtype == WS_THROWING && !isGrenade ) )
    {
        proccess.DmgMax += proccess.Attacker.Stat[ ST_MELEE_DAMAGE ];
        proccess.DmgMin += proccess.Attacker.Stat[ ST_MELEE_DAMAGE ];
    }
    if( weaponSubtype == WS_GUN )
        proccess.BonusDmg += proccess.Attacker.Perk[ PE_BONUS_RANGED_DAMAGE ] * 2;
    // Ammo
    if( ammo !is null )
    {
        proccess.DRMod = ammo.Ammo_DrMod;
        proccess.DMMod = ammo.Ammo_DmgMult;
        proccess.DDMod = ammo.Ammo_DmgDiv;
        proccess.TDMod = ammo.Ammo_DTDiv;
    }
    proccess.DmgMul = proccess.DMMod;

    bool   _quakeScreen = values[ 9 ] == 1;
    if( weapon.ProtoId == PID_JACKAL )
    {
        uint8 dir = values[ 0 ] == 2 ? ( proccess.Attacker.Dir + 2 ) % 6 : ( proccess.Attacker.Dir + 4 ) % 6;
        map.MoveHexByDir( proccess.TargetHx, proccess.TargetHy, dir, 2 );
    }
    else
    {
        proccess.TargetHx += Random( -1, 1 );
        proccess.TargetHy += Random( -1, 1 );
    }

    if( ammoPid != PID_NUKE_ROCKET )
        map.RunFlyEffect( _WeaponEffect( item.Proto, item.Mode ), null, null, proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, values[ 8 ] | values[ 6 ] << 16 );                           // Запускаем летящий снаряд.

    DamageHex( proccess, map, values[ 6 ], _quakeScreen );

    if( values[ 0 ] > 1 )
    {
        if( ammoPid == PID_NUKE_ROCKET )
        {
            values[ 6 ] += 1;
        }

        uint[] newValues = { values[ 0 ] - 1, values[ 1 ], values[ 2 ], values[ 3 ], values[ 4 ], values[ 5 ], values[ 6 ], values[ 7 ], ( values[ 8 ] > 0 ? values[ 8 ] : 0 ), _quakeScreen ? 1 : 0 };
        CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME / 2, "e_ReAtack", newValues, false );
    }
    return 0;
}

class FullReplayAttack : iCombatProccessContext, TimeEventDescriptor
{
	CombatProccess@ proccess;
	uint stage;
	Map@ map;
	uint8 weaponMode;
	uint16 targetX;
	uint16 targetY;
	
	uint Replay()
	{
		if( proccess.Context !is this )
			return 0;

		Critter@ critter = proccess.Attacker;
		if( @critter is null || !critter.IsLife() ) 
			return 0;
		
		Item@ realWeapon = proccess.RealWeapon;
		if( @realWeapon is null ) return 0;
		
		if( critter.TimeAttackId == 0 )
			return 0;
		
		if( map is null )
			return 0;
		if( critter.GetMap() !is map )
			return 0;
		
		if( critter.HexX != proccess.Hx || critter.HexY != proccess.Hy )
			return 0;

		stage++;
		const uint8 use = _WeaponModeUse( weaponMode );
		const int skillNum = _WeaponSkill( realWeapon.Proto, use );
		const uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );
		float apCost = MAX( 1, ( ( _WeaponApCost( realWeapon.Proto, use ) - realWeapon.WeaponBonus_AP - critter.Perk[ PE_BONUS_RATE_OF_FIRE ] ) - ( weaponSubtype == WS_GUN ? critter.Trait[ TRAIT_FAST_SHOT ] : 0 ) ) );
		apCost *= 25; 
		if( critter.Stat[ ST_CURRENT_AP ] * 100 >= apCost && Attack( critter, realWeapon, weaponMode, targetX, targetY, proccess ) )
			critter.StatBase[ ST_CURRENT_AP ] -= apCost; // Отнимает очки действия.
		return 0;
	}
}

uint e_FullReplayAtack( TimeEventDescriptor@ value )
{
	if( value is null )
		return 0;
	
	FullReplayAttack@ context = cast<FullReplayAttack@>(@value);
	if( context is null )
		return 0;	

    return context.Replay();
}

class TimeHexAttackData : TimeEventDescriptor
{
	CombatProccess@ proccess;
	Map@ map;
	uint radius;
	bool quakeScreen;
}

uint e_TimeHexAttack( TimeEventDescriptor@ value )
{
	TimeHexAttackData@ data = cast<TimeHexAttackData@>(@value);
	if( data is null ) return 0;
	DamageHex( data.proccess, data.map, data.radius, data.quakeScreen );
	return 0;
}

uint e_RestoreDoor( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( map is null )
        return 0;
    // if(map.IsHexPassed(values[1], values[2])==false) return __FullSecond+TIMEOUT_RESTORE_DOOR;
    Item@ door = map.GetDoor( values[ 1 ], values[ 2 ] );
    if( door !is null )
        return 0;
    @door = map.AddItem( values[ 1 ], values[ 2 ], values[ 3 ], 1 );
    door.LockerComplexity = values[ 4 ];
    door.LockerOpen();
    door.Update();
    return 0;
}

uint e_EventDead( uint[] @ vals )
{
    Critter@ critter = GetCritter( vals[ 0 ] );
    if( critter !is null )
        critter.EventDead( null );
    return 0;
}

void _SetBattleTimer( Critter& critter, uint index, int oldValue )
{
    if( critter.IsNpc() || critter.TimeoutBase[ index ] == 0 )
    {
        // Log("Timeout set to zero. Critter Id: "+critter.Id);
        critter.StatBase[ ST_BATTLE_DATA ] = 0;
        critter.StatBase[ ST_DAMAGE_RECEIVED ] = 0;
        critter.StatBase[ ST_DAMAGE_DONE ] = 0;
        return;
    }

    if( critter.Stat[ ST_BATTLE_DATA ] != 0 )
    {
        uint duration = 0;
        uint[] vals;
        if( GetTimeEvent( uint( critter.Stat[ ST_BATTLE_DATA ] ), duration, vals ) )
        {
            // Log("TimeEvent already found. Critter: "+critter.Id);
            if( vals.length() < 3 )
            {
                Log( "Warning! Battle stats fucked up! Data length: " + vals.length() );
                for( uint n = 0; n < vals.length(); n++ )
                    Log( "vals[" + n + "] = " + vals[ n ] );
                vals.resize( 3 );
                vals[ 0 ] = critter.Id;
                if( vals[ 1 ] == 0 )
                    vals[ 1 ] = __FullSecond;
            }
            vals[ 2 ] = __FullSecond;
            SetTimeEvent( uint( critter.Stat[ ST_BATTLE_DATA ] ), critter.TimeoutBase[ TO_BATTLE ] - __FullSecond, vals );
            return;
        }
    }
    uint[] values = { critter.Id, __FullSecond, __FullSecond };
    critter.StatBase[ ST_DAMAGE_RECEIVED ] = 0;
    critter.StatBase[ ST_DAMAGE_DONE ] = 0;
    critter.StatBase[ ST_BATTLE_DATA ] =
        int( CreateTimeEvent( critter.TimeoutBase[ index ], "e_BattleStat", values, false ) );
}

uint e_BattleStat( uint[] @ values )
{
    if( @values == null )
    {
        // Log("Values is null!");
        return 0;
    }
    if( values.length() < 3 )
    {
        Log( "Warning! Battle stats fucked up! Data length: " + values.length() );
        for( uint n = 0; n < values.length(); n++ )
            Log( "values[" + n + "] = " + values[ n ] );
        return 0;
    }
    Critter@ critter = GetCritter( values[ 0 ] );
    if( critter is null )
        return 0;
    uint   time = ( values[ 2 ] - values[ 1 ] ) / REAL_SECOND( 1 );
    uint16 dmg = ( critter.Stat[ ST_DAMAGE_DONE ] ) & 0xFFFF,
           kills = ( critter.Stat[ ST_DAMAGE_DONE ] >> 16 ) & 0xFFFF;
    float  dps = float(dmg) / MAX( 1, time );
    dps = ceil( dps * 100 ) / 100; // Округляем до сотых
    critter.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, 800, "$t" + time + "$d" + critter.Stat[ ST_DAMAGE_RECEIVED ] + "$k" + dmg + "$p" + dps + "$c" + kills );
    critter.StatBase[ ST_BATTLE_DATA ] = 0;
    critter.StatBase[ ST_DAMAGE_DONE ] = 0;
    critter.StatBase[ ST_DAMAGE_RECEIVED ] = 0;
    return 0;
}

class CTraceTime : ITraceContext
{
	uint16 HexX;
	uint16 HexY;
	uint Time;
    uint Result;
	
	CTraceTime( )
	{
		Time = 0;
		Result = 0;
	}
	
    bool ExecMutual( uint16 hx, uint16 hy )
    {
        Result += Time;
        return ( HexX == hx && HexY == hy );
    }
}

class CTraceLineIgnoredRaked : ITraceContext
{

    uint8  maxDir = 6;
    uint8  dir = 0;
    uint8  memDir = 0;

    uint16 currentHexX = 0;
    uint16 currentHexY = 0;
    uint16 targHexX = 0;
    uint16 targHexY = 0;
    uint16 memHexX = 0;
    uint16 memHexY = 0;

    uint8[] maxBlockCount;

    uint[]  minDamage;
    uint[]  maxDamage;

    Critter@[] lookCrs;
    uint                 countLookCrs = 0;
    Critter@             target;
    Item@[] items;
    Critter@             critter;
    int                  defDmgMin = 0;
    int                  defDmgMax = 0;

    CombatProccess@ proccess;

    int                  criticalChanceDef = 0;
    bool                 isCritical = false;

    uint[] AllHex;
	
	UpgradeItem::LineDamageData Data;

    CTraceLineIgnoredRaked( CombatProccess & attackArg, Map & map, Critter & critterArg, Item & item, uint16 & in hexX, uint16 & in hexY )
    {
		Data.Effect = PID_BLUE_LASER_EXPLOSION;
		Data.IsFire = false;
		Data.DamageMod = 0.01;
	
        @ critter = critterArg;
        @ proccess = attackArg;
        critter.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( critter );

        defDmgMin = proccess.DmgMin;
        defDmgMax = proccess.DmgMax;

        {
            int aAim = proccess.Aim;
            if( aAim == HIT_LOCATION_UNCALLED || aAim == HIT_LOCATION_NONE || aAim == HIT_LOCATION_TORSO )
                criticalChanceDef = critter.Stat[ ST_CRITICAL_CHANCE ] + ( critter.Trait[ TRAIT_FINESSE ] != 0 ? 10 : 0 ) + critter.Perk[ PE_MORE_CRITICALS ] * 5;
            if( proccess.RealWeapon !is null )
            {
                criticalChanceDef += proccess.RealWeapon.WeaponBonus_CritChance + proccess.RealWeapon.Proto.Weapon_CriticalBonus;
                uint use = 0;
                int  skillNum = _WeaponSkill( proccess.RealWeapon.Proto, use );
                switch( skillNum )
                {
                case SK_SMALL_GUNS:
                case SK_BIG_GUNS:
                case SK_ENERGY_WEAPONS:
                    criticalChanceDef += critter.BookBonus[ BB_RANGED_CRIT ];
                    break;                                                                                              // бонус от книг. ++Cracker
                case SK_UNARMED:
                case SK_THROWING:
                    criticalChanceDef += critter.BookBonus[ BB_MELEE_AND_THROWING_CRIT ];
                    break;                                                                                                     // бонус от книг. ++Cracker
                default:
                    break;
                }
            }
        }

        currentHexX = critter.HexX;
        currentHexY = critter.HexY;

        maxBlockCount.resize( 3 );
        minDamage.resize( 3 );
        maxDamage.resize( 3 );

        maxBlockCount[ 0 ] = 4;
        maxBlockCount[ 1 ] = 8;
        maxBlockCount[ 2 ] = 4;

        minDamage[ 0 ] = proccess.DmgMin * 0.5;
        minDamage[ 1 ] = proccess.DmgMin;
        minDamage[ 2 ] = proccess.DmgMin * 0.5;

        maxDamage[ 0 ] = proccess.DmgMax * 0.5;
        maxDamage[ 1 ] = proccess.DmgMax;
        maxDamage[ 2 ] = proccess.DmgMax * 0.5;

        targHexX = hexX;
        targHexY = hexY;

		UpgradeItem::UpgradeDescriptor@ upgradeDescriptor = cast< UpgradeItem::UpgradeDescriptor@ >( @item.ScriptDescriptor );
        if( @upgradeDescriptor !is null )
			upgradeDescriptor.CheckData( Data, UpgradeItem::Triggered::LineDamage );
    }

    bool ExecMutual( uint16 hx, uint16 hy )
    {
        dir = GetDirection( currentHexX, currentHexY, hx, hy );
        currentHexX = hx;
        currentHexY = hy;
        if( !( currentHexX == critter.HexX && currentHexY == critter.HexY ) )
            for( int i = -1; i < 2; i++ )
            {
                memHexX = currentHexX;
                memHexY = currentHexY;

                if( i != 0 )
                {
                    memDir = ( dir + i );
                    map.MoveHexByDir( memHexX, memHexY, memDir % maxDir, 1 );
                    // Log("memDir " + memDir%maxDir);
                    // map.MoveHexByDir(memHexX,memHexY,memDir%maxDir,1);
                }
                // map.MoveHexByDir(memHexX,memHexY,memDir%maxDir,1);
                if( !( memHexX == critter.HexX && memHexY == critter.HexY ) && !TargetHex( memHexY * map.GetWidth() + memHexX, AllHex ) )
                {
                    @target = map.GetCritter( memHexX, memHexY );
                    if( target !is null && !target.IsDead() )                 // криттеру.
                    {
                        isCritical = false;
                        critter_attack( critter, target );
                        if( target.IsNpc() || target.GetAccess() != ACCESS_ADMIN )
                            target.ModeBase[ MODE_HIDE ] = 0;
                        target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
                        isCritical = ( Random( 1, 100 ) <= criticalChanceDef );
                        int antiCriticalRes = criticalChanceDef > 100 ? criticalChanceDef - 100 : 0;
                        if( Random( 1, 100 ) <= ( target.Stat[ ST_CRITICAL_RESISTANCE ] - antiCriticalRes ) )
                            isCritical = false;
		
						EventSmthAttack( critter, target );
                        CombatRes[] results;

                        if( !proccess.IsLeon( target, 4 ) )
                        {

                            proccess.DmgMin = minDamage[ i + 1 ];
                            proccess.DmgMax = maxDamage[ i + 1 ];

                            ApplyDamage( proccess, target, 1, isCritical, true, results );
                            FlushResults( results );
                        }
                        else
                            proccess.startLeon( target, results );
                    }
                    map.GetItems( memHexX, memHexY, items );

                    if( !map.IsHexRaked( memHexX, memHexY ) )
                    {
                        if( maxBlockCount[ i + 1 ] == 0 )
                            break;
                        maxBlockCount[ i + 1 ] -= 1;

                        minDamage[ i + 1 ] *= 0.66;
                        maxDamage[ i + 1 ] *= 0.66;
                    }
                    else
                    {
                        if( Data.IsFire )
                            SetFire( map, memHexX, memHexY, 1, Random( minDamage[ i + 1 ], maxDamage[ i + 1 ] ) * Data.DamageMod, critter );
						if( Data.Effect != 0 )
							map.RunEffect( Data.Effect, memHexX, memHexY, 0, EFFECT_INSTRUCTION_NONE );
                        // map.SetText (currentHexX,currentHexY, 0, ""+proccess.DmgMin+"-"+proccess.DmgMax );
                    }
                }
            }

        return ( targHexX == currentHexX && targHexY == currentHexY );
    }

    void EndTrace( Item& item )
    {
        Item@ it = null;
        for( uint i = 0, iMax = items.length(); i < iMax; i++ )
        {
            @ it = items[ i ];
            if( it !is null )
                ItemDamage( it, ( Random( ( _WeaponDmgMin( item.Proto, item.Mode ) ), ( _WeaponDmgMax( item.Proto, item.Mode ) ) ) ) );
        }
    }
}

class CTraceBurst : ITraceContext
{
    uint16 currentHexX = 0;
    uint16 currentHexY = 0;
    uint16 targHexX = 0;
    uint16 targHexY = 0;
    uint16 memHexX = 0;
    uint16 memHexY = 0;

    uint  minDamage;
    uint  maxDamage;

    Critter@[] lookCrs;
    uint                 countLookCrs = 0;
    Critter@             target;
    Item@[] items;
    Critter@             critter;
    int                  defDmgMin = 0;
    int                  defDmgMax = 0;

    CombatProccess@ proccess;

    int                  criticalChanceDef = 0;
    bool                 isCritical = false;

    uint16[] AllHexX;
    uint16[] AllHexY;

    CTraceBurst( CombatProccess & attackArg, Map & map, Critter & crArg, Item & item, uint16 & in hexX, uint16 & in hexY )
    {
        @ critter = crArg;
        @ proccess = attackArg;
        critter.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( critter );

        defDmgMin = proccess.DmgMin;
        defDmgMax = proccess.DmgMax;

        {
            int aAim = proccess.Aim;
            if( aAim == HIT_LOCATION_UNCALLED || aAim == HIT_LOCATION_NONE || aAim == HIT_LOCATION_TORSO )
                criticalChanceDef = critter.Stat[ ST_CRITICAL_CHANCE ] + ( critter.Trait[ TRAIT_FINESSE ] != 0 ? 10 : 0 ) + critter.Perk[ PE_MORE_CRITICALS ] * 5;
            if( proccess.RealWeapon !is null )
            {
                criticalChanceDef += proccess.RealWeapon.WeaponBonus_CritChance + proccess.RealWeapon.Proto.Weapon_CriticalBonus;
                uint use = 0;
                int  skillNum = _WeaponSkill( proccess.RealWeapon.Proto, use );
                switch( skillNum )
                {
                case SK_SMALL_GUNS:
                case SK_BIG_GUNS:
                case SK_ENERGY_WEAPONS:
                    criticalChanceDef += critter.BookBonus[ BB_RANGED_CRIT ];
                    break;                                                                                              // бонус от книг. ++Cracker
                case SK_UNARMED:
                case SK_THROWING:
                    criticalChanceDef += critter.BookBonus[ BB_MELEE_AND_THROWING_CRIT ];
                    break;                                                                                                     // бонус от книг. ++Cracker
                default:
                    break;
                }
            }
        }

        currentHexX = critter.HexX;
        currentHexY = critter.HexY;

        minDamage= proccess.DmgMin;
        maxDamage = proccess.DmgMax;

        targHexX = hexX;
        targHexY = hexY;

		//UpgradeItem::UpgradeDescriptor@ upgradeDescriptor = cast< UpgradeItem::UpgradeDescriptor@ >( @item.ScriptDescriptor );
        //if( @upgradeDescriptor !is null )
		//	upgradeDescriptor.CheckData( null, UpgradeItem::Triggered::LineDamage );
    }

    bool ExecMutual( uint16 hx, uint16 hy )
    {
        if( !( currentHexX == critter.HexX && currentHexY == critter.HexY ) )
            {
                memHexX = currentHexX;
                memHexY = currentHexY;

                if( !( memHexX == critter.HexX && memHexY == critter.HexY ) )
                {
                    @target = map.GetCritter( memHexX, memHexY );
                    if( target !is null && !target.IsDead() )                 // криттеру.
                    {
                        isCritical = false;
                        critter_attack( critter, target );
                        if( target.IsNpc() || target.GetAccess() != ACCESS_ADMIN )
                            target.ModeBase[ MODE_HIDE ] = 0;
                        target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
                        isCritical = ( Random( 1, 100 ) <= criticalChanceDef );
                        int antiCriticalRes = criticalChanceDef > 100 ? criticalChanceDef - 100 : 0;
                        if( Random( 1, 100 ) <= ( target.Stat[ ST_CRITICAL_RESISTANCE ] - antiCriticalRes ) )
                            isCritical = false;
						EventSmthAttack( critter, target );
                        CombatRes[] results;

                        if( !proccess.IsLeon( target, 4 ) )
                        {
                            proccess.DmgMin = minDamage;
                            proccess.DmgMax = maxDamage;

                            ApplyDamage( proccess, target, 1, isCritical, true, results );
                            FlushResults( results );
                        }
                        else
                            proccess.startLeon( target, results );
						return false;
                    }
                    if( map.GetItems( memHexX, memHexY, items ) > 0 )
					{
						return false;
					}

                    if( !map.IsHexRaked( memHexX, memHexY ) )
                        return false;
                }
            }

        currentHexX = hx;
        currentHexY = hy;
        return ( targHexX == currentHexX && targHexY == currentHexY );
    }

    void EndTrace( Item& item )
    {
        Item@ it = null;
        for( uint i = 0, iMax = items.length(); i < iMax; i++ )
        {
            @ it = items[ i ];
            if( it !is null )
                ItemDamage( it, ( Random( ( _WeaponDmgMin( item.Proto, item.Mode ) ), ( _WeaponDmgMax( item.Proto, item.Mode ) ) ) ) );
        }
    }
}

#endif // !__CLIENT
class DebugTraccer : MutualObject
{
	uint AttackerId;
	uint TargetId;
	uint HitRounds;
	uint CountRounds;
	uint LeonRounds;
	
	void Update( uint critterId )
	{
	#ifdef __CLIENT
		if( AttackHex::Option::Combat::BurstDebug )
		{
			CritterCl@ chosen = GetChosen();
			if( chosen.Id == AttackerId )
			{
				Message( "Попало " + ( HitRounds + LeonRounds ) + " из " + CountRounds + " пуль." + 
				( ( LeonRounds != 0 ) ? ( " Увернулся от " + LeonRounds ) : "" ) );
			}
			else
			{
				Message( "В вас попало " + ( HitRounds + LeonRounds ) + " из " + CountRounds + " пуль." + 
				( ( LeonRounds != 0 ) ? ( " Увернулся от " + LeonRounds ) : "" ) );
			}
		}
	#endif
	}
	
}

#ifdef __CLIENT
# define MapIsHexPassed       IsHexPassed
# define MapMoveHexByDir      MoveHexByDir
# define MapGetCrittersHex    GetCrittersHex
int ToHitMutual( CritterMutual& critter, const ProtoItem@ weapon, const ProtoItem@ ammo, uint8 weaponMode, uint16 hexX, uint16 hexY, bool ispenalty = true )
#endif
#ifndef __CLIENT
# define MapIsHexPassed       map.IsHexPassed
# define MapMoveHexByDir      map.MoveHexByDir
# define MapGetCrittersHex    map.GetCrittersHex
int ToHitMutual( Map& map, CritterMutual& critter, const ProtoItem@ weapon, const ProtoItem@ ammo, uint8 weaponMode, uint16 hexX, uint16 hexY, bool ispenalty = true )
#endif
{
    int              use = _WeaponModeUse( weaponMode );

    uint             skillNum = _WeaponSkill( weapon, use );
    int              wpnMaxDist = _WeaponMaxDist( weapon, use );
    if( skillNum == SK_THROWING )
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), critter.Stat[ ST_STRENGTH ] + 2 * critter.Perk[ PE_HEAVE_HO ] ) );

    int dist = GetDistantion( critter.HexX, critter.HexY, hexX, hexY );
    if( dist > wpnMaxDist )
        return 0;

    int toHit = critter.Skill[ skillNum ],
        weaponPerkFirst = weapon.Weapon_Perk,
        weaponPerkSecond = weapon.Weapon_SecondPerk,
        ammoPerk = ammo !is null ? ammo.Ammo_Perk : 0;
		
    if( skillNum != SK_UNARMED )
    {
        // Ranged proccess modifiers
        int distmod1 = 2; // Used for initial weapon bonus
        int distmod2 = 0; // Minimal distance
        if( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_LONG_RANGE ) )
            distmod1 = 4;
        else if( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_SCOPE_RANGE ) )
        {
            distmod1 = 5;
            distmod2 = 5;
        }

        int perception = critter.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
            acc += distmod2;
        else
        {
            if( critter.IsPlayer() )
                acc -= ( perception - 2 ) * distmod1;
            else
                acc -= perception * distmod1;
        }

        if( -2 * perception > acc )
            acc = -2 * perception;

        acc -= 4 * critter.Perk[ PE_SHARPSHOOTER ];

        if( acc >= 0 )
        {
            if( critter.Damage[ DAMAGE_EYE ] != 0 )
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc - ( 10 * ( MapGetCrittersPath( critter.HexX, critter.HexY, hexX, hexY, 0.0f, dist, FIND_LIFE, null ) ) );

        if( dist > 1 && !weapon.Weapon_ZoneAttackIgnoreNotRaked )
        {
            uint16 hx = hexX, hy =  hexY;
            MapMoveHexByDir( hx, hy, GetDirection( hexX, hexY, critter.HexX, critter.HexY ), 1 );
            if( not MapIsHexPassed( hx, hy ) && MapGetCrittersHex( hx, hy, 1, FIND_LIFE, null ) == 0 )
                toHit -= 120;
            else if( dist > 2 )
            {
                hx = hexX;
                hy =  hexY;
                MapMoveHexByDir( hx, hy, GetDirection( hexX, hexY, critter.HexX, critter.HexY ), 2 );
                if( not MapIsHexPassed( hx, hy ) && MapGetCrittersHex( hx, hy, 1, FIND_LIFE, null ) == 0 )
                    toHit -= 85;
                else if( dist > 3 )
                {
                    hx = hexX;
                    hy =  hexY;
                    MapMoveHexByDir( hx, hy, GetDirection( hexX, hexY, critter.HexX, critter.HexY ), 3 );
                    if( not MapIsHexPassed( hx, hy ) && MapGetCrittersHex( hx, hy, 1, FIND_LIFE, null ) == 0 )
                        toHit -= 50;
                }

            }

        }

    } // End range modifiers

    if( critter.Trait[ TRAIT_ONE_HANDER ] != 0 )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = critter.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    if( critter.Perk[ PE_WEAPON_HANDLING ] != 0 )
        handlingStrength += 3;
    if( critter.Trait[ TRAIT_ONE_HANDER ] != 0 && FLAG( weapon.Flags, ITEM_TWO_HANDS ) == false )
        handlingStrength += 1;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;

    if( critter.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    if( critter.Perk[ PE_VAMPIRE_ACCURACY ] != 0 && IS_NIGHT( __Hour ) )
        toHit += 13;
    toHit += critter.MyBonus[ WEAPON_BONUS_TOHIT ];
    // Штраф за расстояние для очередей
    int penalty = 0;
	if( ispenalty )
	{
		if( _WeaponRound( weapon, use ) > 1 && _WeaponNoBrust( weapon, use ) == 0 )
			penalty += int( log( float(dist) ) / log( 2.0f ) ) * 15;

		if( _WeaponAttackType( weapon, use ) != WTA_LINE_FLAME && skillNum != SK_UNARMED )
		#ifdef __CLIENT
			penalty += GetSmokePenalty( null, hexX, hexY );
		#endif
		#ifndef __CLIENT
			penalty += GetSmokePenalty( map, critter, null, hexX, hexY );
		#endif
	}
    toHit = CLAMP( toHit, 5, 95 - penalty );

    return toHit;
}

// / Client
#ifdef __CLIENT

# include "sprite.fos"
# include "_client_defines.fos"
# include "client_gui_h.fos"
# include "_colors.fos"

import bool StartStalking( CritterCl@ critter, uint16 hexY, uint16 hexX ) from "client_main";
import void __SetAttacked( int Id, int param1, int param2, string@ param3, int[] @ param4 ) from "client_main";
import uint GetSmokePenalty( CritterCl@ target, uint16 HexX, uint16 HexY ) from "Mk2";
import int  GUI_GetActiveScreen() from "client_gui";
import void DrawBorder( CritterCl& critter, uint distance, uint color ) from "client_main";

int[][]@ ZoneAttack = null;

void DropZoneAttack()
{
	@ZoneAttack = array<array<int>>();
}

// Опции 
// AttackHex::Option::Combat::ColorMainSlot
// AttackHex::Option::Combat::ColorSecondSlot
// AttackHex::Option::Combat::ColorBonusSlot
// AttackHex::Option::Combat::OnlySprite
namespace AttackHex
{ 
	namespace Option
	{
		namespace Combat
		{
			uint	ColorMainWeapon = COLOR_SAND;
			uint	ColorSecondWeapon = COLOR_SAND;
			uint	ColorBonusWeapon = COLOR_BLUE;
			uint	ColorHexBlocked = COLOR_RED;
			
			uint	ColorBurstZone = COLOR_CHANGE_ALPHA( COLOR_SAND, 60 );
			uint	ColorBurstEffectZone = COLOR_CHANGE_ALPHA( COLOR_RED, 60 );
			::Sprite HexSprite;
			::Sprite SpriteBurstTarget;
			
			bool OnlySprite = false;
			bool BurstDebug = true;
		}
	}
}

bool IsHexsDraw = false;

void InitHexCombat()
{
	AttackHex::Option::Combat::HexSprite.Load( "geometry/fallout_hex1.png", PT_ART );
	AttackHex::Option::Combat::SpriteBurstTarget.Load( "geometry/fallout_hex1.png", PT_ART );
}

void render_hit_hex( uint layer )
{
	if( layer > 2 )
		return;
    CritterCl@ chosen = GetChosen();
    if( chosen is null ) return;
	
    ItemCl@ realWeapon = __GrenadeMode ? _CritGetItemBonus( chosen ) : _CritGetItemHand( chosen );
    if( realWeapon is null ) return;
	
    uint8 mode = 0;
    const ProtoItem@ weapon = chosen.GetSlotProto( __GrenadeMode ? SLOT_BONUS : SLOT_HAND1, mode );
    if( weapon is null ) return;
	uint8 use = _WeaponModeUse( mode );
    const ProtoItem@ ammo = ( realWeapon !is null ) ? GetProtoItem( realWeapon.AmmoPid ) : null;

    if( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_HEX_ATTACKING ) || _WeaponRound( weapon, use ) <= realWeapon.AmmoCount )
    {
		//DrawText( "Тест", __MouseX - 6, __MouseY - 6, 100, 100, COLOR_RED,  FONT_FALLOUT, FT_ALIGN | FT_UPPER | FT_BORDERED );
        uint16  hx = 0,
                   hy = 0;
        CritterCl@ monitorCr = GetMonitorCritter( __MouseX, __MouseY );
		bool isCritter = false;
        if( monitorCr !is null && !CtrlPressed )
        {
            hx = monitorCr.HexX;
            hy = monitorCr.HexY;
			isCritter = true;
        }
        else
            GetMonitorHex( __MouseX, __MouseY, hx, hy );
			
        if( hx != 0 && hy != 0 )
        {
            uint16 len = GetDistantion( chosen.HexX, chosen.HexY, hx, hy );
            int    WMaxDist = _WeaponMaxDist( weapon, use );
            uint   dist = ( _WeaponSkill( weapon, use ) == SK_THROWING ) ? ( MIN( WMaxDist, 3 * MIN( int(10), ( chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) ) ) ) : WMaxDist; // Дистанция стрельбы оружия.
			
            if( ( chosen.Stat[ ST_VISIBLE_DIST ] < len || dist < len ) || len == 0 || dist == 0 )
				return;
			
			if(_WeaponeIsPerk( weapon, ammo, WEAPON_PERK_HEX_ATTACKING ) )
            {
				if( layer != 1 )
					return;
					
                if( !weapon.Weapon_ZoneAttackIgnoreNotRaked )
                {
					uint16 XP = hx;
					uint16 YP = hy;
                    if( !IsHexRaked( XP, YP ) && !isCritter )
                        return;

                    GetHexCoord( chosen.HexX, chosen.HexY, XP, YP, 0, len );
                    GetDistantion( chosen.HexX, chosen.HexY, XP, YP );
                    if(( XP != hx || YP != hy ) && !isCritter )
                        return;
                }

                DrawToHit( weapon, mode, @monitorCr, hx, hy );

				if( ZoneAttack !is null )
				{
					if( IsHexsDraw )
					{
						int x2 = 0;
						int y2 = 0;

						int w = AttackHex::Option::Combat::HexSprite.Width / __SpritesZoom;
						int h = AttackHex::Option::Combat::HexSprite.Height / __SpritesZoom;
						
						for( uint i = 0, iEnd = ZoneAttack.length(); i < iEnd; i++ )
						{
							if( ZoneAttack[ i ].length() == 3 && GetHexPos( ZoneAttack[ i ][ 0 ], ZoneAttack[ i ][ 1 ], x2, y2 ) )
								DrawSprite( AttackHex::Option::Combat::HexSprite.Id, 0, x2 - ( w * 0.5 ), y2 - ( h * 0.5 ), w, h, true, true, ZoneAttack[ i ][ 2 ] );
						}
					}
					else
					{
						for( uint i = 0, iEnd = ZoneAttack.length(); i < iEnd; i++ )
						{
							if( ZoneAttack[ i ].length() > 0 )
								DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, ZoneAttack[ i ] );
						}
					}
				}
            }
			else if( _WeaponRound( weapon, use ) > 1 && _WeaponNoBrust( weapon, use ) != 1 )// burst
			{
				if( layer != 1 )
					return;
				
				uint16 preBlockHx = 0, preBlockHy = 0, blockHx = 0, blockHy = 0, 
					chosX = chosen.HexX, chosY = chosen.HexY;
				
				int x = 0, y = 0, tx = 0, ty = 0, cx = 0, cy = 0;
				
                int[] zoneAttack(0);
				
				uint weaponMaxDist = _WeaponMaxDist( weapon, use );
				GetHexPos( chosX, chosY, cx, cy );
                zoneAttack.insertLast( cx );
                zoneAttack.insertLast( cy );
                zoneAttack.insertLast( AttackHex::Option::Combat::ColorBurstZone );
				
				CritterCl@[] crs;
				uint crscount = 0;
				int angle_effect = _WeaponAngleEffective( weapon, use );
				int angle_second = _WeaponAngleSecond( weapon, use );
				if( angle_effect > angle_second )
					angle_second = angle_effect;
				for( int angle = 0 - angle_second, angleend = angle_second + 1; angle < angleend; angle++ )
				{
					crscount += GetCrittersPath( chosX, chosY, hx, hy, float( angle ), weaponMaxDist, FIND_LIFE_AND_KO, crs, preBlockHx, preBlockHy, blockHx, blockHy );
					
					GetHexPos( preBlockHx, preBlockHy, x, y );
					
					zoneAttack.insertLast( x );
					zoneAttack.insertLast( y );
					if( angle >= 0 - angle_effect && angle <= angle_effect )
						zoneAttack.insertLast( AttackHex::Option::Combat::ColorBurstEffectZone );
					else zoneAttack.insertLast( AttackHex::Option::Combat::ColorBurstZone );
				}
				
                zoneAttack.insertLast( cx );
                zoneAttack.insertLast( cy );
                zoneAttack.insertLast( AttackHex::Option::Combat::ColorBurstZone );
                DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, zoneAttack );
				
				int w = AttackHex::Option::Combat::SpriteBurstTarget.Width / __SpritesZoom;
				int h = AttackHex::Option::Combat::SpriteBurstTarget.Height / __SpritesZoom;
				for( uint i = 0; i < crscount; i++ )
				{
					if( GetHexPos( crs[i].HexX, crs[i].HexY, x, y ) )
						DrawSprite( AttackHex::Option::Combat::SpriteBurstTarget.Id, 0, x - ( w * 0.5 ), y - ( h * 0.5 ), w, h, true, true, COLOR_BLUE );
				}
			}
			
        }
    }
}

void DrawToHit( const ProtoItem& weapon, uint8 mode, CritterCl@ monitorCr, uint16 hx, uint16 hy )
{
	int text = to_hit_hex( weapon, mode, @monitorCr, hx, hy );
    DrawText( text + "%", __MouseX + 6, __MouseY + 6, 100, 100, COLOR_RED,  FONT_FALLOUT, FT_ALIGN | FT_UPPER | FT_BORDERED );
}

int to_hit_hex( const ProtoItem& weapon, uint8 weaponMode, CritterCl@ target, uint16 hexX, uint16 hexY )
{
    CritterCl@ chosen = GetChosen();
    if( chosen is null ) return 0;
    ItemCl@ realWeapon = __GrenadeMode ? _CritGetItemBonus( chosen ) : _CritGetItemHand( chosen );
    if( realWeapon is null )
        return 0;
    const ProtoItem@ ammo = realWeapon !is null ? GetProtoItem( realWeapon.AmmoPid ) : null;

    if( realWeapon !is null && _WeaponRound( weapon, _WeaponModeUse( weaponMode ) ) > 0 )
    {
        if( realWeapon.AmmoCount == 0 )
            return 0;
        @ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    if( target !is null )
    {
        hexX = target.HexX;
        hexY = target.HexY;
    }
	
    return ToHitMutual( chosen, weapon, ammo, weaponMode, hexX, hexY, _WeaponRound( weapon, _WeaponModeUse( weaponMode ) ) > 1 );
}

bool hex_attack( CritterCl@ target, uint16 hexX, uint16 hexY )
{
    CritterCl@ chosen = GetChosen();
    if( chosen is null )
        return false;
		
    uint8 mode = 0;
    const ProtoItem@ weapon = chosen.GetSlotProto( __GrenadeMode ? SLOT_BONUS : SLOT_HAND1, mode );
    if( weapon !is null )
    {
		uint8 use = _WeaponModeUse( mode );
        ItemCl@ realWeapon = __GrenadeMode ? _CritGetItemBonus( chosen ) : _CritGetItemHand( chosen );
        const ProtoItem@ ammo = realWeapon !is null ? GetProtoItem( realWeapon.AmmoPid ) : null;
        if( realWeapon !is null && _WeaponRound( weapon, use ) > 0 && realWeapon.AmmoCount == 0 )
            return false;

        if( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_HEX_ATTACKING ) ||  ( _WeaponRound( weapon, use ) > 1 && _WeaponNoBrust( weapon, use ) == 0 ) )
        {
            uint16 hx = 0, hy = 0;
            if( CtrlPressed )
                @target = null;
            if( target !is null && target.Id != chosen.Id )
            {
				if( _WeaponRound( weapon, use ) > 1 && !_WeaponeIsPerk( weapon, ammo, WEAPON_PERK_HEX_ATTACKING ) )
					return false;
					
                hx = target.HexX;
                hy = target.HexY;
					
                __SetAttacked( target.Id, weapon.ProtoId, 0, null, null );
            }
            else if( hexX > 0 && hexY > 0 )
            {
				hx = hexX;
				hy = hexY;
			}
			else if( !GetMonitorHex( __MouseX, __MouseY, hx, hy ) )
			{
				return false;
			}
			
			if( target !is null || ( ( hx > 0 && hy > 0 ) && ( IsHexRaked( hx, hy ) || weapon.Weapon_ZoneAttackIgnoreNotRaked ) ) )
			{
				if( StartStalking( target, hx, hy ) )
					return true;

				uint[]  actions = { CHOSEN_NONE, 0, 0, 0, 0, 0, 0 };
				SetChosenActions( actions );
				RunServerScriptUnsafe( "combat@unsafe_Attack", hx, hy,  __GrenadeMode ? SLOT_BONUS : SLOT_HAND1,  null, null );
				return true;
			}
        }
    }
    return false;
}

void mouse_move_attack_hex( int x, int y, CritterCl@ target )
{
    DropZoneAttack();
    IsHexsDraw = false;
    if( GUI_GetActiveScreen() != CLIENT_MAIN_SCREEN_GAME )
        return;
    uint8      mode = 0;
    CritterCl@ chosen = GetChosen();
    if( chosen is null )
        return;

    const ProtoItem@ protoweapon = chosen.GetSlotProto( __GrenadeMode ? SLOT_BONUS : SLOT_HAND1, mode );
    if( protoweapon is null )
        return;

    ItemCl@ realWeapon = _CritGetItemHand( chosen );
    const ProtoItem@ ammo = ( realWeapon !is null ) ? GetProtoItem( realWeapon.AmmoPid ) : null;
    {
        if( realWeapon !is null && _WeaponRound( protoweapon, _WeaponModeUse( mode ) ) > 0 )
        {
            if( realWeapon.AmmoCount == 0 )
                return;
        }
    }

    if( _WeaponeIsPerk( protoweapon, ammo, WEAPON_PERK_HEX_ATTACKING ) )
    {
        if( GetCurrentCursor() == CURSOR_USE_WEAPON )
        {
            ItemCl@ weapon = chosen.GetItem( 0, __GrenadeMode ? SLOT_BONUS : SLOT_HAND1 );
            if( weapon is null )
                return;
            uint16 weapPid = weapon.GetProtoId();
            //CritterCl@ target = GetMonitorCritterExt(__MouseX, __MouseY);
            //if( @target == null || target.Id == chosen.Id || CtrlPressed )
            {
                switch( _WeaponAttackType( protoweapon, _WeaponModeUse( weapon.Mode ) ) )
                {
                case WTA_LINE_IGNORED_RAKED:
                {
                    uint16 hx = 0;
                    uint16 hy = 0;
					if( target !is null )
					{
						hx = target.HexX;
						hy = target.HexY;
					}
                    else GetMonitorHex( x, y, hx, hy );
                    IsHexsDraw = true;


                    CTraceLineIgnoredRaked Trace( chosen.HexX, chosen.HexY, hx, hy, AttackHex::Option::Combat::ColorMainWeapon );
                    LineTracerHex( chosen.HexX, chosen.HexY, hx, hy, _WeaponMaxDist( weapon.Proto, _WeaponModeUse( weapon.Mode ) ), Trace );
					@ZoneAttack = @Trace.ZoneData;

                } break;

                case WTA_LINE_FLAME:
                {
                    uint16 tx = 0;
                    uint16 ty = 0;
					if( target !is null )
					{
						tx = target.HexX;
						ty = target.HexY;
					}
                    else GetMonitorHex( x, y, tx, ty );
                    IsHexsDraw = true;

                    uint16 dx = tx,
                           dy = ty,
                           hx = chosen.HexX,
                           hy = chosen.HexY,
                           wx = 0,
                           wy = 0;

                    uint dist = _WeaponMaxDist( weapon.Proto, _WeaponModeUse( weapon.Mode ) );

                    uint radius = 1;
                    uint dir = 0;
                    GetHexCoord( hx, hy, dx, dy, 0, dist );

                    bool[] isFlameDirect = { true, true, true };

                    for( uint n = 0; n < dist; n++ )
                    {
                        dir = GetDirection( hx, hy, dx, dy );
                        MoveHexByDir( hx, hy, dir, 1 );
                        wx = hx;
                        wy = hy;

                        if( !IsHexRaked( wx, wy ) )
                            break;

                        uint d = 0;

                        for( uint r = 0; r < radius; r++ )
                        {
                            if( chosen.HexX == wx && chosen.HexY == wy )
                                continue;

                            if( IsHexRaked( wx, wy ) )
                            {
                                if( isFlameDirect[ d ] )
                                {
                                    int[] zoneAttack = { wx, wy, AttackHex::Option::Combat::ColorMainWeapon };
                                    ZoneAttack.insertLast( zoneAttack );
                                }
                            }
                            else
                                isFlameDirect[ d ] = false;

                            wx = hx;
                            wy = hy;
                            d = ( r % 2 == 0 ) ? d = 1 : d = 2;
                            MoveHexByDir( wx, wy, ( r % 2 == 0 ) ? ( dir + 1 ) % 6 : ( dir - 1 ) % 6, r / 2 + 1 );
                        }

                        if( radius - 1 < weapon.Proto.HexWeapon_Radius )
                            radius++;
                    }
                } break;

                case WTA_RADIUS_HEX:
                default:
                {
                    uint16 hx = 0;
                    uint16 hy = 0;
                    int    radius = protoweapon.HexWeapon_Radius;
                    if( radius == 0 )
                        radius = ( weapPid == PID_GRANADE_REVOLV_I || weapPid == PID_GRANADE_REVOLV_II || weapPid == PID_GRANADE_PISTOL || weapPid == PID_REVOLV_GRENADE ) ? 1 : 2;
                    int x1 = 0;
                    int y1 = 0;
					
                    uint8 hexCount = weapPid == PID_JACKAL ? 3 : 1;
					IsHexsDraw = AttackHex::Option::Combat::OnlySprite;
                    for( uint c = 0; c < hexCount; c++ )
                    {
                        int[] zoneAttack = {};
						if( target !is null )
						{
							hx = target.HexX;
							hy = target.HexY;
						}
						else GetMonitorHex( x, y, hx, hy );
                        //GetMonitorHex( x, y, hx, hy );
                        uint8 dir = GetDirection( chosen.HexX, chosen.HexY, hx, hy );
                        if( c == 1 )
                            MoveHexByDir( hx, hy, ( dir + 2 ) % 6, 2 );
                        else if( c == 2 )
                            MoveHexByDir( hx, hy, ( dir + 4 ) % 6, 2 );
                        GetHexPos( hx, hy, x1, y1 );

                        int    x1 = 0;
                        int    y1 = 0;

                        int    yMax = hy + radius;
                        int    yMin = hy - radius;

                        int    xMax = hx + radius;
                        int    xMin = hx - radius;

                        uint16 lastHx = hx - radius;
                        uint16 lastHy = yMin;

                        int    MapWidth = GetMapWidth();
                        int    MapHeight = GetMapHeight();

                        if( MapWidth <  xMax )
                            xMax = MapWidth;
                        if( xMin < 0 )
                            xMin = 0;
                        if( MapHeight <  yMax )
                            yMax = MapHeight;
                        if( yMin < 0 )
                            yMin = 0;

                        if( !chosen.IsDead() && IsHexRaked( hx, hy ) )
                        {
                            for( int hexX = xMin, xEnd = xMax; hexX <= xEnd; hexX++ )
                            {
                                uint16 ihx = hexX;
                                uint16 ihy = yMin;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }

                            for( int hexY = yMin, yEnd = yMax; hexY <= yEnd; hexY++ )
                            {

                                uint16 ihx = xMax;
                                uint16 ihy = hexY;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }

                            for( int hexX = xMax, xEnd = xMin; hexX >= xEnd; hexX-- )
                            {

                                uint16 ihx = hexX;
                                uint16 ihy = yMax;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }

                            for( int hexY = yMax, yEnd = yMin; hexY >= yEnd; hexY-- )
                            {

                                uint16 ihx = xMin;
                                uint16 ihy = hexY;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }
                        }
						
						if( !AttackHex::Option::Combat::OnlySprite )
							ZoneAttack.insertLast( zoneAttack );
                    }
                }
                break;
                }
            }
        }
    }
}

class CTraceLineIgnoredRaked : ITraceContext
{
    uint8  maxDir = 6;
    uint8  dir = 0;
    uint8  memDir = 0;

    uint16 startHexX = 0;
    uint16 startHexY = 0;
    uint16 currentHexX = 0;
    uint16 currentHexY = 0;
    uint16 targHexX = 0;
    uint16 targHexY = 0;
    uint16 memHexX = 0;
    uint16 memHexY = 0;

    int    Color = 0;

	int[][]@ ZoneData;

    CTraceLineIgnoredRaked( uint16 StartHexX, uint16 StartHexY, uint16 hx, uint16 hy, int color )
    {
        maxDir = __MapHexagonal ? 6 : 8;
        currentHexX = StartHexX;
        currentHexY = StartHexY;
        targHexX = hx;
        targHexY = hy;
        startHexY = StartHexY;
        startHexX = StartHexX;
        IsHexsDraw = true;
        Color = color;
		@ZoneData = array<array<int>>();
    }

    bool ExecMutual( uint16 hx, uint16 hy )
    {
        dir = GetDirection( currentHexX, currentHexY, targHexX, targHexY );

        currentHexX = hx;
        currentHexY = hy;
		
        if( !( currentHexX == startHexX && currentHexY == startHexY ) )
            for( int i = -1; i < 2; i++ )
            {
                memHexX = currentHexX;
                memHexY = currentHexY;

                if( i != 0 )
                {
                    memDir = ( dir + i );
                    MoveHexByDir( memHexX, memHexY, memDir % maxDir, 1 );
                }

                if( !( memHexX == startHexX && memHexY == startHexY ) )
                {
                    int[] zoneAttack = { memHexX, memHexY, ( IsHexRaked( memHexX, memHexY ) ? AttackHex::Option::Combat::ColorMainWeapon : AttackHex::Option::Combat::ColorHexBlocked ) };
                    ZoneData.insertLast( zoneAttack );
                }
            }

        return ( targHexX == currentHexX && targHexY == currentHexY );
    }
}

#endif // __CLIENT

bool TargetHex( uint index, uint[]& indx )
{
	if( indx.find( index ) == -1 )
	{
		indx.insertLast(index);
		return false;
	}
    return true;
}
