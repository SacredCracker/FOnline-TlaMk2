// Author: Atom, cvet, Team mk2
// 21-08-2010 05:09
// vanilla

#include "_macros.fos"
#include "_animation.fos"
#include "_msgstr.fos"
#include "_colors.fos"
#include "_npc_pids.fos"
#include "linetracer_h.fos"

#define ATACK_WAIT_TIME         ( 6 )
#define TIMEOUT_RESTORE_DOOR    ( REAL_MINUTE( 12 ) )
#define HP_DOOR                 ( 250 )
#define HP_SANDBAD              ( 100 )
#define isWeaponPerk            #(i)       ( weaponPerkFirst == i || weaponPerkSecond == i || ammoPerk == i )

#ifdef __CLIENT
#define CritterMutual          CritterCl
#define ItemMutual             ItemCl
#define MapGetCrittersPath     GetCrittersPath
#endif

const float DeadZone_PenaltySecondTargets = 0.6;
const float DeadZone_PenaltyEffectTargets = 1.0;
const float DeadZone_MaxHitModule = 0.6;

// Server
#ifndef __CLIENT
#define CritterMutual          Critter
#define ItemMutual             Item
#define MapGetCrittersPath     Map.GetCrittersPath
#include "_upgrade_item_defines.fos"

#include "critical_table.fos"
#include "combat_msg.fos"
#include "npc_ai.fos"
#include "combat_h.fos"

// Штраф на процент потенциальных критических пуль
import void critter_attack( Critter& critter, Critter& target ) from "main";
import void DeteriorateItem( Critter& critter, Item& item, int deteriorateCount ) from "Mk2";
import void AffectPoison( Critter& critter, int value ) from "Mk2";
import void AffectRadiation( Critter& critter, int value ) from "Mk2";
import void QuakeScreen( Map& map ) from "effects";
import void FlushScreen( Map& map, uint fromColor, uint toColor, uint timeMs ) from "effects";
import uint GetSmokePenalty( Map& map, Critter& attacker, Critter@ target, uint16 hexX, uint16 hexY ) from "Mk2";
import void SmokeBlast( Map& map, uint16 hexX, uint16 hexY, uint16 smokePid, uint ownerId ) from "Mk2";
import bool reload_weapon( Critter@ critter, Item@ weapon ) from "merc";
import void put_down_weapon( Critter@ critter )  from "merc";
import void lightning_attack( Critter& critter, Critter& target, ProtoItem& weapon, uint8 weaponMode ) from "lightning_weapon";
import void Explode( Map@ map, uint16 hexX, uint16 hexY, Critter@ critter, uint16 explodePid, uint ownerId, int bonusDamage, int bonusRadius ) from "explode";
import void ChangePlayerScore( Critter& player, uint scoreIndex, int value ) from "Mk2";
import void SetDeleteItem( Item& item, uint delHours ) from "Mk2";
import void SetFire( Map& map, uint16 hx, uint16 hy, uint16 radius, uint16 damage, Critter@ critter ) from "Mk2";

// CTE_END_BATTLE
uint cte_EndBattle( Critter& critter, int identifier, int& rate, int& )
{
    critter.RefreshSpeed();
    return 0;
}

enum ETypeAttack
{
    TypeAttack_None,
    TypeAttack_Melee,
    TypeAttack_Normal,
    TypeAttack_Flame,
    TypeAttack_Burst,
    TypeAttack_RocketsThrowing,
    TypeAttack_End
}

CombatProccess@ GetCombatProccess( )
{
	return null;
}

void EventSmthAttack( Critter@ attacker, Critter@ target )
{
	if( attacker.Id != target.Id )
	{						
		Critter@ lookCritter = null;
		Critter@[] lookCritters;
		for( uint i = 0, iMax = attacker.GetCritters( true, FIND_ALL, @lookCritters ); i < iMax; i++ )
		{
			@lookCritter = lookCritters[ i ];
			lookCritter.EventSmthAttack( attacker, target );
			lookCritter.EventSmthAttacked( target, attacker );
		}
	}
}

CombatAlgoritm@ GetCombatAlgoritm( CombatProccess@ proccess )
{
	CombatAlgoritm@ result = null;
	
	if( proccess.ScoreUnarmed)
	{
		@result = CombatAlgoritm_Unarmed();
	}
	else switch( proccess.WeaponSubtype )
	{
		case WS_GUN:
			if( proccess.IsBurst )
				@result = CombatAlgoritm_Burst();
			else	@result = CombatAlgoritm_GunNormal();
			break;
		
		case WS_THROWING:
			@result = CombatAlgoritm_Throwing();
			break;
			
		default: break;
	}
	
	@result.proccess = proccess;
	return result;
}

class CombatAlgoritm
{
	void Proccess( )
	{
	
	}
	
	CombatProccess@ proccess;
}

class CombatAlgoritm_GunNormal : CombatAlgoritm
{
	bool CheckLightning()
	{
		if( proccess.IsWeaponPerk( WEAPON_PERK_LIGHTNING_WEAPON ) )
		{
			lightning_attack( proccess.Attacker, proccess.RealTarget, proccess.Weapon, proccess.WeaponMode );
			return true;
		}
		return false;
	}

	void Proccess()
	{
        if( proccess.IsHit || proccess.IsChangeTarget() )
        {
            if( CheckLightning() || !proccess.IsLeon( proccess.RealTarget, proccess.Distantion ) )
            {
                if( proccess.TypeDamage == DAMAGE_EXPLODE )
                    proccess.Map.RunEffect( PID_EXPLODE_ROCKET, proccess.RealTarget.HexX, proccess.RealTarget.HexY, 0, 0 );
                ApplyDamage( proccess, proccess.RealTarget, proccess.WeaponAmmoRound, proccess.IsCritical && proccess.IsHit, !proccess.IsChangeTarget(), proccess.Results );
            }
            else
                proccess.startLeon( proccess.RealTarget, proccess.Results );
        }
        else // standard miss here
        {
            Critter@[] critsLine;
			Critter@ crForI = null;
			Critter@ target = null; 
			for( int i = 0, iMax = proccess.Map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0.0f, proccess.GetWeaponMaxDistance(), FIND_LIFE_AND_KO, critsLine ); i < iMax; i++ )
            {
				@crForI = critsLine[ i ];
				if( crForI is proccess.RealTarget )
					continue;
					
				if( proccess.IsLeon( crForI, GetDistantion( proccess.Hx, proccess.Hy, crForI.HexX, crForI.HexY ) ) )
				{
					proccess.startLeon( crForI, proccess.Results );
					continue;
				}
				
				proccess.ToHitCalculated( crForI, crForI.HexX, crForI.HexY, HIT_LOCATION_UNCALLED );
				if( Random( 1, 100 ) <= int( proccess.HitResult * 0.33 ) )
				{
					@target = crForI;
					break;
				}
			}
			if( target !is null )
			{
				@proccess.RealTarget = target;
				proccess.TargetHx = target.HexX;
				proccess.TargetHy = target.HexY;
				
				proccess.UseNormal = true;
				NotifyOops( proccess.Attacker, proccess.Target, target, proccess.Results );
				ApplyDamage( proccess, target, proccess.WeaponAmmoRound, false, false, proccess.Results );
				NotifyMiss( proccess.Attacker, proccess.Results );
			}
		}
	}
}

class CombatAlgoritm_Throwing : CombatAlgoritm
{
	void Proccess()
	{
		if( proccess.IsLeon( proccess.RealTarget, proccess.Distantion ) )
            proccess.startLeon( proccess.RealTarget, proccess.Results );
        else if( proccess.IsHit || proccess.IsChangeTarget() )
            ApplyDamage( proccess, proccess.RealTarget, proccess.WeaponAmmoRound, proccess.IsCritical && proccess.IsHit, !proccess.IsChangeTarget(), proccess.Results );
        else
        {
            uint16 bx = 0,
                   by = 0,
                   pbx = 0,
                   pby = 0;
            Critter@[] critsLine;
			Critter@ crForI = null;
			Critter@ target = null;
            for( int i = 0, iMax = proccess.Map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0.0f, proccess.GetWeaponMaxDistance(), FIND_LIFE_AND_KO, critsLine, pbx, pby, bx, by ); i < iMax; i++ )
            {
                @crForI = critsLine[ i ];

                if( crForI is proccess.RealTarget )
                    continue;
				
                if( proccess.IsLeon( crForI, GetDistantion( proccess.Hx, proccess.Hy, crForI.HexX, crForI.HexY ) ) )
                {
                    proccess.startLeon( crForI, proccess.Results );
                    continue;
                }
				
				proccess.ToHitCalculated( crForI, crForI.HexX, crForI.HexY, HIT_LOCATION_UNCALLED );
                if( Random( 1, 100 ) <= int( proccess.HitResult * 0.33 ) )
                    @target = crForI;
            }
            if( target !is null )
            {
				@proccess.RealTarget = target;
				proccess.TargetHx = target.HexX;
				proccess.TargetHy = target.HexY;
                NotifyOops( proccess.Attacker, proccess.Target, target, proccess.Results );
                proccess.UseNormal = true;
                ApplyDamage( proccess, target, proccess.WeaponAmmoRound, false, false, proccess.Results );
            }
            else
            {
                proccess.UseHex = true;
                NotifyMiss( proccess.Attacker, proccess.Results );
                proccess.TargetHx = pbx;
                proccess.TargetHy = pby;
            }
        }                                     // miss
	}
}

class CombatAlgoritm_Unarmed : CombatAlgoritm
{
	void Proccess()
	{
		if( proccess.IsLeon( proccess.RealTarget, proccess.Distantion ) )
            proccess.startLeon( proccess.RealTarget, proccess.Results );  // TabaK. Уворот от рукопашной атаки. хз, надо ли.
        else if( proccess.IsHit )
        {
            if( proccess.Attacker.Mode[ MODE_HIDE ] != 0 && proccess.IsSilentAtack( proccess.RealTarget ) )
            {
                proccess.UnSneak( proccess.Attacker );
                proccess.DmgMul *= 2;
            }
            ApplyDamage( proccess, proccess.RealTarget, 1, proccess.IsCritical && proccess.IsHit, true, proccess.Results );
        }
        else
        {
            if( proccess.IsChangeTarget() )
                ApplyDamage( proccess, proccess.RealTarget, 1, false, false, proccess.Results );
            else
                NotifyMiss( proccess.Attacker, proccess.Results );
        }
	}
}

class BurstHitData
{
	uint rounds = 0;
	uint leon = 0;
}

class CombatAlgoritm_Burst : CombatAlgoritm
{
	uint countHitTargets;
	Critter@[] critsHit;
    BurstHitData@[] critsHitBullets;;

	uint StartRounds;
		
	CombatAlgoritm_Burst( )
	{
		Clear( );
	}
		
	void Clear( )
	{
		countHitTargets = 0;
		critsHit.resize(0);
		critsHitBullets.resize(0);
	}
		
	void AddTarget( Critter& critter, BurstHitData& data )
	{
		critsHit.insertFirst( critter );
        critsHitBullets.insertFirst( data );
        countHitTargets++;
		proccess.WeaponAmmoRound -= data.rounds;
	}
	
	bool CritterIsTarget( Critter& critter )
	{
		return FindCritterInArray( critsHit, critter ) != -1;
	}

	void Proccess( )
	{
		Clear();
        bool criticalHit = proccess.IsCritical && proccess.IsHit;
			
		StartRounds = proccess.WeaponAmmoRound;
		
        if( proccess.RealTarget !is null )
		{
			if( !ParseTarget( proccess.RealTarget, true ) )
				criticalHit = false;
		}
		
		uint8 angle_effect = _WeaponAngleEffective( proccess.Weapon, proccess.WeaponUse );
		uint8 angle_second = _WeaponAngleSecond( proccess.Weapon, proccess.WeaponUse );
		
		int wpnMaxDist = proccess.GetWeaponMaxDistance();
		ParseAngle( 0 - angle_effect, angle_effect, wpnMaxDist, true );
		if( angle_second > angle_effect )
		{
			ParseAngle( Random( 0 - angle_second, -1 - angle_effect ), 0 - angle_effect, wpnMaxDist, false );
			ParseAngle( angle_effect, Random( angle_effect + 1, angle_second ), wpnMaxDist, false );
		}
        Damage( criticalHit );
		
        if( !proccess.TargetHit && proccess.TargetId != 0 )
            NotifyMiss( proccess.Attacker, proccess.Results );
			
		proccess.WeaponAmmoRound = StartRounds;
	}

	void ParseAngle( int angleBegin, int angleEnd, int distance, bool isEffect )
	{
		Critter@[] sTargets;
		
		angleEnd++;
		for( int angle = angleBegin; angle < angleEnd; angle++ )
			proccess.Map.GetCrittersPath( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, float( angle ), distance, FIND_LIFE_AND_KO, sTargets );
		
        Parse( sTargets, isEffect );
	}
	
	void Damage( bool criticalHit )
	{
		Critter@ crForI = null;
		DebugTraccer traccer;
		traccer.AttackerId = proccess.Attacker.Id;
		traccer.CountRounds = StartRounds;
        for( uint i = 0; i < countHitTargets; i++ )
        {
            @crForI = critsHit[ i ];
            if( proccess.TypeDamage == DAMAGE_EXPLODE )
                proccess.Map.RunEffect( PID_EXPLODE_ROCKET, crForI.HexX, crForI.HexY, 0, 0 );

			BurstHitData@ data = critsHitBullets[ i ];
			traccer.TargetId = crForI.Id;
			traccer.HitRounds = data.rounds;
			traccer.LeonRounds = data.leon;
			
			if( proccess.Attacker.IsPlayer() )
				proccess.Attacker.Send( traccer );
			if( crForI.IsPlayer() )
				crForI.Send( traccer );
			
			if( data.rounds != 0 )
			{
				if( proccess.Target is crForI ) proccess.TargetHit = true;
				ApplyDamage( proccess, crForI, data.rounds, ( proccess.Target is crForI ) && criticalHit, ( proccess.Attacker.IsPlayer() && !proccess.IsChangeTarget() ) || ( !proccess.Attacker.IsPlayer() && proccess.Target is crForI ), proccess.Results );
			}
        }
	}
	
	bool ParseTarget( Critter& target, bool isEffect )
	{
		if( CritterIsTarget( target) )
			return false;

		int distantion = GetDistantion( proccess.Hx, proccess.Hy, target.HexX, target.HexY );
		
        proccess.ToHitCalculated( target, target.HexX, target.HexY, HIT_LOCATION_UNCALLED );
		if( !isEffect ) 
		{
			if( proccess.HitModule != DeadZone_PenaltySecondTargets )
				proccess.Hit *= DeadZone_PenaltySecondTargets;
			else proccess.HitMaxBorder *= DeadZone_MaxHitModule;
		}
		int curRounds = 0;
		BurstHitData data;
		LeonHash leon( target, distantion );
		//proccess.Debug( "proccess.Hit " + proccess.Hit + " hitModule " + hitModule );
		for( ;curRounds < proccess.WeaponAmmoRound;)
		{
			curRounds++;
			int hit = proccess.Hit - GetBulletHitPenalty( curRounds );
			int random = Random( 1, 100 );
			int result = proccess.HitClamp( hit );
			//proccess.Debug( "hit " + hit + " " + proccess.HitPenalty );
			//proccess.Debug( "random " + random + " result " + result );
			if( random <= result )
			{
				if( !leon.Is( ) )
					data.rounds++;
				else data.leon++;
			}
			else if( !isEffect )
				break;
		}
		//proccess.Debug( "data.rounds " + data.rounds );
			
		if( data.rounds != 0 || data.leon != 0 )
		{
			AddTarget( target, data );
			return true;
		}
		return false;
	}
	
	uint GetBulletHitPenalty( int round )
	{
		return ( 35 - proccess.AttackerSkill * 0.1 ) * round;
	}
	
	void Parse( Critter@[]& sTargets, bool isEffect )
	{
		uint countTargets = sTargets.length();
		Critter@ crForI = null;
        for( uint i = Random( 0, countTargets - 1 ); countTargets > 0 && proccess.WeaponAmmoRound > 0; i = Random( 0, countTargets - 1 ) )
        {
            @crForI = sTargets[ i ];
			sTargets.removeAt(i);
			countTargets--;
			ParseTarget( crForI, isEffect);
        }
	}
}

void startCombatTimeout( Critter& target, bool sneak = true )
{
	if( target.IsNpc() || target.GetAccess() != ACCESS_ADMIN )
	{
		int targetTimeout = BATTLE_TIMEOUT( target );
		Item@ targetArmor = _CritGetItemArmor( target );

		if( validEngineObject( targetArmor ) )
			targetTimeout -= REAL_SECOND( targetArmor.Proto.BonusForOutOfCombat );

		if( __FullSecond + REAL_SECOND( 5 ) > uint( targetTimeout ) )
			targetTimeout = __FullSecond + REAL_SECOND( 5 );
		if( target.Timeout[ TO_BATTLE ] < targetTimeout - __FullSecond )
		{
			target.TimeoutBase[ TO_BATTLE ] = targetTimeout;
			uint[] indexes;
			if( target.GetTimeEvents( CTE_END_BATTLE, indexes ) > 0 )
				target.ChangeTimeEvent( indexes[ 0 ], targetTimeout - __FullSecond, 0, 0 );
			else
				target.AddTimeEvent( "cte_EndBattle", targetTimeout - __FullSecond, CTE_END_BATTLE );
		}
		target.RefreshSpeed();
		if( sneak )
			target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
	}
}

uint GetHitAimDefault( int hitLocation )
{
	return GetHitAim( hitLocation );
}

uint GetHitAimUnarmed( int hitLocation )
{
	return GetHitAim( hitLocation ) * 0.5;
}

enum CombatResult
{
	unproccess,
	success,
	ammo_ran_out,
	broken_weapon,
	critical_fail,
	end
}

class Combat : CombatProccess, MixinToHitProccess, MixinFlamerProccess
{
	bool IsHexAttack;
	bool IsQuakeScreen;
	uint ExplodeId;
	uint Radius;
	CombatResult Result;

	Combat( Critter& attacker, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo )
	{
		super();
		Prepare( attacker, target, target.HexX, target.HexY, weapon, weaponMode, ammo, SLOT_HAND1 );
	}

	Combat( Critter& attacker, uint16 targetX, uint16 targetY, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, int weaponSlot )
	{
		super();
		Prepare( attacker, null, targetX, targetY, weapon, weaponMode, ammo, weaponSlot );
	}
	
	void Clear()
	{
		CombatProccess::Clear();
		IsHexAttack = false;
		IsQuakeScreen = false;
		ExplodeId = 0;
		Radius = 0;
		Result = CombatResult::unproccess;
	}
	
	void Prepare( Critter& attacker, Critter@ target, uint16 targetX, uint16 targetY, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, int weaponSlot )
	{
		Clear();
		@Results = CombatRes[]();
		@GetHitAim = GetHitAimDefault;
		
		IsHexAttack = target is null;
		
		if( IsHexAttack )
		{
			UseHex = true;
			SetTargetHex( targetX, targetY );
		}
		else SetTarget( target );
		SetAttacker( attacker );
		SetProtoWeapon( weapon, weaponMode );
		AttackerSkill = Attacker.Skill[ WeaponSkill ];
		FillAim();
		FillCriticalChance();
		SetAmmo( ammo );
		FillWeapon( weaponSlot );
		FillMap();
		FillThrowing();
		FillGun();
		FillUnarmed();
		FillWeaponPerks();
		FillBookBonus();
		FillEffects();
	}
	
	void FillEffects()
	{
		 bool 	isRocket = ( AmmoPid == PID_CANNON_BALLS_FRAG ) || ( AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( AmmoPid == PID_ROCKET_AP ) || ( AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( AmmoPid == PID_EMP_ROCKET ) || ( AmmoPid == PID_NUKE_ROCKET ) || ( AmmoPid == PID_ROCKET_FIRE ),
				explode = ( ( isRocket ) || ( WeaponPid == PID_MOLOTOV_COCKTAIL ) || ( WeaponPid == PID_FRAG_GRENADE ) ||
                     ( WeaponPid == PID_PULSE_GRENADE ) || ( WeaponPid == PID_PLASMA_GRENADE ) || ( WeaponPid == PID_PLASMA_CANNON ) || ( WeaponPid == PID_GRANADE_REVOLV_I ) || ( WeaponPid == PID_GRANADE_REVOLV_II ) || ( WeaponPid == PID_GRANADE_PISTOL ) || ( WeaponPid == PID_REVOLV_GRENADE ) ||
                     ( WeaponPid == PID_HOLY_HAND_GRENADE ) || WeaponPid == PID_FIRE_GRENADE );
        IsQuakeScreen = ( explode && WeaponPid != PID_PLASMA_CANNON && WeaponPid != PID_MOLOTOV_COCKTAIL && WeaponPid != PID_FIRE_GRENADE && AmmoPid != PID_ROCKET_FIRE );

		Radius += Weapon.HexWeapon_Radius;

		if( explode || WeaponSkill == SK_TRAPS )
		{
			if( Radius == 0 )
			{
				Radius = ( WeaponPid == PID_GRANADE_REVOLV_I || WeaponPid == PID_GRANADE_REVOLV_II || WeaponPid == PID_GRANADE_PISTOL || WeaponPid == PID_REVOLV_GRENADE ) ? 1 : 2;
				if( AmmoPid == PID_NUKE_ROCKET )
					Radius = 35;
			}
			switch( WeaponPid )
			{
				case PID_MOLOTOV_COCKTAIL:
					ExplodeId = PID_EXPLODE_FIRE_BIG;
					break;
				case PID_FIRE_GRENADE:
					ExplodeId = PID_EXPLODE_FIRE_BIG;
					break;
				case PID_FRAG_GRENADE:
				case PID_HOLY_HAND_GRENADE:
					ExplodeId = PID_EXPLODE_FIRE_SMALL;
					break;
				case PID_PULSE_GRENADE:
					ExplodeId = PID_EXPLODE_EMP;
					break;
				case PID_PLASMA_GRENADE:
				case PID_PLASMA_CANNON:
					ExplodeId = PID_EXPLODE_PLASMA;
					break;

				default:
				{
					if( isRocket )
					{
						if( AmmoPid == PID_EMP_ROCKET )
							ExplodeId = PID_EXPLODE_EMP;
						else if( AmmoPid == PID_NUKE_ROCKET )
							ExplodeId = PID_EXPLODE_NUKLEAR;
						else
							ExplodeId = PID_EXPLODE_ROCKET;
					}
					else
						ExplodeId = PID_EXPLODE_FIRE_BIG;
				} break;
			}
		}
	}
	
	void FillBookBonus()
	{
		switch( WeaponSkill )
        {
			case SK_SMALL_GUNS:
			case SK_BIG_GUNS:
			case SK_ENERGY_WEAPONS:
				CriticalChance += Attacker.BookBonus[ BB_RANGED_CRIT ];
				break;
				
			case SK_UNARMED:
			case SK_THROWING:
				CriticalChance += Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT ];
				break;
				
			default:
				break;
        }
	}
	
	void FillWeaponPerks()
	{
		if( IsWeaponPerk( WEAPON_PERK_LONG_RANGE ) )
			DistanceMod1 = 4;
		else if( IsWeaponPerk( WEAPON_PERK_SCOPE_RANGE ) )
		{
			DistanceMod1 = 5;
			DistanceMod2 = 5;
		}
		
        if( IsWeaponPerk( WEAPON_PERK_SCOPE_RANGE ) )
            CriticalChance += 15;
			
		if( IsWeaponPerk( WEAPON_PERK_DOUBLE_SHOT ) )
			WeaponAmmoRound *= 2;
			
		if( TypeAttack == WTA_DEFAULT && IsWeaponPerk( WEAPON_PERK_HEX_ATTACKING ) )
			TypeAttack = WTA_RADIUS_HEX;
	}
	
	void FillMap()
	{
		@Map = Attacker.GetMap();
		AttackDistantion = Distantion;
	}
	
	int GetHandlingStrength( )
	{
		return Attacker.Stat[ ST_STRENGTH ] + Attacker.Perk[ PE_WEAPON_HANDLING ] * 3 + ( ( Attacker.Trait[ TRAIT_ONE_HANDER ] != 0 && !FLAG( Weapon.Flags, ITEM_TWO_HANDS ) ) ? 1 : 0 ) - Attacker.Trait[ TRAIT_SMALL_FRAME ] * 2;
	}
	
	void SetAttacker( Critter& attacker )
	{
		@Attacker = attacker;
		Hx = Attacker.HexX;
		Hy = Attacker.HexY;
		
		if( Attacker.Trait[ TRAIT_JINXED ] != 0 || Attacker.Perk[ PE_JINXED_II ] != 0 )
			IsJinked = true;
	}
	
	void SetTarget( Critter@ target )
	{
		@Target = target;
		if( Target !is null )
		{
			SetRealTarget( Target );
			
			if( Target.Trait[ TRAIT_JINXED ] != 0 || Target.Perk[ PE_JINXED_II ] != 0 )
				IsJinked = true;
		}
	}
	
	void SetTargetHex( uint16 hexX, uint16 hexY )
	{
		TargetHx = hexX;
		TargetHy = hexY;
	}
	
	void SetRealTarget( Critter& target )
	{
		@RealTarget = target;
		if( RealTarget !is null )
			SetTargetHex( RealTarget.HexX,	RealTarget.HexY );
	}
	
	void FillWeapon( int slot )
	{
		@RealWeapon = Attacker.GetItem( 0, slot );
		if( RealWeapon !is null )
		{
			DmgMin += RealWeapon.WeaponBonus_MinDamage;
			DmgMax += RealWeapon.WeaponBonus_MaxDamage;
			
			CriticalChance += RealWeapon.WeaponBonus_CritChance;
			
			if( IsBurst )
			{
				if( RealWeapon.AmmoCount < WeaponAmmoRound )
					WeaponAmmoRound = RealWeapon.AmmoCount;
			}
		}
	}
	
	void SetWeaponMode( uint8 weaponMode )
	{
		WeaponMode = weaponMode;
		WeaponUse = _WeaponModeUse( WeaponMode );
	}
	
	void SetProtoWeapon( ProtoItem& weapon, uint8 weaponMode )
	{
		@Weapon = weapon;
		WeaponPid = Weapon.ProtoId;
		SetWeaponMode( weaponMode );
		WeaponSkill = _WeaponSkill( Weapon, WeaponUse );
		
		WeaponSubtype = GetWeaponSubType();
		ScoreUnarmed = WeaponSubtype == WS_UNARMED;
		
		WeaponAmmoRound = _WeaponRound( Weapon, WeaponUse );
		IsBurst = ( WeaponAmmoRound > 1 ) && _WeaponNoBrust( Weapon, WeaponUse ) == 0;
		
		AddWeaponPerk( Weapon.Weapon_Perk );
		AddWeaponPerk( Weapon.Weapon_SecondPerk );
		
		DmgMin += _WeaponDmgMin( Weapon, WeaponUse );
		DmgMax += _WeaponDmgMax( Weapon, WeaponUse );
		
		CriticalChance += Weapon.Weapon_CriticalBonus;
		
		TypeAttack = _WeaponAttackType( Weapon, WeaponUse );
		
		UpdateWeaponProtoId();
		UpdateTypeDamage();
	}
	
	void FillCriticalChance()
	{
		CriticalChance += Attacker.Stat[ ST_CRITICAL_CHANCE ];
		if( IsAim )
			CriticalChance += Attacker.Stat[ ST_LUCK ] * 2;
	}
	
	void FillAim()
	{
		Aim = GetAim();
		IsAim = Aim != HIT_LOCATION_UNCALLED && Aim != HIT_LOCATION_NONE && Aim != HIT_LOCATION_TORSO;
	}
	
	void UpdateWeaponProtoId()
	{
		switch( Weapon.ProtoId )
		{
			case PID_FLAMER:
			case PID_IMPROVED_FLAMETHROWER:
			case PID_FIRE_GECKO_FLAME_WEAPON:
			case PID_FLAMER_MK3:
			case PID_FIRE_GECKO_FLAME_WEAPON_LIGHT:
				TypeAttack = ETypeAttack::TypeAttack_Flame;
				break;
			default: break;
		}
	}
	
	void FillGun()
	{
		if( WeaponSubtype != WS_GUN )
			return;
		BonusDmg += Attacker.Perk[ PE_BONUS_RANGED_DAMAGE ] * 2;
		
		if( Attacker.Perk[ PE_SNIPER ] != 0 )
			CriticalChance += GetBonusCriticalChanceForHitAim( Aim );
	}
	
	void FillThrowing()
	{		
		if( WeaponSubtype != WS_THROWING )
			return;
		BonusDmg += Attacker.Stat[ ST_THROWING_DAMAGE ];
		
		if( Attacker.Perk[ PE_SLAYER ] != 0 )
			CriticalChance += GetBonusCriticalChanceForHitAim( Aim );
	}
	
	void FillUnarmed()
	{
		if( !ScoreUnarmed )
			return;
			
		if( Weapon.Weapon_UnarmedArmorPiercing )
			AddWeaponPerk( WEAPON_PERK_PENETRATE );
		
		BonusDmg += Attacker.Stat[ ST_MELEE_DAMAGE ];
		TypeAttack = ETypeAttack::TypeAttack_Melee;
		
		@GetHitAim = GetHitAimUnarmed;
		
        CriticalChance += Weapon.Weapon_UnarmedCriticalBonus;
		CriticalChance += Attacker.Stat[ ST_LUCK ] * 2;
		if( Attacker.Perk[ PE_SLAYER ] != 0 )
			CriticalChance += GetBonusCriticalChanceForHitAim( Aim );
	}
	
	void SetAmmo( ProtoItem@ ammo )
	{
		@Ammo = ammo;
		if( Ammo !is null )
		{
			AmmoPid = Ammo.ProtoId;
			AddWeaponPerk( Ammo.Ammo_Perk );
			DRMod += Ammo.Ammo_DrMod;
			DMMod += Ammo.Ammo_DmgMult;
			DDMod += Ammo.Ammo_DmgDiv;
			TDMod += Ammo.Ammo_DTDiv;
			DmgMul += DMMod;
			UpdateTypeDamage( );
		}
	}
	
	bool CheckAmmo( )
	{
		if( Attacker.Mode[MODE_UNLIMITED_AMMO] != 0 )
			return true;
		if( Weapon.Ammo_Caliber == 0 && Weapon.Weapon_MaxAmmoCount == 0 )
			return true;
		if( !validEngineObject( RealWeapon ) )
			return true;
		if( IsBurst )
			return RealWeapon.AmmoCount != 0;
		return WeaponAmmoRound <= RealWeapon.AmmoCount;
	}
	
	void SetAttackerDirection( )
	{
		Attacker.SetDir( GetDirection( Hx, Hy, TargetHx, TargetHy ) );
	}
	
	void AttackerSay( uint message )
	{
		if( Attacker.IsPlayer() )
			Attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, message );
	}
	
	void SetSneakTimeout( Critter& critter )
	{
		if( critter.IsNpc() || critter.GetAccess() != ACCESS_ADMIN )
			critter.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( critter );
	}
	
	void SetCombatTimeout( Critter& critter )
	{
		if( critter.IsNpc() || critter.GetAccess() != ACCESS_ADMIN )
		{
			int targetTimeout = BATTLE_TIMEOUT( critter );
			Item@ targetArmor = _CritGetItemArmor( critter );

			if( validEngineObject( targetArmor ) )
				targetTimeout -= REAL_SECOND( targetArmor.Proto.BonusForOutOfCombat );

			if( __FullSecond + REAL_SECOND( 5 ) > uint( targetTimeout ) )
				targetTimeout = __FullSecond + REAL_SECOND( 5 );
			if( critter.Timeout[ TO_BATTLE ] < targetTimeout - __FullSecond )
			{
				critter.TimeoutBase[ TO_BATTLE ] = targetTimeout;
				uint[] indexes;
				if( critter.GetTimeEvents( CTE_END_BATTLE, indexes ) > 0 )
					critter.ChangeTimeEvent( indexes[ 0 ], targetTimeout - __FullSecond, 0, 0 );
				else
					critter.AddTimeEvent( "cte_EndBattle", targetTimeout - __FullSecond, CTE_END_BATTLE );
			}
			critter.RefreshSpeed();
		}
	}
	
	void CombatScoreAttacker()
	{
		if( Attacker.IsPlayer() )   // leaderboard
		{
			if( WeaponSubtype == WS_GUN )
				ChangePlayerScore( Attacker, SCORE_SHOOTER, 1 );
			else if( WeaponSkill == SK_UNARMED || WeaponSkill == SK_THROWING )
				ChangePlayerScore( Attacker, SCORE_UNARMED, 1 );
		}
	}
	
	void NpcAttacker_Say( )
	{
		if( Attacker.IsNpc() )
			AI_TrySayCombatText( Attacker, COMBAT_TEXT_ATTACK );
	}
	
	void Miss( )
	{
		if(Target is null)
			return;
		if( Target.IsNpc() )
			AI_TrySayCombatText( Target, COMBAT_TEXT_MISS );
		Target.Action( ACTION_DODGE, 0, null );     // Todo: type front/back
	}
	
	void ToHitCalculated( Critter@ target, uint16 targethx, uint16 targethy, int aim )
	{
		ToHit( target, aim, targethx, targethy );
	}
	
	int HitCheck( )
	{
		int margin = HitResult - Random( 1, 100 );

		// Дополнительная обработка трейта Jinxed
		if( margin >= 0 && IsJinked && Random( 1, 100 ) <= 5 )
		{
			margin = -1;
			IsCritical = true;
		}
		return margin;
	}
	
	void MissProccess( int roll )
	{
        // not setting isHit, we try a critical failure		
        if( Attacker.Mode[ MODE_INVULNERABLE ] == 0 )
        {
            if( !IsCritical )
                IsCritical = ( ( -roll ) * 0.1 >= Random( 1, 100 ) );
            if( IsCritical )
            {
                int roll = Random( 1, 100 ) - 5 * ( Attacker.Stat[ ST_LUCK ] - 5 );
                if( roll <= 20 )
                    roll = 0;
                else if( roll <= 50 )
                    roll = 1;
                else if( roll <= 75 )
                    roll = 2;
                else if( roll <= 95 )
                    roll = 3;
                else
                    roll = 4;
                CriticalFailFlags = CriticalFailureTable[ 5 * Weapon.Weapon_CriticalFailture + roll ];
                if( CriticalFailFlags == 0 )
                    IsCritical = false;
                IsRandomHit = FLAG( CriticalFailFlags, MF_HIT_RANDOMLY );
            }
        }
		
		if( IsHexAttack )
		{
			IsRandomHit = true;
		}
	}
	
	void HitProccess( int roll )
	{
		IsHit = true;
        IsCritical = Random( 1, 100 ) <= CriticalChance;
		
		int criticalResistance = 0;
		if( RealTarget !is null )
			criticalResistance = RealTarget.Stat[ ST_CRITICAL_RESISTANCE ];
        if( IsCritical && Random( 1, 100 ) <=  criticalResistance - ( CriticalChance > 100 ? ( CriticalChance - 100 ) : 0 ) )
            IsCritical = false;		
	}
	
	void RandomHitProccess( int roll )
	{
		if( IsRandomHit )
		{
			if( IsHexAttack )
			{
				if( Attacker.IsPlayer() )
					Attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, 109 );
				if( Random( Attacker.Stat[ ST_LUCK ], 100 ) >= 10 )        // Проверяем на удачу, вдруг попал в себя.
					Map.GetHexCoord( Hx, Hy, TargetHx, TargetHy, Random( roll, ABS( roll ) ), Random( 1, _WeaponMaxDist( Weapon, WeaponUse ) ) );
				else
				{
					TargetHx = Hx;
					TargetHy = Hy;
				}
			}
			else
			{
				Critter@ randomTarget = ChooseRandomTarget( Map, Attacker, RealTarget, _WeaponMaxDist( Weapon, WeaponUse ) );
				if( validEngineObject( randomTarget ) )
				{
					SetRealTarget( randomTarget );
					Aim = HIT_LOCATION_UNCALLED;
					if( Target !is null )
						NotifyOops( Attacker, Target, randomTarget, Results );
				}
			}			
		}
	}
	
	void RunAction()
	{
		Attacker.Action( ACTION_USE_WEAPON, ( ( ( !IsHit && IsCritical && !IsRandomHit ) ? 1 : 0 ) << 8 ) | ( Aim << 4 ) | WeaponUse, RealWeapon );
	}
	
	bool CriticalFailure()
	{
		if( !IsHit && IsCritical && ( !IsRandomHit  || !validEngineObject( RealTarget ) ) )
		{
			if( Attacker.IsPlayer() )
				Attacker.Say( SAY_NETMSG, "CriticalFailure. Your proccess cancelled" );
			::CriticalFailure( Attacker, Weapon, WeaponUse, Ammo, CriticalFailFlags, Results );
			return true;
		}
		return false;
	}
	
	void AlgoritmProccess()
	{
		GetCombatAlgoritm( this ).Proccess( );
	}
	
	void PlayNotAmmo( )
	{
		string sound = "WA01XXX1.ACM";
		sound[ 2 ] = _WeaponSoundId( Weapon, WeaponUse );
		Map.PlaySound( sound );
	}
	
	void PlayShot( )
	{
		string sound = "WAX1XXX1.ACM";
		sound[ 2 ] = _WeaponSoundId( Weapon, WeaponUse );
		Map.PlaySound( sound );
	}
	
	void ShootEffect()
	{
		if( IsHexAttack || Attacker.IsNpc() )
		{
			PlayShot();			
			Attacker.Animate( 0, _WeaponAnim2( Weapon, WeaponUse ), null, true, false );
        }
		else if( _WeaponEffect( Weapon, WeaponUse ) != 0 )
		{
			if( UseHex )
				Map.RunFlyEffect( _WeaponEffect( Weapon, WeaponUse ), Attacker, null, Hx, Hy, TargetHx, TargetHy, ExplodeId | Radius << 16 );  // yeah, the target can be null (see: grenades, rocket launcher)
			else
				Map.RunFlyEffect( _WeaponEffect( Weapon, WeaponUse ), Attacker, RealTarget, Hx, Hy, TargetHx, TargetHy, ExplodeId | Radius << 16 );
		}
	}
	
	void AmmoRemove()
	{
		if( validEngineObject( RealWeapon ) && Attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
		{
			if( WeaponAmmoRound > 0 )
			{
				uint startammo = RealWeapon.AmmoCount;
				if( RealWeapon.AmmoCount <= WeaponAmmoRound )
					RealWeapon.AmmoCount = 0;
				else
					RealWeapon.AmmoCount -= WeaponAmmoRound;
				RealWeapon.Update();
			}

			if( RealWeapon.IsDeteriorable() && Attacker.IsPlayer() )
				DeteriorateItem( Attacker, RealWeapon, ( ( ( MAX_SKILL_VAL - ( ( AttackerSkill * 90 ) * 0.01 ) ) / 3 ) * ( 90 + Weapon.BrokenCoefficient ) ) * 0.005 );

			// One time weapon, erase current and push next (if exist)
			if( _WeaponRemove( Weapon, WeaponUse ) )
			{
				{
					int slot = RealWeapon.CritSlot;
					Item@ stack = Attacker.GetStackItem( RealWeapon, true );
					if( stack is null )
					{
						uint16 protoid = RealWeapon.GetProtoId();
						if( WeaponSkill == SK_THROWING && !WeaponIsGrenade() )
						{
							RealWeapon.EventDrop( Attacker );
							MoveItem( RealWeapon, 1, Map, TargetHx, TargetHy );
						}
						else DeleteItem( RealWeapon );
						
						Item@[] items;
						for( uint i = 0, iEnd = Attacker.GetItems( SLOT_INV, items ); i < iEnd; i++ )
							if( items[ i ].GetProtoId() == protoid )
							{
								Attacker.MoveItem( items[ i ].Id, 1, slot );
								//items[ i ].Mode = weaponMode;
								items[ i ].Update( );
								// Mode
								break;
							}
					}
					else
					{
						if( WeaponSkill == SK_THROWING && !WeaponIsGrenade() )
						{
							stack.EventDrop( Attacker );
							MoveItem( stack, 1, Map, TargetHx, TargetHy );
						}
						else
						{
							uint count = stack.GetCount();
							if( count > 1 )
							{
								stack.SetCount( count - 1 );
								stack.Update();
							}
							else DeleteItem( stack );
						}
					}
				}
			}
		}
	}
	
	void ProccessShoot()
	{
		ShootEffect();
		AmmoRemove();		
	}
	
	void ProccessSpecialEffects()
	{
		switch( WeaponPid )   // Особый эффект оружия(не визуальный)
		{
			case PID_SMOKE_GRENADE:
				SmokeBlast( Map, TargetHx, TargetHy, PID_SMOKE, Attacker.Id );
				break;
				
			case PID_MUSTARD_GAS_GRENADE:
				SmokeBlast( Map, TargetHx, TargetHy, PID_MUSTARD_GAS, Attacker.Id );
				break;
				
			default:
				break;
		}
	}
	
	void ProccessAttack()
	{
		if( !IsHexAttack )
		{
			AlgoritmProccess();
			return;
		}
	
		uint16 effect = _WeaponEffect( Weapon, WeaponUse );
	
		switch( TypeAttack )
		{
			case WTA_LINE_IGNORED_RAKED:
			{
				CTraceLineIgnoredRaked Trace( this, Map, Attacker, RealWeapon, TargetHx, TargetHy );
				LineTracerHex( Hx, Hy, TargetHx, TargetHy, Map, GetWeaponMaxDistance(), Trace );
				Trace.EndTrace( RealWeapon );
				Map.RunFlyEffect( effect, null, null, Hx, Hy, TargetHx, TargetHy, EFFECT_INSTRUCTION_NONE );
			} break;
			
			case WTA_LINE_FLAME:
			{
				ProccessFlameLine( );
				if( effect != 0 )
					Map.RunFlyEffect( effect, null, null, Hx, Hy, TargetHx, TargetHy, EFFECT_INSTRUCTION_NONE );                  // Запускаем летящий снаряд.
			} break;

			case WTA_RADIUS_HEX:
			{
				if( effect != 0 )
				{
					ProtoItem@ protoEffect = GetProtoItem( effect );		
					if( protoEffect !is null )
					{
						Map.RunFlyEffect( effect, null, null, Hx, Hy, TargetHx, TargetHy, EFFECT_INSTRUCTION_NONE ); // Запускаем летящий снаряд.
						if( ExplodeId != 0 )
							Map.RunEffect( ExplodeId, TargetHx, TargetHy, Radius, EFFECT_INSTRUCTION_NONE );
						DamageHex( this, Map, Radius, IsQuakeScreen );
					}
				}
				else
					DamageHex( this, Map, Radius, IsQuakeScreen );


				if( TypeDamage == DAMAGE_FIRE )
					SetFire( Map, TargetHx, TargetHy, Radius, Random( DmgMin, DmgMax ), Attacker );

				if( WeaponAmmoRound > 0 && WeaponAmmoRound < 50 && IsBurst )
				{
					uint[] values = { WeaponAmmoRound, Map.Id, Attacker.Id, RealWeapon.Id, TargetHx, TargetHy, Radius, TypeDamage, ExplodeId, IsQuakeScreen ? 1 : 0 };
					CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME, "combat@e_ReAtack", values, false );
				}
			} break;
			
			default:
			{
				if( ( WeaponAmmoRound > 1 && IsBurst ) || WTA_BURST_REGION == TypeAttack )
				{
					if( WTA_BURST_REGION == TypeAttack )
					{
						MaintainAttack@ replay = cast<MaintainAttack@>(@Context);
						if( replay is null )
						{
							if( Attacker.TimeAttackId != 0 )
							{
								uint duration = 0;
								TimeEventDescriptor@ descriptor = GetTimeEvent( Attacker.TimeAttackId, duration );
								if( descriptor !is null )
								{
									@ replay = cast<MaintainAttack@>(@descriptor);
									if( replay is null || !replay.Check() )
									{
										EraseTimeEvent( Attacker.TimeAttackId );
										Attacker.TimeAttackId = 0;
									}
								}
								else 
								{
									EraseTimeEvent( Attacker.TimeAttackId );
									Attacker.TimeAttackId = 0;
								}
							}
							
							if( replay is null )
								@replay = MaintainAttack();
							
							replay.Fill(this);
							@Context = replay;
						}
						
						WeaponAmmoRound = replay.GetAmmoRound( );
						
						replay.Continue();
					}
					
					AlgoritmProccess();
					break;
				}
					
				if( effect != 0 )
				{
					ProtoItem@ protoEffect = GetProtoItem( effect );		
					if( protoEffect !is null )
					{							
						Map.RunFlyEffect( effect, null, null, Hx, Hy, TargetHx, TargetHy, EFFECT_INSTRUCTION_NONE ); // Запускаем летящий снаряд.
						if( ExplodeId != 0 )
							Map.RunEffect( ExplodeId, TargetHx, TargetHy, Radius, EFFECT_INSTRUCTION_NONE );
						DamageHex( this, Map, Radius, IsQuakeScreen );
						break;
					}
				}
				else
					DamageHex( this, Map, Radius, IsQuakeScreen );
				if( TypeDamage == DAMAGE_FIRE )
					SetFire( Map, TargetHx, TargetHy, Radius, Random( DmgMin, DmgMax ), Attacker );
				if( WeaponAmmoRound > 0 && WeaponAmmoRound < 50 && IsBurst )
				{
					uint[] values = { WeaponAmmoRound, Map.Id, Attacker.Id, RealWeapon.Id, TargetHx, TargetHy, Radius, TypeDamage, ExplodeId, IsQuakeScreen ? 1 : 0 };
					CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME, "combat@e_ReAtack", values, false );
				}
			} break;
		} 
	}
	
	bool CheckBroken( )
	{
		if( RealWeapon is null )
			return true;
		return !FLAG( RealWeapon.BrokenFlags, BI_BROKEN );
	}
	
	bool CheckAttack( )
	{
		if( !CheckAmmo( ) )
		{
			AttackerSay( STR_COMBAT_NEED_OUT_OF_AMMO );
			PlayNotAmmo();
			Attacker.Animate( 0, _WeaponAnim2( Weapon, WeaponUse ), null, true, false );
			Result = CombatResult::ammo_ran_out;
			return false;
		}
		
		if( !CheckBroken( ) )
		{
			AttackerSay( STR_DETERIORATION_WEAPON_BROKEN );
			Result = CombatResult::broken_weapon;
			return false;
		}
		
		return true;
	}
	
	bool Attack(  )
	{
		if( !CheckAttack( ) )
			return false;
			
		SetCombatTimeout( Attacker );
		SetSneakTimeout( Attacker );
		
		CombatScoreAttacker();
		NpcAttacker_Say();
		
		ToHitCalculated( RealTarget, TargetHx, TargetHy, Aim );

		int hitRoll = HitCheck();
		if( hitRoll < 0 )
		{
			MissProccess( hitRoll );
			RandomHitProccess( hitRoll );
		}
		else HitProccess( hitRoll );
		
		if( RealTarget !is null )
		{
			UnSneak( RealTarget );
			RealTarget.EventAttacked( Attacker );
		}
		SetAttackerDirection( );
		ProccessSpecialEffects();
		
		if( CriticalFailure() )
		{
			Result = CombatResult::critical_fail;
			return false;
		}
		
		if( RealTarget !is null && !IsSilentAtack( RealTarget ) )
			UnSneak( Attacker );

		ProccessAttack();
		ProccessShoot( );
		FlushResults( Results );
		
		if( !TargetHit )
			Miss();
		
		// WIP
		if( ExplodeId == PID_EXPLODE_NUKLEAR )
		{
			uint[] values = { 22, Map.Id, Attacker.Id, RealWeapon.Id, TargetHx, TargetHy, 1, TypeDamage, PID_EXPLODE_FIRE_BIG, IsQuakeScreen ? 1 : 0 };
			CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME * 10, "combat@e_ReAtack", values, false );
		}
		Result = CombatResult::success;
		return true;
	}
	
	int GetResult()
	{
		return Result;
	}
}

mixin class MixinFlamerProccess
{
	void ProccessFlameLine( )
	{
		uint16 hx = Hx,
				hy = Hy,
				wx = 0,
				wy = 0;

		uint attackRange = GetWeaponMaxDistance();

		uint radius = 1;
		uint dir = 0;
		uint16 dx = TargetHx;
		uint16 dy = TargetHy;
		Map.GetHexCoord( hx, hy, dx, dy, 0, attackRange );

		uint[] AllHex, targetIds;
		bool[] isFlameDirect = { true, true, true };
		
		for( uint n = 0; n < attackRange; n++ )
		{
			dir = GetDirection( hx, hy, dx, dy );
			Map.MoveHexByDir( hx, hy, dir, 1 );
			wx = hx;
			wy = hy;
			if( !Map.IsHexRaked( wx, wy ) )
				break;

			uint d = 0;

			for( uint r = 0; r < radius; r++ )
			{
				if( Hx == wx && Hy == wy )
					continue;
				if( Map.IsHexRaked( wx, wy ) )
				{
					if( isFlameDirect[ d ] )
					{
						if( !TargetHex( wy * Map.GetWidth() + wx, AllHex ) )
						{
							DamageHex( this, Map, 1, false, targetIds );
							SetFire( Map, wx, wy, 1, Random( DmgMin, DmgMax ), Attacker );
						}
					}
				}
				else
					isFlameDirect[ d ] = false;
				wx = hx;
				wy = hy;
				d = ( r % 2 == 0 ) ? d = 1 : d = 2;
				Map.MoveHexByDir( wx, wy, ( r % 2 == 0 ) ? ( dir + 1 ) % 6 : ( dir - 1 ) % 6, r / 2 + 1 );
			}
			if( radius - 1 < Radius )
				radius++;
		}
	}
}

bool CombatAttack( Combat@ proccess )
{
	return proccess.Attack( );
}

bool CombatAttack( Critter& attacker, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo ) // Export
{
    return CombatAttack( Combat( attacker, target, weapon, weaponMode, ammo ) );
}

void ApplyDamage( CombatProccess& proccess, Critter& target, uint rounds, bool isCritical, bool intentionally, CombatRes[]& results )
{
    Map@ map = target.GetMap();
	proccess.DropDamage();
	
    if( target.IsDead() || !( validEngineObject( map ) ) )
        return;

    if( !__NewbieLocationIsPvp && validEngineObject( proccess.Attacker ) && proccess.Attacker.IsPlayer() && target.IsPlayer() && map.GetLocation().GetProtoId() == LOCATION_NewbieLocation )
    {
        proccess.Attacker.Say( SAY_NETMSG, "Oh-oh! Not this time, my friend!" );
        return;         // НоПвп в Нубке.
    }

    if( validEngineObject( proccess.Attacker ) && intentionally && target.Id != proccess.TargetId )
        target.EventAttacked( proccess.Attacker );

    startCombatTimeout( target );
    uint             countMissAc = 0;
    ProtoItem@ ammo = validEngineObject( proccess.RealWeapon ) ? GetProtoItem( proccess.RealWeapon.AmmoPid ) : null;
    int              bonusAc = ( ammo !is null ) ? ( 0 - ammo.Ammo_AcMod ) : 0;
    if( !isCritical )
    {
        for( uint i = 0; i < rounds; i++ )
            if( Random( 0, 99 ) < target.Stat[ ST_ARMOR_CLASS ] + bonusAc )
                countMissAc++;

        if( countMissAc == rounds )
        {
            NotifyMissAc( target, results );
            return;
        }
    }
    rounds -= countMissAc;

    uint eff = 0,
         msgEff = 0,
         extraMessage = 0,
         extraMessageSelf = 0,
         CountOfCriticalsBulets = 0;

    @proccess.ArmorTarget = _CritGetItemArmor( target );

    uint8 MortirFD = validEngineObject( proccess.RealWeapon ) ? proccess.RealWeapon.Proto.Weapon_FlyingDistance : 0;

    bool  isGrenade = proccess.WeaponSubtype == WS_THROWING && proccess.TypeDamage != DAMAGE_NORMAL,
          isPowerArmor = (  target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_POWERED ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_POWERED_II ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_ADVANCED_I ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_ADVANCED_II ||
                            target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_SENTRY_BOTS || target.Perk[ PE_STONEWALL ] != 0 );

    if( target.IsNpc() && ( target.Stat[ ST_BASE_CRTYPE ] == CRTYPE_PA || target.Stat[ ST_BASE_CRTYPE ] == CRTYPE_PA_NO_HEAD || target.Stat[ ST_BASE_CRTYPE ] == CRTYPE_APA ) )
        isPowerArmor = true;

	if( target.Id == proccess.TargetId )
		proccess.TargetHit = true;
	
    // Check no PvP
    if( target.IsPlayer() )
    {
        if( validEngineObject( proccess.Attacker ) )
        {
            if( proccess.Attacker.IsPlayer() && ( proccess.Attacker.Mode[ MODE_NO_PVP ] != 0 || target.Mode[ MODE_NO_PVP ] != 0 ) )
            {
                proccess.Attacker.Say( SAY_NETMSG, "No PvP." );
                target.Say( SAY_NETMSG, "No PvP." );
                return;
            }
        }
    }

    if( target.IsNpc() || target.GetAccess() != ACCESS_ADMIN )
        target.ModeBase[ MODE_HIDE ] = 0;

    int bonusChance = 0;

    // определение количества критических попаданий в очереди
    if( validEngineObject( proccess.RealWeapon ) )
        bonusChance = proccess.RealWeapon.WeaponBonus_CritChance + proccess.RealWeapon.Proto.Weapon_CriticalBonus;
    if( rounds > 1 && intentionally )
    {
        int critChance = proccess.Attacker.Stat[ ST_CRITICAL_CHANCE ] + bonusChance,
            antiCritRes = critChance > 100 ? critChance - 100 : 0;
        for( uint i = 0; i < rounds; i++ )
        {
            int rand = Random( 1, 100 ),
                rand2 = Random( 1, 100 );

            if( rand <= critChance && rand2 > ( target.Stat[ ST_CRITICAL_RESISTANCE ] - antiCritRes ) )
                CountOfCriticalsBulets++;
        }
        if( CountOfCriticalsBulets > 0 )
            isCritical = true;
    }
    else if( isCritical )
        CountOfCriticalsBulets = 1;

    uint[] dmgMulForCriticalsHits( CountOfCriticalsBulets, 1 );    // массив множителей урона, для каждой пули в очереди
    /*for( uint i = 0; i < CountOfCriticalsBulets; i++ )
    {
        dmgMulForCriticalsHits[ i ] = 1;
    }*/

    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
        isCritical = false;
    else if( isCritical || proccess.ForceFlags != 0 )
    {
        if( isCritical )
        {
            int aim_ = proccess.Aim,
                roll = 0;
            if( aim_ == HIT_LOCATION_NONE )
                aim_ = HIT_LOCATION_UNCALLED;
            aim_--;
            uint offset = 0;

            for( uint i = 0; i < CountOfCriticalsBulets; i++ )
            {
                roll = Random( 0, 90 ) + ( validEngineObject( proccess.Attacker ) ? ( ( proccess.Attacker.Perk[ PE_BETTER_CRITICALS ] != 0 ? 10 : 0 ) +
                                                                                    ( ( proccess.Attacker.Trait[ TRAIT_FAST_SHOT ] != 0 && proccess.WeaponSubtype == WS_GUN ) ? -25 : 0 ) +
                                                                                    ( proccess.Attacker.Trait[ TRAIT_HEAVY_HANDED ] != 0 ? -15 : 0 ) +
                                                                                    ( proccess.IsWeaponPerk( WEAPON_PERK_BETTER_CRITICALS ) ? 10 : 0 ) ) : 0 ) - target.Perk[ PE_TOUGHNESS ] * 4;
                if( validEngineObject( proccess.Attacker ) )
                {
                    if( validEngineObject( proccess.RealWeapon ) )
                    {
                        roll += proccess.RealWeapon.WeaponBonus_Critroll + proccess.RealWeapon.Proto.Weapon_BonusCritRoll;
                        uint use = 0;
                        int  skillWeapon = _WeaponSkill( proccess.RealWeapon.Proto, use );
                        switch( skillWeapon )
                        {
                        case SK_UNARMED:
                        case SK_THROWING:
                            roll += proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT_ROLL ];
                            break;
                        case SK_ENERGY_WEAPONS:
                        case SK_SMALL_GUNS:
                        case SK_BIG_GUNS:
                            roll += proccess.Attacker.BookBonus[ BB_RANGED_CRIT_ROLL ];
                            break;
                        default:
                            break;
                        }
                    }
                    else if( proccess.ScoreUnarmed )
                        roll += proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT_ROLL ];
                }
                if( roll <= 20 )
                    roll = 0;
                else if( roll <= 45 )
                    roll = 1;
                else if( roll <= 70 )
                    roll = 2;
                else if( roll <= 90 )
                    roll = 3;
                else if( roll <= 100 )
                    roll = 4;
                else
                    roll = 5;
                offset = target.Stat[ ST_BODY_TYPE ] * 9 * 6 * 7 + aim_ * 6 * 7 + roll * 7;
                dmgMulForCriticalsHits[ i ] = CriticalTable[ offset ];
            }

// 0x00000001 - knockout
// 0x00000002 - knockdown
// 0x00000004 - crippled left leg
// 0x00000008 - crippled right leg
// 0x00000010 - crippled left arm
// 0x00000020 - crippled right arm
// 0x00000040 - blinded
// 0x00000080 - death
// 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug) // not used now
// 0x00000800 - bypass armor
// 0x00004000 - dropped weapon (doesn't work) // haha, really?
// 0x00008000 - lose next turn
// 0x00200000 - random

            eff = CriticalTable[ offset + 1 ];
            int stat = CriticalTable[ offset + 2 ],
                statMod = CriticalTable[ offset + 3 ];

            uint cMessage = CriticalTable[ offset + 5 ],
                 cFailureMessage = CriticalTable[ offset + 6 ];

            extraMessage = cMessage;

            if( stat != -1 && ( Random( 1, 10 ) > ( target.Stat[ stat ] + statMod ) ) )
            {
                eff |= CriticalTable[ offset + 4 ];
                extraMessage = cFailureMessage;
            }

            if( target.Mode[ MODE_NO_KNOCK ] != 0 )
                UNSETFLAG( eff, HF_KNOCKDOWN );
        }

        if( proccess.ForceFlags != 0 )
        {
            eff |= proccess.ForceFlags;
            isCritical = true;
        }

        // in the following: in no lose limbs, then clear the effects and set msgEff
        // otherwise set msgEff first, then check for HF_RANDOM
        if( target.Mode[ MODE_NO_LOOSE_LIMBS ] != 0 )
        {
            UNSETFLAG( eff, ( HF_CRIPPLED_LEFT_LEG | HF_CRIPPLED_RIGHT_LEG | HF_CRIPPLED_LEFT_ARM | HF_CRIPPLED_RIGHT_ARM | HF_RANDOM ) );
            msgEff = eff;
        }
        else
        {
            msgEff = eff;

            if( FLAG( eff, HF_RANDOM ) )
            {
                UNSETFLAG( eff, HF_RANDOM );
                switch( Random( 1, 4 ) )
                {
                case 1:
                    SETFLAG( eff, HF_CRIPPLED_LEFT_LEG );
                    break;
                case 2:
                    SETFLAG( eff, HF_CRIPPLED_RIGHT_LEG );
                    break;
                case 3:
                    SETFLAG( eff, HF_CRIPPLED_LEFT_ARM );
                    break;
                case 4:
                    SETFLAG( eff, HF_CRIPPLED_RIGHT_ARM );
                    break;
                default:
                    break;
                }
            }
        }

        if( validEngineObject( proccess.Attacker ) && proccess.Attacker.IsPlayer() )
            ChangePlayerScore( proccess.Attacker, SCORE_SNIPER, 1 );
    }     // end isCritical

    proccess.TargetDR = target.Stat[ ST_NORMAL_RESIST + proccess.TypeDamage - 1 ];
    proccess.TargetDT = target.Stat[ ST_NORMAL_ABSORB + proccess.TypeDamage - 1 ];

    if( proccess.TypeDamage == DAMAGE_EMP && target.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
    {
        proccess.TargetDR = 0;
        proccess.TargetDT = 0;
    }
    else
    {
        if( proccess.IsWeaponPerk( WEAPON_PERK_PENETRATE ) )
            proccess.TargetDR -= 15;
        if( FLAG( eff, HF_BYPASS_ARMOR ) && proccess.TypeDamage != DAMAGE_EMP )
        {
            proccess.TargetDT *= 0.2;
            proccess.TargetDR *= 0.5;
            proccess.TargetDR -= ( validEngineObject( proccess.Attacker ) ? ( proccess.Attacker.Trait[ TRAIT_FINESSE ] != 0 ? 30 : 0 ) : 0 );
        }
        if( isGrenade && validEngineObject( proccess.Attacker ) && proccess.Attacker.Perk[ PE_ARMOR_BUSTER ] != 0 )
            proccess.TargetDR -= 25;

        proccess.TargetDR += ( validEngineObject( proccess.Attacker ) ? ( proccess.Attacker.Trait[ TRAIT_FINESSE ] != 0 ? 30 : 0 ) : 0 );
        if( proccess.IsWeaponPerk( WEAPON_PERK_FLAMEBOY ) )
            proccess.TargetDR -= 10;
        // Log("targetDR1="+targetDR);
        proccess.TargetDR += proccess.DRMod;       // always
        // Log("targetDR2="+targetDR);
    }

    proccess.TargetDR = CLAMP( proccess.TargetDR, 0, 100 );
    if( proccess.TDMod != 0 )
        proccess.TargetDT /= proccess.TDMod;
    proccess.DmgMin += proccess.BonusDmg;
    proccess.DmgMax += proccess.BonusDmg;
    int rawDmg = 0,
        typeDamage = proccess.TypeDamage,
        totalDmg = 0;

	Mk2::CombatTargetPacket@ scriptTarget = cast<Mk2::CombatTargetPacket>(@target.ScriptDescriptor);		
    {
        // некритические попадания в очереди
        bool argIsCrit = false;
        uint damageMulCrit = 1;

        for( uint i = 0; i < ( rounds - CountOfCriticalsBulets ); i++ )
        {
            typeDamage = proccess.TypeDamage;

            {
                if( !scriptTarget.FormatDamage( proccess, rawDmg, typeDamage, argIsCrit, damageMulCrit, i ) )
                    break;
            }

            if( rawDmg > 0 )
            {
                proccess.Damage[ typeDamage ] = proccess.Damage[ typeDamage ] + rawDmg;
                // totalDmg+=rawDmg;
            }
        }

        uint bulleti = rounds - CountOfCriticalsBulets;
        // критические попадания в очереди
        argIsCrit = true;
        for( uint i = 0; i < CountOfCriticalsBulets; i++ )
        {
            typeDamage = proccess.TypeDamage;

            {
                if( !scriptTarget.FormatDamage( proccess, rawDmg, typeDamage, argIsCrit, dmgMulForCriticalsHits[ i ], bulleti++ ) )
                    break;
            }

            if( rawDmg > 0 )
                proccess.Damage[ typeDamage ] = proccess.Damage[ typeDamage ] + rawDmg;
        }
    }

    // 0x00000001 - knockout
    // 0x00000002 - knockdown
    // 0x00000004 - crippled left leg
    // 0x00000008 - crippled right leg
    // 0x00000010 - crippled left arm
    // 0x00000020 - crippled right arm
    // 0x00000040 - blinded
    // 0x00000080 - death
    // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug)
    // 0x00000800 - bypass armor
    // 0x00004000 !- dropped weapon (doesn't work)
    // 0x00008000 - lose next turn

    // code for dropping weapon, adapted from critical failures

    bool isKo = false,
         knockDown = false,
         knockOut = false,
         isDead = false,
         loseTurn = false,
         isBelow = false;

    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
        eff = 0;
    // Knock down
    if( FLAG( eff, HF_KNOCKDOWN ) )
    {
        isKo = true;
        knockDown = true;
    }
    else if( ( proccess.TypeDamage == DAMAGE_EXPLODE && proccess.Damage[ DAMAGE_EXPLODE ] > 9 ) || ( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 8 ) )
        isKo = true;

    // Clipped LLeg
    if( FLAG( eff, HF_CRIPPLED_LEFT_LEG ) )
        target.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
    // Clipped RLeg
    if( FLAG( eff, HF_CRIPPLED_RIGHT_LEG ) )
        target.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
    // Clipped LArm
    if( FLAG( eff, HF_CRIPPLED_LEFT_ARM ) )
        target.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
    // Clipped RArm
    if( FLAG( eff, HF_CRIPPLED_RIGHT_ARM ) )
        target.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
    // Blinded
    if( FLAG( eff, HF_BLINDED ) )
        target.DamageBase[ DAMAGE_EYE ] = 1;

    // Lose turn
    if( FLAG( eff, HF_LOST_NEXT_TURN ) )
    {
        isKo = true;
        loseTurn = true;
    }
    // Knock out
    if( FLAG( eff, HF_KNOCKOUT ) )
    {
		if( !isPowerArmor || Random( 1, 100 ) >= 40 )
		{
			isKo = false;
			knockDown = false;
			knockOut = false;
			loseTurn = false;
		}
		else
		{
			isKo = true;
			knockOut = true;
			loseTurn = false;       // overridden
		}
    }

    if( target.Mode[ MODE_NO_DROP ] != 0 )
    {
        UNSETFLAG( eff, HF_DROPPED_WEAPON );
        UNSETFLAG( msgEff, HF_DROPPED_WEAPON );
    }

    if( validEngineObject( proccess.Attacker ) )
    {
        if( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 5 )
            proccess.Damage = proccess.Damage * 1.4;                                                                                                                                        // Усиленный урон дробовиком
        if( proccess.Attacker.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( target.Stat[ ST_BODY_TYPE ] == BT_ALIEN || target.Stat[ ST_BODY_TYPE ] == BT_ROBOT ) )
            proccess.Damage = proccess.Damage + Random( 10, 20 );                                                                                                                           // yes, pulse grenade works
        if( proccess.Attacker.Perk[ PE_PYROMANIAC ] != 0 && ( proccess.TypeDamage == DAMAGE_FIRE || proccess.Damage[ DAMAGE_FIRE ] > 0 ) )
            proccess.Damage[ DAMAGE_FIRE ] = proccess.Damage[ DAMAGE_FIRE ] + Random( 10, 30 );
    }
	
	totalDmg = proccess.TotalDamage;
    if( totalDmg > 0 )
    {
        if( target.Mode[ MODE_INVULNERABLE ] == 0 )
        {
            if( validEngineObject( proccess.Attacker ) )
            {
                if( validEngineObject( proccess.RealWeapon ) )
                {
                    int skillWeapon = _WeaponSkill( proccess.RealWeapon.Proto, proccess.RealWeapon.Mode );
                    switch( skillWeapon )
                    {
                    case SK_UNARMED:
                    case SK_THROWING:
                        proccess.Damage = proccess.Damage + proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_DAMAGE ];
                        break;
                    case SK_ENERGY_WEAPONS:
                        proccess.Damage = proccess.Damage + int(totalDmg * 0.01 * proccess.Attacker.BookBonus[ BB_ENERGY_DAMAGE ]);
                        break;
                    case SK_SMALL_GUNS:
                        proccess.Damage = proccess.Damage + int(totalDmg * 0.01 * proccess.Attacker.BookBonus[ BB_SMALL_DAMAGE ]);
                        break;
                    case SK_BIG_GUNS:
                        proccess.Damage = proccess.Damage + int(totalDmg * 0.01 * proccess.Attacker.BookBonus[ BB_BIG_DAMAGE ]);
                        break;

                    default:
                        break;
                    }
                }
                else if( proccess.ScoreUnarmed )
                    proccess.Damage = proccess.Damage + proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_DAMAGE ];
            }
           
            proccess.IsCritical = isCritical;

            if( scriptTarget !is null )
                scriptTarget.TakeDamage( proccess, 1, totalDmg );

            if( target.Stat[ ST_CURRENT_HP ] < 1 )
            {
                isKo = true;
                isBelow = true;

                int DeadHitPoints = target.Stat[ ST_DEAD_HIT_POINTS ];
                if( ( DeadHitPoints == __DeadHitPoints && ( target.Stat[ ST_BODY_TYPE ] != BT_MEN && target.Stat[ ST_BODY_TYPE ] != BT_WOMEN &&
                                                            target.Stat[ ST_BODY_TYPE ] != BT_CHILDREN && target.Stat[ ST_BODY_TYPE ] != BT_SUPER_MUTANT && target.Stat[ ST_BODY_TYPE ] != BT_GHOUL && target.Stat[ ST_BODY_TYPE ] != BT_BRAHMIN && target.Stat[ ST_BODY_TYPE ] != BT_DOG ) ) ||
                    target.Mode[ MODE_NO_KNOCK ] != 0 )
                    DeadHitPoints = 0;
                if( target.Stat[ ST_CURRENT_HP ] <= DeadHitPoints )
                    isDead = true;
            }
        }
        // Score
        if( proccess.ScoreUnarmed && validEngineObject( proccess.Attacker ) && proccess.Attacker.IsPlayer() )
            ChangePlayerScore( proccess.Attacker, SCORE_UNARMED_DAMAGE, totalDmg );
    }
    else
    {
        proccess.IsCritical = isCritical;
			
        if( scriptTarget !is null )
            scriptTarget.TakeDamage( proccess, 2, totalDmg );
    }
	
    bool attackFront = true;
    {
        uint dir = GetDirection( proccess.Hx, proccess.Hy, target.HexX, target.HexY );
        if( ( dir == target.Dir || ( ( dir + 1 ) % 6 ) == target.Dir || ( ( dir + 5 ) % 6 ) == target.Dir ) )
            attackFront = false;
    }

    if( validEngineObject( proccess.ArmorTarget ) && target.IsPlayer() )
        DeteriorateItem( target, proccess.ArmorTarget, ( ( ( ( 100 - ( target.Stat[ ST_NORMAL_RESIST + proccess.TypeDamage - 1 ] ) ) * rounds + ( totalDmg < 10 ? 10 : totalDmg ) ) / 3 ) * ( 65 + proccess.ArmorTarget.Proto.BrokenCoefficient ) ) * 0.01  );

    if( proccess.IsWeaponPerk( WEAPON_PERK_ELECTRIC_SHOCK ) )
        target.StatBase[ ST_CURRENT_AP ] -= Random( 1, 2 ) * 100;

    // Dead
    if( isDead )
    {
        bool  burst = proccess.IsBurst;
        uint8 anim2Dead = 0;

        if( target.IsKnockout() && proccess.TypeDamage != DAMAGE_EXPLODE )
        {
            if( target.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT )
                anim2Dead = ANIM2_DEAD_PRONE_FRONT;
            else
                anim2Dead = ANIM2_DEAD_PRONE_BACK;
        }
        else
        {
            anim2Dead = attackFront ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK;

            switch( proccess.TypeDamage )
            {
            case DAMAGE_UNCALLED:
                break;
            case DAMAGE_NORMAL:
                if( burst )
                {
                    if( isCritical || proccess.BloodyMess )
                        anim2Dead = ANIM2_DEAD_BLOODY_BURST;
                    else
                        anim2Dead = ANIM2_DEAD_BURST;
                }
                else if( isCritical || proccess.BloodyMess )
                    anim2Dead = ANIM2_DEAD_BLOODY_SINGLE;
                else
                {
                    if( isKo || ( MortirFD != 0 && !isPowerArmor ) )
                    {
                        if( ( isBelow || knockOut || ( ( MortirFD != 0 || knockDown || proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) )  && !isPowerArmor ) ) && !target.IsKnockout() && target.Mode[ MODE_NO_KNOCK ] == 0 )
                        {
                            int knockDist = totalDmg;
                            if( ( ( proccess.WeaponPid >= PID_CLUB && proccess.WeaponPid <= PID_SUPER_SLEDGE ) || ( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 8 ) || MortirFD != 0 || proccess.TypeDamage == DAMAGE_EXPLODE ) && target.IsCanWalk() )
                            {
                                if( proccess.IsWeaponPerk( WEAPON_PERK_KNOCKBACK ) )
                                    knockDist *= 0.2;
                                else if( MortirFD != 0 )
                                {
                                    knockDist *= 0 * 33;
                                    if( knockDist > MortirFD )
                                        knockDist = MortirFD;
                                }
                                else if( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) )
                                {
                                    knockDist *= 0.17;
                                    if( knockDist > 7 )
                                        knockDist = 7;
                                }
                                else
                                    knockDist *= 0.1;
                                knockDist--;
                                if( knockDist > 10 && MortirFD == 0 )
                                    knockDist = 10;
                                uint16 knockHx = proccess.Hx,
                                       knockHy = proccess.Hy;
                                if( knockDist > 0 )
                                {
                                    if( knockHx == target.HexX && knockHy == target.HexY && validEngineObject( proccess.Attacker ) )
                                    {
                                        knockHx = proccess.Attacker.HexX;
                                        knockHy = proccess.Attacker.HexY;
                                    }
                                    map.GetHexCoordWall( target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist );
                                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, knockHx, knockHy );
                                }
                                else
                                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
                            }
                            else
                                target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
                        }
                    }
                }
                break;
            case DAMAGE_LASER:
                anim2Dead = ANIM2_DEAD_LASER;
                break;
            case DAMAGE_FIRE:
                if( proccess.BloodyMess || Random( 0, 1 ) == 0 )
                    anim2Dead = ANIM2_DEAD_BURN_RUN;
                else
                    anim2Dead = ANIM2_DEAD_BURN;
                break;
            case DAMAGE_PLASMA:
                anim2Dead = ANIM2_DEAD_FUSED;
                break;
            case DAMAGE_ELECTR:
                if( Random( 0, 1 ) == 0 )
                    anim2Dead = ANIM2_DEAD_PULSE;
                else
                    anim2Dead = ANIM2_DEAD_PULSE_DUST;
                break;
            case DAMAGE_EXPLODE:
                anim2Dead = ANIM2_DEAD_EXPLODE;
                break;
            default:
                break;
            }
        }

        if( target.IsPlayer() )
            ChangePlayerScore( target, SCORE_ZOMBY, 1 );

        if( validEngineObject( proccess.Attacker ) )
        {
            if( proccess.Attacker.IsPlayer() )
            {
                ChangePlayerScore( proccess.Attacker, SCORE_KILLER, 1 );
                if( target.IsPlayer() )
                    ChangePlayerScore( proccess.Attacker, SCORE_MANIAC, 1 );
                else if( target.Id == proccess.TargetId )
                    target.AddEnemyInStack( proccess.Attacker.Id );
            }
            else
                proccess.Attacker.EraseEnemyFromStack( target.Id );

            // if(target.ModeBase[MODE_ENCAUNTER_MOB]!=1) attacker.StatBase[ST_EXPERIENCE]+=target.Stat[ST_KILL_EXPERIENCE];
            if( target.IsPlayer() )
                proccess.Attacker.KillBase[ KILL_PLAYERS ]++;
            proccess.Attacker.KillBase[ KILL_BEGIN + target.Stat[ ST_BODY_TYPE ] ]++;
        }
        target.ToDead( anim2Dead, proccess.Attacker );
    }
    else if( isKo || ( MortirFD != 0 && !isPowerArmor ) )
    {
        int maxAp = target.Stat[ ST_ACTION_POINTS ],
            currentAp = target.Stat[ ST_CURRENT_AP ],
            targetAp = currentAp;

        if( loseTurn )
        {
            targetAp = -target.Perk[ PE_QUICK_RECOVERY ] != 0 ? maxAp * 0.5 : maxAp;
            target.StatBase[ ST_MOVE_AP ] = 0;
        }
        if( knockOut )
            targetAp = -Random( maxAp, 2 * maxAp - target.Perk[ PE_QUICK_RECOVERY ] != 0 ? maxAp * 0.5 : 0 );
        if( knockDown && !( target.IsKnockout() && map.IsTurnBased() ) )
            targetAp -= ( target.Perk[ PE_QUICK_RECOVERY ] != 0 ? 1 : 3 );
        if( ( isBelow || knockOut || ( ( MortirFD != 0 || knockDown || proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) || proccess.TypeDamage == DAMAGE_EXPLODE )  && !isPowerArmor ) ) && !target.IsKnockout() && target.Mode[ MODE_NO_KNOCK ] == 0 )
        {
            int knockDist = totalDmg;
            if( ( ( proccess.WeaponPid >= PID_CLUB && proccess.WeaponPid <= PID_SUPER_SLEDGE ) || ( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) && proccess.Distantion < 8 ) || MortirFD != 0 || proccess.TypeDamage == DAMAGE_EXPLODE ) && target.IsCanWalk() )
            {
                if( proccess.IsWeaponPerk( WEAPON_PERK_KNOCKBACK ) )
                    knockDist *= 0.2;
                else if( MortirFD != 0 )
                {
                    knockDist /= 3;
                    if( knockDist > MortirFD )
                        knockDist = MortirFD;
                }
                else if( proccess.IsWeaponPerk( WEAPON_PERK_SHOTGUN ) )
                {
                    knockDist *= 0.16;
                    if( knockDist > 7 )
                        knockDist = 7;
                }
                else
                    knockDist *= 0.1;
                knockDist--;
                if( knockDist > 10 && MortirFD == 0 )
                    knockDist = 10;
                uint16 knockHx = proccess.Hx,
                       knockHy = proccess.Hy;
                if( knockDist > 0 )
                {
                    if( knockHx == target.HexX && knockHy == target.HexY && validEngineObject( proccess.Attacker ) )
                    {
                        knockHx = proccess.Attacker.HexX;
                        knockHy = proccess.Attacker.HexY;
                    }
                    map.GetHexCoordWall( target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist );
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, knockHx, knockHy );
                }
                else
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
            }
            else
                target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
        }
        if( targetAp < currentAp )
            target.StatBase[ ST_CURRENT_AP ] = 100 * targetAp;
    }
    
    // TabaK. Добавил проверку на смерть. Дюп пофикшен???
    if( FLAG( eff, HF_DROPPED_WEAPON ) || ( ( target.Stat[ ST_CURRENT_HP ] < 1 ) && target.IsPlayer() && target.Mode[ MODE_NO_DROP ] == 0 && !isDead ) )
    {
        Item@ realWeaponTarget = _CritGetItemHand( target );
        if( validEngineObject( realWeaponTarget ) )
        {
            if( FLAG( realWeaponTarget.Flags, ITEM_GAG ) )
                DeleteItem( realWeaponTarget );
            else
            {
                MoveItem( realWeaponTarget, 1, map, target.HexX, target.HexY );
                realWeaponTarget.EventDrop( target );
                if( target.IsNpc() )
                {
                    NpcPlane@ plane = CreatePlane();

                    NpcPlane@[] crPlanes( 0 );

                    if( target.GetPlanes( crPlanes ) > 0 )
                        plane.Priority = crPlanes[ 0 ].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = realWeaponTarget.HexX;
                    plane.Pick_HexY = realWeaponTarget.HexY;
                    plane.Pick_Pid = realWeaponTarget.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    target.AddPlane( plane );
                }
            }
        }
    }
    // Damage
    else if( !target.IsKnockout() )
    {
        // Animate hit
        if( proccess.ShowHitAnimForce )
            target.Action( ACTION_DAMAGE_FORCE, attackFront ? 0 : 1, null );
        else
            target.Action( ACTION_DAMAGE, attackFront ? 0 : 1, null );

        // Npc hit message
        if( proccess.CombatMessage && proccess.TypeDamage != DAMAGE_UNCALLED && target.IsNpc() )
        {
            switch( proccess.Aim )
            {
            case HIT_LOCATION_NONE:
            case HIT_LOCATION_UNCALLED:
            case HIT_LOCATION_TORSO:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_TORSO );
                break;
            case HIT_LOCATION_EYES:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_EYES );
                break;
            case HIT_LOCATION_HEAD:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_HEAD );
                break;
            case HIT_LOCATION_LEFT_ARM:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_LEFT_ARM );
                break;
            case HIT_LOCATION_RIGHT_ARM:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_RIGHT_ARM );
                break;
            case HIT_LOCATION_GROIN:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_GROIN );
                break;
            case HIT_LOCATION_RIGHT_LEG:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_RIGHT_LEG );
                break;
            case HIT_LOCATION_LEFT_LEG:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_LEFT_LEG );
                break;
            default:
                break;
            }
        }
    }

    bool isAimed = ( proccess.Aim != HIT_LOCATION_NONE ) && ( proccess.Aim != HIT_LOCATION_TORSO ) && ( proccess.Aim != HIT_LOCATION_UNCALLED );

    uint mainMsg = CMSG_HIT,
         length = 3;

    if( isCritical )
    {
        mainMsg += 2;
        length += 2;
    }
    if( isDead )
    {
        mainMsg += 4;
        if( isCritical )
            length -= 1;
    }
    if( isAimed )
    {
        mainMsg += 1;
        length += 1;
    }

    uint[] sendEff( length );
    sendEff[ 0 ] = mainMsg;
    sendEff[ 1 ] = target.Id;
    uint now = 2;

    if( isAimed )
    {
        sendEff[ 2 ] = proccess.Aim;
        now++;
    }

    sendEff[ now ] = totalDmg;
    now++;

    if( isCritical )
    {
        if( !isDead )
        {
            sendEff[ now ] = msgEff;
            now++;
        }

        sendEff[ now ] = extraMessage;
    }

    Critter@[] crits;

    for( uint i = 0, iMax = target.GetCritters( true, FIND_ALL | FIND_ONLY_PLAYERS, crits ); i < iMax; i++ )
        if( crits[ i ].Id != target.Id )
            AddEff( crits[ i ], sendEff, results );

    if( isCritical )
        sendEff[ now ] = extraMessage + 1500;            // men_player - men_npc

    AddEff( target, sendEff, results );

    // poisoning and irradiating:
    if( validEngineObject( proccess.Attacker ) )
    {
        int poison = ( proccess.IsWeaponPerk( WEAPON_PERK_TOXIC ) ) ? 50 : proccess.Attacker.Stat[ ST_TOXIC ],
            radiation = proccess.Attacker.Stat[ ST_RADIOACTIVE ];

        if( proccess.AmmoPid == PID_50_CAL || proccess.AmmoPid == PID_HN_AP_NEEDLER_CARTRIDGE )
            radiation += rounds * 50;

        if( poison != 0 || radiation != 0 )
        {
            if( Random( 2, 16 ) > target.Stat[ ST_LUCK ] )
            {
                if( poison > 0 )
                    AffectPoison( target, Random( poison / 3, poison ) );
                if( radiation > 0 )
                    AffectRadiation( target, Random( radiation / 3, radiation ) );
            }
        }

        if( proccess.Attacker.Stat[ ST_BODY_TYPE ] == BT_CENTAUR && Random( 2, 16 ) > target.Stat[ ST_LUCK ] )
            AffectRadiation( target, Random( 10, 20 ) );
    }

    if( proccess.ArmorTarget !is null && target.Stat[ ST_CURRENT_ARMOR_PERK ] == ARMOR_PERK_TESLA && ( proccess.TypeDamage == DAMAGE_ELECTR || proccess.TypeDamage == DAMAGE_LASER || proccess.TypeDamage == DAMAGE_PLASMA ) )
    {
        int cunsumedDmg = proccess.DmgMax - totalDmg;
        if( cunsumedDmg > 0 )
            proccess.ArmorTarget.Charge = CLAMP( proccess.ArmorTarget.Charge + cunsumedDmg, 0, 100 );
    }
}

void CriticalFailure( Critter& attacker, ProtoItem& weapon, uint8 weaponUse, ProtoItem@ ammo, uint eff, CombatRes[]& results )
{

    // 0x00000100 hit self OK
    // 0x00100000 weapon exploded OK

    // 0x00000200 lost rest of ammo OK
    // 0x00000400 fired dud shot OK?
    // 0x00000800 hurt self OK
    // 0x00001000 hit randomly ~OK, TODO
    // 0x00002000 crippled random limb OK
    // 0x00040000 on fire NOT USED NOW, TODO?

    // 0x00200000 weapon destroyed OK
    // 0x00400000 weapon dropped OK
    // 0x00800000 lost next turn OK
    // 0x02000000 knocked down OK


    int  totalDmg = 0;

    bool tookDamage = false,
         wpnIsRemoved = _WeaponRemove( weapon, weaponUse );

    Item@ realWeapon = _CritGetItemHand( attacker );
    Map@  map = attacker.GetMap();

    if( attacker.Mode[ MODE_NO_DROP ] != 0 )
        UNSETFLAG( eff, MF_WEAPON_DROPPED );

    if( FLAG( eff, MF_HIT_SELF ) || FLAG( eff, MF_WEAPON_EXPLODED ) ) // only one bullet because burst weapons do not have the ability
    {
        bool validAmmo = ammo !is null;

        int  dmgType = _WeaponDmgType( weapon, weaponUse ),
             targetDR = attacker.Stat[ ST_NORMAL_RESIST + dmgType - 1 ],
             targetDT = attacker.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ],
             dmgMin = _WeaponDmgMin( weapon, weaponUse ),
             dmgMax = _WeaponDmgMax( weapon, weaponUse ),
             dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1, // technically, should be *2
             dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;  // technically, should be *2

        if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
            targetDT /= 5;
        targetDR += ( ( attacker.Trait[ TRAIT_FINESSE ] != 0 ) ? 30 : 0 );
        if( attacker.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
            totalDmg += Random( 10, 30 );
        if( validAmmo )
            targetDR += ammo.Ammo_DrMod;
        targetDR = CLAMP( targetDR, 0, 100 );

        totalDmg = Random( dmgMin, dmgMax ) + 2 * attacker.Perk[ PE_BONUS_RANGED_DAMAGE ];
        totalDmg *= dmgMul;
        if( dmgDiv != 0 )
            totalDmg /= dmgDiv;
        totalDmg -= targetDT;
        totalDmg -= ( totalDmg * targetDR ) * 0.01;
        if( totalDmg < 0 )
            totalDmg = 0;
        if( attacker.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( attacker.Stat[ ST_BODY_TYPE ] == BT_ALIEN || attacker.Stat[ ST_BODY_TYPE ] == BT_ROBOT ) )
            totalDmg += Random( 10, 20 );
        if( attacker.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
            totalDmg += Random( 10, 30 );
        totalDmg -= ( totalDmg * attacker.Perk[ PE_TOUGHNESS ] * 5 ) * 0.01;
        tookDamage = true;
    }

    uint16 ammoRound = _WeaponRound( weapon, weaponUse );
    if( ammoRound > 0 && validEngineObject( realWeapon ) && attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
    {
        if( realWeapon.AmmoCount <= ammoRound || FLAG( eff, MF_LOST_REST_OF_AMMO ) )
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
    }

    if( attacker.Mode[ MODE_NO_DROP ] != 0 )
        UNSETFLAG( eff, MF_WEAPON_DROPPED );

    if( FLAG( eff, MF_WEAPON_DROPPED ) && validEngineObject( realWeapon ) )
    {
        if( FLAG( realWeapon.Flags, ITEM_GAG ) )
        {
            DeleteItem( realWeapon );
        }
        else
        {
            MoveItem( realWeapon, 0, map, attacker.HexX, attacker.HexY );
            realWeapon.EventDrop( attacker );
            if( attacker.IsNpc() )
            {
                NpcPlane@ plane = CreatePlane();

                NpcPlane@[] crPlanes( 0 );

                if( attacker.GetPlanes( crPlanes ) > 0 )
                    plane.Priority = crPlanes[ 0 ].Priority + 1;
                else
                    plane.Priority = 70;

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = realWeapon.HexX;
                plane.Pick_HexY = realWeapon.HexY;
                plane.Pick_Pid = realWeapon.GetProtoId();
                plane.Pick_UseItemId = 0;
                plane.Pick_ToOpen = false;
                plane.Run = true;
                attacker.AddPlane( plane );
            }
        }
    }

    if( ( FLAG( eff, MF_WEAPON_DESTROYED ) || FLAG( eff, MF_WEAPON_EXPLODED ) ) && validEngineObject( realWeapon ) )
    {
        if( realWeapon.GetCount() > 1 )
            realWeapon.SetCount( realWeapon.GetCount() - 1 );
        else
        {
            DeleteItem( realWeapon );
        }
    }

    if( FLAG( eff, MF_HURT_SELF ) )
    {
        totalDmg += Random( 1, 5 );
        tookDamage = true;
    }

    if( FLAG( eff, MF_LOST_NEXT_TURN ) )
    {
        attacker.StatBase[ ST_CURRENT_AP ] = -100 * attacker.Perk[ PE_QUICK_RECOVERY ] != 0 ? attacker.Stat[ ST_ACTION_POINTS ] * 0.5 : attacker.Stat[ ST_ACTION_POINTS ];
        attacker.StatBase[ ST_MOVE_AP ] = 0;
    }

    if( FLAG( eff, MF_KNOCKED_DOWN ) && !attacker.IsKnockout() )
        attacker.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), attacker.Perk[ PE_QUICK_RECOVERY ] != 0 ? 1 : 3, attacker.HexX, attacker.HexY );

    if( FLAG( eff, MF_CRIPPLED_RANDOM_LIMB ) && attacker.Mode[ MODE_NO_LOOSE_LIMBS ] == 0 )
    {
        switch( Random( 1, 4 ) )
        {
        case 1:
            attacker.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
            break;
        case 2:
            attacker.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
            break;
        case 3:
            attacker.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
            break;
        case 4:
            attacker.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
            break;
        default:
            break;
        }
    }

    if( totalDmg > 0 )
        attacker.StatBase[ ST_CURRENT_HP ] -= totalDmg;

    uint[] allEff = { CMSG_CRIT_MISS, attacker.Id, eff };

    if( tookDamage )
    {
        allEff.resize( 4 );
        allEff[ 3 ] = totalDmg;
        allEff[ 0 ] = CMSG_CRIT_MISS_DAMAGE;
    }

    if( attacker.Stat[ ST_CURRENT_HP ] < 1 )
    {
        if( attacker.Stat[ ST_CURRENT_HP ] > __DeadHitPoints && attacker.Mode[ MODE_NO_KNOCK ] == 0 )
        {
            if( !attacker.IsKnockout() )
                attacker.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 0, attacker.HexX, attacker.HexY );
        }
        else
        {
            uint anim2Dead = ANIM2_DEAD_FRONT;
            if( attacker.IsKnockout() )
            {
                if( attacker.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT )
                    anim2Dead = ANIM2_DEAD_PRONE_FRONT;
                else
                    anim2Dead = ANIM2_DEAD_PRONE_BACK;
            }
            attacker.ToDead( anim2Dead, null );
            allEff[ 2 ] |= MF_WAS_KILLED;
        }
    }

    Critter@[] him = { @attacker },
    crits;
    for( int i = 0, iMax = map.GetCrittersSeeing( him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits ); i < iMax; i++ )
        AddEff( crits[ i ], allEff, results );

    FlushResults( results );
}

void InjureCritter( Critter& critter, uint damage, uint damageType, uint8 dir, uint attackerId, CombatProccess& combat ) // Export
{
    if( damageType > DAMAGE_EXPLODE )
        return;

    CombatRes[] results;
    ApplyDamage( combat, critter, 1, false, true, results );

    FlushResults( results );
}

void InjureCritter( Critter& critter, uint damage, uint damageType, uint8 dir, uint attackerId ) // Export
{
    if( damageType > DAMAGE_EXPLODE )
        return;

    Critter@ attacker = null;
    if( attackerId != 0 && critter.Id != attackerId )
        @attacker = GetCritter( attackerId );
    CombatProccess@ proccess = CombatProccess();
    @proccess.Attacker = attacker;

    uint16 hx = critter.HexX,
           hy = critter.HexY;
    Map@   map = critter.GetMap();
    if( validEngineObject( map ) )
        map.MoveHexByDir( hx, hy, ( dir + 3 ) % 6, 1 );

    proccess.Hx = hx;
    proccess.Hy = hy;
    proccess.Aim = HIT_LOCATION_UNCALLED;
    proccess.IsBurst = false;
    proccess.BloodyMess = false;
    proccess.CombatMessage = false;
    proccess.WeaponSubtype = 0;
    proccess.DmgMin = damage;
    proccess.DmgMax = damage;
    proccess.TypeDamage = damageType;
    proccess.BonusDmg = 0;
    proccess.DmgMul = 1;
    proccess.DRMod = 0;
    proccess.DMMod = 1;
    proccess.DDMod = 1;
    proccess.TargetId = critter.Id;
    proccess.ShowHitAnimForce = true;

    CombatRes[] results;
    ApplyDamage( proccess, critter, 1, false, true, results );

    FlushResults( results );
}

void InjureCritter( Critter& critter, uint damage, uint damageType, uint8 dir, uint attackerId, uint forceFlags ) // Export
{
    if( damageType > DAMAGE_EXPLODE )
        return;

    Critter@ attacker = null;
    if( attackerId != 0 && critter.Id != attackerId )
        @attacker = GetCritter( attackerId );

    CombatProccess@ proccess = CombatProccess();
    @proccess.Attacker = attacker;

    uint16 hx = critter.HexX,
           hy = critter.HexY;
    Map@   map = critter.GetMap();
    if( validEngineObject( map ) )
        map.MoveHexByDir( hx, hy, ( dir + 3 ) % 6, 1 );

    proccess.Hx = hx;
    proccess.Hy = hy;
    proccess.Aim = HIT_LOCATION_UNCALLED;
    proccess.IsBurst = false;
    proccess.BloodyMess = false;
    proccess.CombatMessage = false;
    proccess.WeaponSubtype = 0;
    proccess.DmgMin = damage;
    proccess.DmgMax = damage;
    proccess.TypeDamage = damageType;
    proccess.BonusDmg = 0;
    proccess.DmgMul = 1;
    proccess.DRMod = 0;
    proccess.DMMod = 1;
    proccess.DDMod = 1;
    proccess.TargetId = critter.Id;
    proccess.ForceFlags = forceFlags;
    proccess.ShowHitAnimForce = true;

    CombatRes[] results;
    ApplyDamage( proccess, critter, 1, false, true, results );

    FlushResults( results );
}

int FindCritterInArray( Critter@[]& crits, Critter& critter )
{
    uint crId = critter.Id;
    for( uint i = 0, iMax = crits.length(); i < iMax; i++ )
        if( crits[ i ].Id == crId )
            return i;
    return -1;
}

// client only, possible use by AI
int RawToHit( Critter& critter, Critter& target, ProtoItem@ weapon, uint8 weaponMode, ProtoItem@ ammo )
{
	return ToHitMutual( critter.GetMap(), critter, target, null, weapon, ammo, weaponMode, target.HexX, target.HexY );
}

Critter@ ChooseRandomTarget( Map& map, Critter& critter, Critter& target, uint weaponMaxDist )
{
    Critter@[] critters;
    uint16 hx = critter.HexX,
           hy = critter.HexY,
           bx = 0,
           by = 0,
           pbx = 0,
           pby = 0;
    uint n = map.GetCrittersHex( hx, hy, weaponMaxDist, FIND_LIFE_AND_KO, critters );
    if( n == 0 )
        return null;    // should never happen
    uint start = Random( 0, n - 1 );
    Critter@ resultCritter = null;
    for( uint i = start; i < n; i++ )
    {
        @resultCritter = critters[ i ];
        if( resultCritter.Id == critter.Id || resultCritter.Id == target.Id )
            continue;
        // wallcheck:
        map.GetCrittersPath( hx, hy, resultCritter.HexX, resultCritter.HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by );
        if( bx == resultCritter.HexX && by == resultCritter.HexY )
            return resultCritter;
    }
    for( uint i = 0; i < start; i++ )
    {
        @resultCritter = critters[ i ];
        if( resultCritter.Id == critter.Id || resultCritter.Id == target.Id )
            continue;
        // wallcheck:
        map.GetCrittersPath( hx, hy, resultCritter.HexX, resultCritter.HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by );
        if( bx == resultCritter.HexX && by == resultCritter.HexY )
            return resultCritter;
    }

    return null;
}

// //////////////////////////////////////////////////////////////////////////////////
// Погексовая атака v.1.1///////////////////////////////////////////////////////////
// ////////////////////////////////////////////////////////////////////////////////
/*ВНИМАНИЕ, НПЦ НЕ МОГУТ АТАКОВАТЬ ПОГЕКСОВО.*/
// ///////////////////////////////////////////////////////////////////////////////////
// Имитация сетки стрельбы.

bool Zone_Attack( Critter& critter, uint16 hexX, uint16 hexY, int slot = SLOT_HAND1 )
{
    Map@ map = critter.GetMap();
    if( !validEngineObject( map ) )
        return false;
	
	Item@ item = critter.GetItem( 0, slot );
    if( !validEngineObject( item ) )
        return false;
    ProtoItem@ proto = GetProtoItem( item.GetProtoId() );
	uint8 use = _WeaponModeUse( item.Mode );
    if( proto is null )
        return false;
    
	bool isDoor = map.GetDoor( hexX, hexY ) !is null;
    uint len = GetDistantion( critter.HexX, critter.HexY, hexX, hexY );
    if( map.IsHexRaked( hexX, hexY ) != true && !isDoor )
        return false; // Гекс непростреливаемый, в него нельзя выстрелить. Выходим из функции.
    bool IsThrowing = ( _WeaponSkill( proto, use ) == SK_THROWING );
    int  WMaxDist = _WeaponMaxDist( proto, use );
    uint dist = ( _WeaponSkill( proto, use ) == SK_THROWING ) ? 
					( MIN( WMaxDist, 3 * MIN( int(10), ( critter.Stat[ ST_STRENGTH ] + 2 * critter.Perk[ PE_HEAVE_HO ] ) ) ) ) : 
						WMaxDist;
						
    if( uint( critter.Stat[ ST_VISIBLE_DIST ] ) < len || dist < len || len == 0 || dist == 0 )
        return false; // Если точка выстрела дальше чем видит персонаж, и не входит в дистанцию атаки оружия, значит не стреляем.

    if( proto.Weapon_ZoneAttackIgnoreNotRaked )
        return true;

    uint16 XP = hexX, YP = hexY;                      // Координаты гекса по X и Y для записи в него гекса занятости.
    map.GetHexCoord( critter.HexX, critter.HexY, XP, YP, 0, 0 ); // Найдем непростреливаемый гекс на пути выстрела.
	if( len <= GetDistantion( critter.HexX, critter.HexY, XP, YP ) )
		return true;
	return isDoor;
}

bool u_Attack( Critter@ critter, int hexX, int hexY, int slot, CombatProccess@ combatProccess = null )
{
	if( critter is null || critter.IsNotValid )
	{
		Log( "critter is null" );
		return false;
	}
	
	if( !critter.IsFree() || !critter.IsLife() )
        return false;
	
    Item@ item = critter.GetItem( 0, slot );
    if( !validEngineObject( item ) )
        return false;
    if( _ItemIsBroken( item ) )
    {
        if( critter.IsPlayer() )
            critter.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_WEAPON_BROKEN );
        return false;
    }
    uint8 mode = item.Mode,
			use = _WeaponModeUse( mode );
    ProtoItem@ weapon = GetProtoItem( item.GetProtoId() );

    if( FLAG( item.Flags, ITEM_TWO_HANDS ) )
    {
        if( critter.Damage[ DAMAGE_RIGHT_ARM ] != 0 || critter.Damage[ DAMAGE_LEFT_ARM ] != 0 )
        {
            if( critter.IsPlayer() )
                critter.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_DMG_ARM );
            return false;
        }
    }
    else
    {
        if( critter.Damage[ DAMAGE_RIGHT_ARM ] != 0 && critter.Damage[ DAMAGE_LEFT_ARM ] != 0 )
        {
            if( critter.IsPlayer() )
                critter.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_DMG_TWO_ARMS );
            return false;
        }
    }
	
	uint16 ammoRound = _WeaponRound( weapon, use );
    bool isBurst = ( ammoRound > 1 && _WeaponNoBrust( weapon, use ) == 0 );
	
    if( !_WeaponeIsPerk( weapon, GetProtoItem( item.AmmoPid ), WEAPON_PERK_HEX_ATTACKING ) && !isBurst )
        return false;

    if( !Zone_Attack( critter, hexX, hexY, slot ) )
        return false;

    int skillNum = _WeaponSkill( weapon, use );
    uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );
    uint16 apCost = MAX( 1, ( ( _WeaponApCost( weapon, use ) - item.WeaponBonus_AP - critter.Perk[ PE_BONUS_RATE_OF_FIRE ] ) - ( weaponSubtype == WS_GUN ? critter.Trait[ TRAIT_FAST_SHOT ] : 0 ) ) );
    if( !critter.IsAnim1( weapon.Weapon_Anim1 ) || critter.Stat[ ST_CURRENT_AP ] < apCost )
        return false;

    if( Attack( critter, item, mode, hexX, hexY, slot, combatProccess ) )
    {
		// __Breaktime
		uint breaktime = _WeaponBreakAttack( weapon, use );
		if( breaktime == 0 ) breaktime = __Breaktime;
        critter.StatBase[ ST_CURRENT_AP ] -= apCost * 100;         // Отнимает очки действия.
        critter.Wait( breaktime );
        return true;
    }
    return false;
}

void unsafe_Attack( Critter& critter, int hexX, int hexY, int slot, string@, int[] @ )
{
    u_Attack( critter, hexX, hexY, slot );
}

bool Attack( Critter& critter, Item& item, uint8 weaponMode, uint16 defHexX, uint16 defHexY, int slot, CombatProccess@ combatProccess = null ) // ToDo переделать под нпц
{
	Combat@ proccess = cast<Combat@>(@combatProccess);
	if( proccess is null ) @proccess = Combat( critter, defHexX, defHexY, GetProtoItem( item.GetProtoId() ), weaponMode, GetProtoItem( item.AmmoPid ), slot );
	else proccess.Prepare( critter, null, defHexX, defHexY, GetProtoItem( item.GetProtoId() ), weaponMode, GetProtoItem( item.AmmoPid ), slot );
    return CombatAttack( proccess );
}

void DamageHex( CombatProccess& proccess, Map& map, uint16 radius, bool _quakeScreen, uint[]@ target_ids = null )
{
    if( _quakeScreen )
        QuakeScreen( map );

    proccess.Attacker.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( proccess.Attacker );

    Critter@[] critters;
    Critter@ c = null;
    int skillNum = _WeaponSkill( proccess.RealWeapon.Proto, _WeaponModeUse( proccess.RealWeapon.Mode ) );
    {
        int  criticalChanceDef = 0;
        {
            int aAim = proccess.Aim;
            if( aAim == HIT_LOCATION_UNCALLED || aAim == HIT_LOCATION_NONE || aAim == HIT_LOCATION_TORSO )
                criticalChanceDef = proccess.Attacker.Stat[ ST_CRITICAL_CHANCE ] + ( proccess.Attacker.Trait[ TRAIT_FINESSE ] != 0 ? 10 : 0 ) + proccess.Attacker.Perk[ PE_MORE_CRITICALS ] * 5;
            if( proccess.RealWeapon !is null )
            {
                criticalChanceDef += proccess.RealWeapon.WeaponBonus_CritChance + proccess.RealWeapon.Proto.Weapon_CriticalBonus;
                switch( skillNum )
                {
                case SK_SMALL_GUNS:
                case SK_BIG_GUNS:
                case SK_ENERGY_WEAPONS:
                    criticalChanceDef += proccess.Attacker.BookBonus[ BB_RANGED_CRIT ];
                    break;                                                                                              // бонус от книг. ++Cracker
                case SK_UNARMED:
                case SK_THROWING:
                    criticalChanceDef += proccess.Attacker.BookBonus[ BB_MELEE_AND_THROWING_CRIT ];
                    break;                                                                                                     // бонус от книг. ++Cracker
                default:
                    break;
                }
            }
        }
        bool   isCritical = false;
        if( proccess.RealWeapon !is null && proccess.WeaponPid == PID_JACKAL && proccess.RealWeapon.AmmoPid == PID_JACKAL_WALKING_MINE )
        {
            map.GetHexCoord( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0, 0 );
            int[] params = { SK_TRAPS, proccess.Attacker.Skill[ SK_TRAPS ], MODE_HIDE, 1, SK_SNEAK, proccess.Attacker.Skill[ SK_TRAPS ], MERC_MASTER_ID, proccess.Attacker.Id, ST_FACTION, proccess.Attacker.Stat[ ST_FACTION ] };
            Critter@ npc = map.AddNpc( NPC_WALKING_MINE, proccess.TargetHx, proccess.TargetHy, 0, params, null, "walking_mine@_WalkingMineInit" );
            if( npc !is null )
                CreateTimeEvent( __FullSecond + REAL_SECOND( 90 ), "combat@e_EventDead", npc.Id, false );
            return;
        }
        uint iMax = map.GetCrittersHex( proccess.TargetHx, proccess.TargetHy, MAX( 0, int(radius - 1) ), FIND_LIFE_AND_KO, critters );
        for( uint i = 0; i < iMax; i++ )
        {
            @ c = critters[ i ];
            if( c !is null )
            {
				if( target_ids !is null )
				{
					if( target_ids.find( c.Id ) == -1 )
						target_ids.insertLast( c.Id );
					else continue;
				}
				
                uint16 traceHexX = c.HexX,                                                                              // TabaK. Фикс пробивания стен взрывом.
                       traceHexY = c.HexY;
                map.GetHexCoord( proccess.TargetHx, proccess.TargetHy, traceHexX, traceHexY, 0, 0 );
                if( traceHexX != c.HexX || traceHexY != c.HexY )
                    continue;
                if( proccess.WeaponPid == PID_JACKAL )
                {
                    Item@ mine = c.AddItem( PID_JACKAL_MINE_ACTIVE, 1 );
                    if( mine !is null )
                    {
                        mine.LockerId = proccess.RealWeapon.Id;
                        mine.Val2 = proccess.Attacker.Id;
                        mine.Val3 = proccess.Attacker.Skill[ skillNum ];
                        c.EventAttacked( proccess.Attacker );
                        c.PlaySound( "FLRTRAP.ACM", c.IsPlayer() );
                        return;
                    }
                }
                else if( proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
                {
                    MoveItem( proccess.RealWeapon, 1, c );
                    c.PlaySound( "FLRTRAP.ACM", c.IsPlayer() );
                }
                if( !( c.IsDead() ) )
                {
                    /*if( ExplodeId == PID_EXPLODE_NUKLEAR )
                    {
                        AffectRadiation( c, Random( 340, 460 ) );
                        proccess.TypeDamage = DAMAGE_FIRE;
                    }*/
                    if( c.IsNpc() || c.GetAccess() != ACCESS_ADMIN )
                        c.ModeBase[ MODE_HIDE ] = 0;
                    c.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( c );
                    isCritical = ( Random( 1, 100 ) <= criticalChanceDef );
                    int antiCriticalRes = criticalChanceDef > 100 ? criticalChanceDef - 100 : 0;
                    if( isCritical && Random( 1, 100 ) <= ( c.Stat[ ST_CRITICAL_RESISTANCE ] - antiCriticalRes ) )
                        isCritical = false;

					EventSmthAttack( proccess.Attacker, c );
                    CombatRes[] results;
                    critter_attack( proccess.Attacker, c );
                    ApplyDamage( proccess, c, 1, isCritical, true, results );
                    FlushResults( results );
                }
            }
        }
        if( iMax == 0 )
        {
            if( proccess.WeaponPid == PID_JACKAL || proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
            {
                if( !map.IsHexPassed( proccess.TargetHx, proccess.TargetHy ) )
                    map.GetHexCoord( proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, 0, proccess.Distantion );
                Item@ mine = map.GetItem( proccess.TargetHx, proccess.TargetHy, PID_JACKAL_MINE_ACTIVE );
                if( mine !is null )
                {
                    uint duration = 0;
                    uint[] values;
                    if( GetTimeEvent( mine.Val1, duration, values ) )
                    {
                        SetTimeEvent( mine.Val1, 0, values );
                    }
                    else
                        CreateTimeEvent( __FullSecond, "explode@e_Explode", mine.Id, false );
                    if( proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
					{
                        DeleteItem( proccess.RealWeapon );
						@proccess.RealWeapon = null;
                    }
					return;
                }
                else if( proccess.WeaponPid == PID_JACKAL_MINE_ACTIVE )
                {
                    MoveItem( proccess.RealWeapon, 1, map, proccess.TargetHx, proccess.TargetHy );
                    proccess.RealWeapon.EventDrop( proccess.Attacker );
                    return;
                }
                @mine = map.AddItem( proccess.TargetHx, proccess.TargetHy, PID_JACKAL_MINE_ACTIVE, 1 );
                if( mine !is null )
                {
                    mine.LockerId = proccess.RealWeapon.Id;
                    mine.Val2 = proccess.Attacker.Id;
                    mine.Val3 = proccess.Attacker.Skill[ skillNum ];
                    return;
                }
            }
        }

        /*if( ExplodeId == PID_EXPLODE_NUKLEAR )
        {
            critters.resize( 0 );
            for( uint i = 0, iMax = map.GetCritters( 0, FIND_LIFE_AND_KO, @critters ); i < iMax; i++ )
                AffectRadiation( critters[ i ], Random( 230, 340 ) );
        }*/
    }

    Item@[] items = GetItems( map, proccess.TargetHx, proccess.TargetHy, radius );

    Item@ it = null;
    for( uint i = 0, iMax = items.length(); i < iMax; i++ )
    {
        @ it = items[ i ];
        if( it !is null )
            ItemDamage( it, Random( proccess.DmgMin, proccess.DmgMax ) );
    }
}

Item@[] GetItems( Map& map, uint16 hexX, uint16 hexY, uint radius )
{
    Item@[] items;
    {
        uint16 yMax = hexY + radius,
               yMin = hexY - radius,

               xMax = hexX + radius,
               xMin = hexX - radius,

               MapWidth = map.GetWidth(),
               MapHeight = map.GetHeight();

        if( MapWidth < xMax )
            xMax = MapWidth;
        if( xMin < 0 )
            xMin = 0;
        if( MapHeight < yMax )
            yMax = MapHeight;
        if( yMin < 0 )
            yMin = 0;
		
		uint16 hy = 0,
		         hx = 0;
		
        for( hx = xMin; hx < xMax; hx++ )
            for( hy = yMin; hy < yMax; hy++ )
                map.GetItems( hx, hy, @items );
    }
    return items;
}

void ItemDamage( Item& it, uint TotalDamag )
{
    uint16 x = 0, y = 0, itPid = it.GetProtoId();
    Map@   map = it.GetMapPosition( x, y );
    bool   bVar = false;
    uint   heal = 0;

    switch( itPid )
    {
    // Мешки
    case PID_SANDBAG_1:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_2:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 2 );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_3:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 3 );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_4:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 4 );
            heal = it.CurrentHp;
        }
    }

    case PID_SANDBAG_5:
    {
        if( heal == 0 )
        {
            if( it.CurrentHp == 0 )
                it.CurrentHp = uint( HP_SANDBAD * 5 );
            heal = it.CurrentHp;
        }

        if( TotalDamag >= heal )
        {
            DeleteItem( it );
        }
        else
        {
            heal -= TotalDamag;
            if( heal <= 100 )
            {
                if( !ChangeProto( it, PID_SANDBAG_1 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            else if( heal <= 200 )
            {
                if( !ChangeProto( it, PID_SANDBAG_2 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            else if( heal <= 300 )
            {
                if( !ChangeProto( it, PID_SANDBAG_3 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            else if( heal <= 400 )
            {
                if( !ChangeProto( it, PID_SANDBAG_4 ) )
                    Log( "Damage SandBag ChangeProto() failed. ErrText=" + GetLastError() );
                it.Flags = it.Proto.Flags;
                SETFLAG( it.Flags, ITEM_GAG );
            }
            it.CurrentHp = uint( heal );
        }
    }       break;

    // PID_ACTIVE_MINE
    // 40% что погексовка ущерба не принесёт
    // 30% что мин просто будет уничтожен, без детонации
    // 30% что мин сдетонирует.
    case PID_ACTIVE_MINE:
    {
        uint chance = Random( 1, 100 );
        if( chance >= 70 )
        {
            DeleteItem( it );
        }
        else if( chance >= 40 )
        {
            CreateTimeEvent( __FullSecond, "explode@e_Explode", it.Id, false );
        }
    } break;
    // Пластид.
    // 65% что погексовка ущерба не принесёт
    // 20% что пластид просто будет уничтожен, без детонации
    // 15% что пластид сдетонирует.
    case PID_ACTIVE_PLASTIC_EXPLOSIVE:
    {
        uint chance = Random( 1, 100 );
        if( chance >= 80 )
        {
            DeleteItem( it );
        }
        else if( chance >= 65 )
        {
            Critter@ c = null;
            uint     ownerId = it.Val2;
            int      bD = it.Val3;
            int      bR = it.Val4;
            Explode( map, x, y, c, itPid, ownerId, bD, bR );
            DeleteItem( it );
        }
    } break;

    default:
        break;
    }

    if( it.GetType() == ITEM_TYPE_DOOR )
    {
        if( it.GetScriptId() != 0 ||
            ( ( it.LockerCondition ) & ( LOCKER_NOOPEN | LOCKER_ELECTRO | LOCKER_NOUSE ) ) != 0 ||
            it.LockerComplexity > 299 )
            return;
        if( it.CurrentHp == 0 )
            it.CurrentHp = uint( HP_DOOR );
        heal = it.CurrentHp;
        TotalDamag = ( TotalDamag - ( TotalDamag * it.Proto.Material ) / 10 );
        if( TotalDamag >= heal )
        {
            uint[] values = { map.Id, x, y, it.GetProtoId(), it.LockerComplexity };
            it.LockerOpen();
            DeleteItem( it );
            CreateTimeEvent( __FullSecond + TIMEOUT_RESTORE_DOOR, "combat_e_RestoreDoor", values, true );
        }
        else
        {
            heal -= TotalDamag;
            it.CurrentHp = uint( heal );
        }
    }
}

bool ChangeProto( Item& item, uint pid )
{
	if( @GetProtoItem( pid ) is null )
	{
		Log( "Невалиден прототип предмета под пидом: " + pid );
		return false;
	}
	
	return item.ChangeProto( pid );
}

uint e_ReAtack( uint[] @ values )
{
    Map@     map = GetMap( values[ 1 ] );
    Critter@ critter = GetCritter( values[ 2 ] );
    Item@    item = GetItem( values[ 3 ] );
    if( item is null || critter is null || map is null )
        return 0;

    uint16           ammoPid = item.AmmoPid;

    ProtoItem@ weapon = GetProtoItem( item.GetProtoId() ),
                     ammo = GetProtoItem( ammoPid );
    if( weapon is null )
        return 0;
    int weaponPerkFirst = weapon.Weapon_Perk,
        weaponPerkSecond = weapon.Weapon_SecondPerk,
        ammoPerk = ammo !is null ? ammo.Ammo_Perk : 0;
    if( !isWeaponPerk( WEAPON_PERK_HEX_ATTACKING ) )
        return 0;

    int skillNum = _WeaponSkill( weapon, item.Mode ),
        dmgType = _WeaponDmgType( weapon, item.Mode );

    uint8 aim = _WeaponModeAim( item.Mode ),
          weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : WS_UNARMED );

    bool isHthAttack = ( weaponSubtype == WS_UNARMED ),
         isGrenade = weaponSubtype == WS_THROWING && dmgType != DAMAGE_NORMAL;

    CombatProccess@ proccess = CombatProccess();
    proccess.WeaponPid = weapon.ProtoId;
    @proccess.Attacker = critter;
    @proccess.RealWeapon = item;
    proccess.Hx = critter.HexX;
    proccess.Hy = critter.HexY;
    proccess.TargetHx = values[ 4 ];
    proccess.TargetHy = values[ 5 ];
    proccess.Aim = aim;
    proccess.IsBurst = false;
    proccess.BloodyMess = critter.Trait[ TRAIT_BLOODY_MESS ] != 0;
    proccess.CombatMessage = true;
    proccess.ScoreUnarmed = ( weaponSubtype == WS_UNARMED );
    proccess.WeaponSubtype = weaponSubtype;
    proccess.DmgMin = _WeaponDmgMin( weapon, item.Mode );
    proccess.DmgMax = _WeaponDmgMax( weapon, item.Mode );
    proccess.DmgMin += item.WeaponBonus_MinDamage;
    proccess.DmgMax += item.WeaponBonus_MaxDamage;
    proccess.TypeDamage = dmgType;
    proccess.BonusDmg = 0;

    if( isHthAttack || ( weaponSubtype == WS_THROWING && !isGrenade ) )
    {
        proccess.DmgMax += proccess.Attacker.Stat[ ST_MELEE_DAMAGE ];
        proccess.DmgMin += proccess.Attacker.Stat[ ST_MELEE_DAMAGE ];
    }
    if( weaponSubtype == WS_GUN )
        proccess.BonusDmg += proccess.Attacker.Perk[ PE_BONUS_RANGED_DAMAGE ] * 2;
    // Ammo
    if( ammo !is null )
    {
        proccess.DRMod = ammo.Ammo_DrMod;
        proccess.DMMod = ammo.Ammo_DmgMult;
        proccess.DDMod = ammo.Ammo_DmgDiv;
        proccess.TDMod = ammo.Ammo_DTDiv;
    }
    proccess.DmgMul = proccess.DMMod;

    bool   _quakeScreen = values[ 9 ] == 1;
    if( weapon.ProtoId == PID_JACKAL )
    {
        uint8 dir = values[ 0 ] == 2 ? ( proccess.Attacker.Dir + 2 ) % 6 : ( proccess.Attacker.Dir + 4 ) % 6;
        map.MoveHexByDir( proccess.TargetHx, proccess.TargetHy, dir, 2 );
    }
    else
    {
        proccess.TargetHx += Random( -1, 1 );
        proccess.TargetHy += Random( -1, 1 );
    }

    if( ammoPid != PID_NUKE_ROCKET )
        map.RunFlyEffect( _WeaponEffect( GetProtoItem( item.GetProtoId() ), item.Mode ), null, null, proccess.Hx, proccess.Hy, proccess.TargetHx, proccess.TargetHy, values[ 8 ] | values[ 6 ] << 16 );                           // Запускаем летящий снаряд.

    DamageHex( proccess, map, values[ 6 ], _quakeScreen );

    if( values[ 0 ] > 1 )
    {
        if( ammoPid == PID_NUKE_ROCKET )
        {
            values[ 6 ] += 1;
        }

        uint[] newValues = { values[ 0 ] - 1, values[ 1 ], values[ 2 ], values[ 3 ], values[ 4 ], values[ 5 ], values[ 6 ], values[ 7 ], ( values[ 8 ] > 0 ? values[ 8 ] : 0 ), _quakeScreen ? 1 : 0 };
        CreateTimeEvent( __FullSecond + ATACK_WAIT_TIME / 2, "combat@e_ReAtack", newValues, false );
    }
    return 0;
}

MaintainAttack@ GetMaintainAttack( Critter& critter )
{
	if( critter.TimeAttackId != 0 )
	{
		uint duration = 0;
		TimeEventDescriptor@ descriptor = GetTimeEvent( critter.TimeAttackId, duration );
		if( descriptor !is null )
			return cast<MaintainAttack@>(@descriptor);
	}
	return null;
}

void StopMaintainAttack( Critter& critter )
{
	MaintainAttack@ maintain = GetMaintainAttack( critter );
	if( maintain is null )
		return;
	maintain.Stopped();
}

class MaintainAttack : iCombatProccessContext, TimeEventDescriptor
{
	CombatProccess@ proccess;
	Map@ map;
	uint16 targetX;
	uint16 targetY;
	uint EventId;
	uint Delay;
	BurstStage stage;
	bool IsStopped;
	
	MaintainAttack()
	{
		Clear();
	}
	
	void Clear()
	{
		@proccess = null;
		@map = null;
		stage.current = 0;
		stage.maxrounds = 0;
		stage.progression = 0;
		stage.max = 0;
		targetX = 0;
		targetY = 0;
		Delay = 0;
		EventId = 0;
		IsStopped = false;
	}
	
	uint get_WeaponRound()
	{
		return _WeaponRound( proccess.Weapon, proccess.WeaponUse );
	}
	
	uint GetAmmoRound( )
	{
		if( stage.max == stage.current )
			return WeaponRound;
		if( stage.current == 0 )
			return 1;
		
		return stage.currentRound;
	}
	
	void Stopped()
	{
		IsStopped = true;
	}
	
	void Continue()
	{
		IsStopped = false;
		UpdateDelay();
		if( proccess.Attacker.TimeAttackId != EventId || EventId == 0 )
		{
			EventId = CreateTimeEvent( __FullSecond + Delay, e_FullReplayAtack, this );
			proccess.Attacker.TimeAttackId = EventId;
		}
	}
	
	bool Check()
	{
		if( !validEngineObject( proccess.Attacker ) || !proccess.Attacker.IsLife() )
			return false;
		if( @proccess.RealWeapon is null )
			return false;
		if( map is null || proccess.Attacker.GetMap() is null )
			return false;
		if( proccess.Attacker.GetMap() !is map )
			return false;
		if( proccess.RealWeapon.Accessory != ACCESSORY_CRITTER )
			return false;
		if( proccess.RealWeapon.CritId != proccess.Attacker.Id )
			return false;
		if( proccess.RealWeapon.CritSlot != SLOT_HAND1  )
			return false;	
		return true;
	}
	
	bool CheckPosition()
	{
		if( proccess.Map !is map )
			return false;
		if( proccess.Attacker.HexX != proccess.Hx || proccess.Attacker.HexY != proccess.Hy )
			return false;
		return true;
	}
	
	bool CheckContinue()
	{
		if( !CheckPosition() )
			return false;
		if( proccess.GetResult() != CombatResult::success )
			return false;
		if( IsStopped )
			return false;
		return true;
	}
	
	void Fill( CombatProccess@ combatProccess )
	{
		@proccess = @combatProccess;
		@map = proccess.Map;
		targetX = proccess.TargetHx;
		targetY = proccess.TargetHy;
		@proccess.Context = this;
		
		if( stage.maxrounds == 0 )
		{
			stage.current = 0;
			stage.maxrounds = WeaponRound;
			stage.progression = proccess.Weapon.Weapon_BulletProgression;
			stage.max = stage.maxrounds * stage.progression;
		}
	}
	
	void Send()
	{
		if( proccess.Attacker !is null && proccess.Attacker.IsPlayer() )
			proccess.Attacker.Send( stage, BurstStageDestcriptorId );
	}
	
	void UpdateDelay()
	{
		Delay = REAL_MS( _WeaponTimeAttack( proccess.Weapon, proccess.WeaponUse ) );
	}
	
	void StageRaise()
	{
		if( stage.current < stage.max )
		{
			stage.current++;
			Send();
		}
	}
	
	void StageLose()
	{
		if( stage.current > 0 )
		{
			stage.current--;
			Send();
		}
	}
	
	float GetActionCost( )
	{
		float apCost = MAX( 1, ( ( _WeaponApCost( proccess.Weapon, proccess.WeaponUse ) - proccess.RealWeapon.WeaponBonus_AP - proccess.Attacker.Perk[ PE_BONUS_RATE_OF_FIRE ] ) - ( proccess.WeaponSubtype == WS_GUN ? proccess.Attacker.Trait[ TRAIT_FAST_SHOT ] : 0 ) ) );
		return apCost * 25; 
	}
	
	uint Replay()
	{
		Delay = 0;
		if( proccess.Context !is this )
			return 0;
			
		if( !Check() )
		{
			stage.current = 0;
			Send();
			return 0;
		}
		
		bool success = false;
		if( CheckContinue() )
		{
			float apCost = GetActionCost( );
			if( proccess.Attacker.Stat[ ST_CURRENT_AP ] * 100 >= apCost && Attack( proccess.Attacker, proccess.RealWeapon, proccess.WeaponMode, targetX, targetY, proccess.RealWeapon.CritSlot, proccess ) )
			{
				StageRaise();
				proccess.Attacker.StatBase[ ST_CURRENT_AP ] -= apCost; // Отнимает очки действия.
				success = true;
			}
		}
		
		if( !success )
		{
			StageLose();
			if( stage.current == 0 )
			{
				if( proccess.Attacker.TimeAttackId == EventId )
					proccess.Attacker.TimeAttackId = 0;
				return 0;
			}
			UpdateDelay();
		}
		return Delay;
	}
}

uint e_FullReplayAtack( TimeEventDescriptor@ value )
{
	if( value is null )
		return 0;
	
	MaintainAttack@ context = cast<MaintainAttack@>(@value);
	if( context is null )
		return 0;	

    return context.Replay();
}

uint e_RestoreDoor( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( map is null )
        return 0;
    // if(map.IsHexPassed(values[1], values[2])==false) return __FullSecond+TIMEOUT_RESTORE_DOOR;
    Item@ door = map.GetDoor( values[ 1 ], values[ 2 ] );
    if( door !is null )
        return 0;
    @door = map.AddItem( values[ 1 ], values[ 2 ], values[ 3 ], 1 );
    door.LockerComplexity = values[ 4 ];
    door.LockerOpen();
    door.Update();
    return 0;
}

uint e_EventDead( uint[] @ vals )
{
    Critter@ critter = GetCritter( vals[ 0 ] );
    if( critter !is null )
        critter.EventDead( null );
    return 0;
}

void _SetBattleTimer( Critter& critter, uint index, int oldValue )
{
    if( critter.IsNpc() || critter.TimeoutBase[ index ] == 0 )
    {
        // Log("Timeout set to zero. Critter Id: "+critter.Id);
        critter.StatBase[ ST_BATTLE_DATA ] = 0;
        critter.StatBase[ ST_DAMAGE_RECEIVED ] = 0;
        critter.StatBase[ ST_DAMAGE_DONE ] = 0;
        return;
    }

    if( critter.Stat[ ST_BATTLE_DATA ] != 0 )
    {
        uint duration = 0;
        uint[] vals;
        if( GetTimeEvent( uint( critter.Stat[ ST_BATTLE_DATA ] ), duration, vals ) )
        {
            // Log("TimeEvent already found. Critter: "+critter.Id);
            if( vals.length() < 3 )
            {
                Log( "Warning! Battle stats fucked up! Data length: " + vals.length() );
                for( uint n = 0; n < vals.length(); n++ )
                    Log( "vals[" + n + "] = " + vals[ n ] );
                vals.resize( 3 );
                vals[ 0 ] = critter.Id;
                if( vals[ 1 ] == 0 )
                    vals[ 1 ] = __FullSecond;
            }
            vals[ 2 ] = __FullSecond;
            SetTimeEvent( uint( critter.Stat[ ST_BATTLE_DATA ] ), critter.TimeoutBase[ TO_BATTLE ] - __FullSecond, vals );
            return;
        }
    }
    uint[] values = { critter.Id, __FullSecond, __FullSecond };
    critter.StatBase[ ST_DAMAGE_RECEIVED ] = 0;
    critter.StatBase[ ST_DAMAGE_DONE ] = 0;
    critter.StatBase[ ST_BATTLE_DATA ] = int( CreateTimeEvent( critter.TimeoutBase[ index ], "combat@e_BattleStat", values, false ) );
}

uint e_BattleStat( uint[] @ values )
{
    if( @values == null )
    {
        // Log("Values is null!");
        return 0;
    }
    if( values.length() < 3 )
    {
        Log( "Warning! Battle stats fucked up! Data length: " + values.length() );
        for( uint n = 0; n < values.length(); n++ )
            Log( "values[" + n + "] = " + values[ n ] );
        return 0;
    }
    Critter@ critter = GetCritter( values[ 0 ] );
    if( critter is null )
        return 0;
    uint   time = ( values[ 2 ] - values[ 1 ] ) / REAL_SECOND( 1 );
    uint16 dmg = ( critter.Stat[ ST_DAMAGE_DONE ] ) & 0xFFFF,
           kills = ( critter.Stat[ ST_DAMAGE_DONE ] >> 16 ) & 0xFFFF;
    float  dps = float(dmg) / MAX( 1, time );
    dps = ceil( dps * 100 ) / 100; // Округляем до сотых
    critter.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, 800, "$t" + time + "$d" + critter.Stat[ ST_DAMAGE_RECEIVED ] + "$k" + dmg + "$p" + dps + "$c" + kills );
    critter.StatBase[ ST_BATTLE_DATA ] = 0;
    critter.StatBase[ ST_DAMAGE_DONE ] = 0;
    critter.StatBase[ ST_DAMAGE_RECEIVED ] = 0;
    return 0;
}

class CTraceLineIgnoredRaked : ITraceContext
{

    uint8  maxDir = 6;
    uint8  dir = 0;
    uint8  memDir = 0;

    uint16 currentHexX = 0;
    uint16 currentHexY = 0;
    uint16 targHexX = 0;
    uint16 targHexY = 0;
    uint16 memHexX = 0;
    uint16 memHexY = 0;

    uint8[] maxBlockCount;

    uint[]  minDamage;
    uint[]  maxDamage;

    Critter@[] lookCrs;
    uint                 countLookCrs = 0;
    Critter@             target;
    Item@[] items;
    Critter@             critter;
    int                  defDmgMin = 0;
    int                  defDmgMax = 0;

    CombatProccess@ proccess;

    int                  criticalChanceDef = 0;
    bool                 isCritical = false;

    uint[] AllHex;
	
	UpgradeItem::LineDamageData Data;

    CTraceLineIgnoredRaked( CombatProccess & attackArg, Map & map, Critter & critterArg, Item & item, uint16 & in hexX, uint16 & in hexY )
    {
		Data.Effect = PID_BLUE_LASER_EXPLOSION;
		Data.IsFire = false;
		Data.DamageMod = 0.01;
	
        @ critter = critterArg;
        @ proccess = attackArg;
        critter.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( critter );

        defDmgMin = proccess.DmgMin;
        defDmgMax = proccess.DmgMax;

        {
            int aAim = proccess.Aim;
            if( aAim == HIT_LOCATION_UNCALLED || aAim == HIT_LOCATION_NONE || aAim == HIT_LOCATION_TORSO )
                criticalChanceDef = critter.Stat[ ST_CRITICAL_CHANCE ] + ( critter.Trait[ TRAIT_FINESSE ] != 0 ? 10 : 0 ) + critter.Perk[ PE_MORE_CRITICALS ] * 5;
            if( proccess.RealWeapon !is null )
            {
                criticalChanceDef += proccess.RealWeapon.WeaponBonus_CritChance + proccess.RealWeapon.Proto.Weapon_CriticalBonus;
                uint use = 0;
                int  skillNum = _WeaponSkill( proccess.RealWeapon.Proto, use );
                switch( skillNum )
                {
                case SK_SMALL_GUNS:
                case SK_BIG_GUNS:
                case SK_ENERGY_WEAPONS:
                    criticalChanceDef += critter.BookBonus[ BB_RANGED_CRIT ];
                    break;                                                                                              // бонус от книг. ++Cracker
                case SK_UNARMED:
                case SK_THROWING:
                    criticalChanceDef += critter.BookBonus[ BB_MELEE_AND_THROWING_CRIT ];
                    break;                                                                                                     // бонус от книг. ++Cracker
                default:
                    break;
                }
            }
        }

        currentHexX = critter.HexX;
        currentHexY = critter.HexY;

        maxBlockCount.resize( 3 );
        minDamage.resize( 3 );
        maxDamage.resize( 3 );

        maxBlockCount[ 0 ] = 4;
        maxBlockCount[ 1 ] = 8;
        maxBlockCount[ 2 ] = 4;

        minDamage[ 0 ] = proccess.DmgMin * 0.5;
        minDamage[ 1 ] = proccess.DmgMin;
        minDamage[ 2 ] = proccess.DmgMin * 0.5;

        maxDamage[ 0 ] = proccess.DmgMax * 0.5;
        maxDamage[ 1 ] = proccess.DmgMax;
        maxDamage[ 2 ] = proccess.DmgMax * 0.5;

        targHexX = hexX;
        targHexY = hexY;

		UpgradeItem::UpgradeDescriptor@ upgradeDescriptor = cast< UpgradeItem::UpgradeDescriptor@ >( @item.ScriptDescriptor );
        if( @upgradeDescriptor !is null )
			upgradeDescriptor.CheckData( Data, UpgradeItem::Triggered::LineDamage );
    }

    bool ExecMutual( uint16 hx, uint16 hy )
    {
        dir = GetDirection( currentHexX, currentHexY, hx, hy );
        currentHexX = hx;
        currentHexY = hy;
        if( !( currentHexX == critter.HexX && currentHexY == critter.HexY ) )
            for( int i = -1; i < 2; i++ )
            {
                memHexX = currentHexX;
                memHexY = currentHexY;

                if( i != 0 )
                {
                    memDir = ( dir + i );
                    map.MoveHexByDir( memHexX, memHexY, memDir % maxDir, 1 );
                    // Log("memDir " + memDir%maxDir);
                    // map.MoveHexByDir(memHexX,memHexY,memDir%maxDir,1);
                }
                // map.MoveHexByDir(memHexX,memHexY,memDir%maxDir,1);
                if( !( memHexX == critter.HexX && memHexY == critter.HexY ) && !TargetHex( memHexY * map.GetWidth() + memHexX, AllHex ) )
                {
                    @target = map.GetCritter( memHexX, memHexY );
                    if( target !is null && !target.IsDead() )                 // криттеру.
                    {
                        isCritical = false;
                        critter_attack( critter, target );
                        if( target.IsNpc() || target.GetAccess() != ACCESS_ADMIN )
                            target.ModeBase[ MODE_HIDE ] = 0;
                        target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
                        isCritical = ( Random( 1, 100 ) <= criticalChanceDef );
                        int antiCriticalRes = criticalChanceDef > 100 ? criticalChanceDef - 100 : 0;
                        if( Random( 1, 100 ) <= ( target.Stat[ ST_CRITICAL_RESISTANCE ] - antiCriticalRes ) )
                            isCritical = false;
		
						EventSmthAttack( critter, target );
                        CombatRes[] results;

                        if( !proccess.IsLeon( target, 4 ) )
                        {

                            proccess.DmgMin = minDamage[ i + 1 ];
                            proccess.DmgMax = maxDamage[ i + 1 ];

                            ApplyDamage( proccess, target, 1, isCritical, true, results );
                            FlushResults( results );
                        }
                        else
                            proccess.startLeon( target, results );
                    }
                    map.GetItems( memHexX, memHexY, items );

                    if( !map.IsHexRaked( memHexX, memHexY ) )
                    {
                        if( maxBlockCount[ i + 1 ] == 0 )
                            break;
                        maxBlockCount[ i + 1 ] -= 1;

                        minDamage[ i + 1 ] *= 0.66;
                        maxDamage[ i + 1 ] *= 0.66;
                    }
                    else
                    {
                        if( Data.IsFire )
                            SetFire( map, memHexX, memHexY, 1, Random( minDamage[ i + 1 ], maxDamage[ i + 1 ] ) * Data.DamageMod, critter );
						if( Data.Effect != 0 )
							map.RunEffect( Data.Effect, memHexX, memHexY, 0, EFFECT_INSTRUCTION_NONE );
                        // map.SetText (currentHexX,currentHexY, 0, ""+proccess.DmgMin+"-"+proccess.DmgMax );
                    }
                }
            }

        return false;
    }

    void EndTrace( Item& item )
    {
        Item@ it = null;
        for( uint i = 0, iMax = items.length(); i < iMax; i++ )
        {
            @ it = items[ i ];
            if( it !is null )
                ItemDamage( it, ( Random( ( _WeaponDmgMin( item.Proto, item.Mode ) ), ( _WeaponDmgMax( item.Proto, item.Mode ) ) ) ) );
        }
    }
}

#endif // !__CLIENT
#ifdef __CLIENT
class BurstTimer : _Timeout
{
	BurstStage@ stage;
	
	BurstTimer( string str )
	{
		CritterCl@ chosen = GetChosen();
		if( chosen !is null )
			ChosId = chosen.Id;
		else ChosId = 0;
		Str = str;
	}
	
	string@ Get() override
	{
		if( stage is null || stage.maxrounds == 0 )
			return null;
			
		CritterCl@ chosen = GetChosen();
		if( chosen is null || ChosId != chosen.Id )
			return null;
		return Str + stage.currentRound + "/" + stage.maxrounds ;
	}
}
#endif

uint BurstStageDestcriptorId = GetStrHash("BurstStageDestcriptor");

class BurstStage : MutualObject
{
	uint current;
	uint max;
	uint progression;
	uint maxrounds;
	
	#ifdef __CLIENT
	BurstTimer@ Timer;
	#endif
	
	BurstStage( )
	{
		current = 0;
		max = 0;
		progression = 0;
		maxrounds = 0;
		
		#ifdef __CLIENT
		@ Timer = null;
		#endif
	}
	
	
	uint get_currentRound()
	{
		return current/progression;
	}
	
	void Update( uint critterId )
	{
	#ifdef __CLIENT
		if( Timer is null && current != 0 )
		{
			@Timer = BurstTimer( "Прогрессия очереди: " );
			@Timer.stage = this;
			AddTimer( Timer );
		}
		if( current == 0 && Timer !is null )
		{
			@Timer.stage = null;
			@Timer = null;
		}
	#endif
	}
	
}

class DebugTraccer : MutualObject
{
	uint AttackerId;
	uint TargetId;
	uint HitRounds;
	uint CountRounds;
	uint LeonRounds;
	
	void Update( uint critterId )
	{
	#ifdef __CLIENT
		if( AttackHex::Option::Combat::BurstDebug )
		{
			CritterCl@ chosen = GetChosen();
			if( chosen.Id == AttackerId )
			{
				Message( "Попало " + ( HitRounds + LeonRounds ) + " из " + CountRounds + " пуль." + 
				( ( LeonRounds != 0 ) ? ( " Увернулся от " + LeonRounds ) : "" ) );
			}
			else
			{
				Message( "В вас попало " + ( HitRounds + LeonRounds ) + " из " + CountRounds + " пуль." + 
				( ( LeonRounds != 0 ) ? ( " Увернулся от " + LeonRounds ) : "" ) );
			}
		}
	#endif
	}
	
}

#ifdef __CLIENT
# define MapIsHexPassed       IsHexPassed
# define MapMoveHexByDir      MoveHexByDir
# define MapGetCrittersHex    GetCrittersHex
#endif
#ifndef __CLIENT
# define MapIsHexPassed       Map.IsHexPassed
# define MapMoveHexByDir      Map.MoveHexByDir
# define MapGetCrittersHex    Map.GetCrittersHex
#endif
mixin class MixinToHitProccess
{
	#ifdef __CLIENT
	int ToHit( CritterMutual@ target, uint8 aim, uint16 hexX, uint16 hexY )
	#endif
	#ifndef __CLIENT
	int ToHit( CritterMutual@ target, uint8 aim, uint16 hexX, uint16 hexY )
	#endif
	{
		int distantion = GetDistantion( Attacker.HexX, Attacker.HexY, hexX, hexY );
		if( distantion > GetWeaponMaxDistance() )
			return 0;

		Hit = AttackerSkill;
			
		if( WeaponSkill != SK_UNARMED )
		{
			// Ranged proccess modifiers
			int distmod1 = 2; // Used for initial weapon bonus
			int distmod2 = 0; // Minimal distance
			if( IsWeaponPerk( WEAPON_PERK_LONG_RANGE ) )
				distmod1 = 4;
			else if( IsWeaponPerk( WEAPON_PERK_SCOPE_RANGE ) )
			{
				distmod1 = 5;
				distmod2 = 5;
			}

			int perception = Attacker.Stat[ ST_PERCEPTION ];
			int acc = distantion;

			if( distantion < distmod2 )
				acc += distmod2;
			else
			{
				if( Attacker.IsPlayer() )
					acc -= ( perception - 2 ) * distmod1;
				else
					acc -= perception * distmod1;
			}

			if( -2 * perception > acc )
				acc = -2 * perception;

			acc -= 4 * Attacker.Perk[ PE_SHARPSHOOTER ];

			if( acc >= 0 )
			{
				if( Attacker.Damage[ DAMAGE_EYE ] != 0 )
					acc *= -12;
				else
					acc *= -4;
			}
			else
				acc *= -4;

			Hit += acc - ( 10 * ( MapGetCrittersPath( Attacker.HexX, Attacker.HexY, hexX, hexY, 0.0f, distantion, FIND_LIFE, null ) ) );

			if( distantion > 1 && !Weapon.Weapon_ZoneAttackIgnoreNotRaked )
			{
				uint16 hx = hexX, hy =  hexY;
				MapMoveHexByDir( hx, hy, GetDirection( hexX, hexY, Attacker.HexX, Attacker.HexY ), 1 );
				if( not MapIsHexPassed( hx, hy ) && MapGetCrittersHex( hx, hy, 0, FIND_LIFE, null ) == 0 )
					Hit -= 120;
				else if( distantion > 2 )
				{
					hx = hexX;
					hy =  hexY;
					MapMoveHexByDir( hx, hy, GetDirection( hexX, hexY, Attacker.HexX, Attacker.HexY ), 2 );
					if( not MapIsHexPassed( hx, hy ) && MapGetCrittersHex( hx, hy, 0, FIND_LIFE, null ) == 0 )
						Hit -= 85;
					else if( distantion > 3 )
					{
						hx = hexX;
						hy =  hexY;
						MapMoveHexByDir( hx, hy, GetDirection( hexX, hexY, Attacker.HexX, Attacker.HexY ), 3 );
						if( not MapIsHexPassed( hx, hy ) && MapGetCrittersHex( hx, hy, 0, FIND_LIFE, null ) == 0 )
							Hit -= 50;
					}

				}

			}

		} // End range modifiers
		
		if( RealWeapon !is null )
		{
			if( !( Weapon.Weapon_IsUnarmed ) && Attacker.Trait[ TRAIT_ONE_HANDER ] != 0 )
				Hit += ( FLAG( Weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );
			Hit += RealWeapon.WeaponBonus_ToHit;
		}

		int handlingStrength = Attacker.Stat[ ST_STRENGTH ];
		int reqStrength = Weapon.Weapon_MinStrength;
		if( Attacker.Perk[ PE_WEAPON_HANDLING ] != 0 )
			handlingStrength += 3;
		if( Attacker.Trait[ TRAIT_ONE_HANDER ] != 0 && FLAG( Weapon.Flags, ITEM_TWO_HANDS ) == false )
			handlingStrength += 1;
		if( handlingStrength < reqStrength )
			Hit -= ( reqStrength - handlingStrength ) * 20;
		Hit += Weapon.Weapon_BonusToHit;

		if( Attacker.Damage[ DAMAGE_EYE ] != 0 )
			Hit -= 25;
		if( Attacker.Perk[ PE_VAMPIRE_ACCURACY ] != 0 && IS_NIGHT( __Hour ) )
			Hit += 13;
		if( target !is null )
		{
			if( target.IsKnockout() )
				Hit += 40;
			Hit += target.GetMultihex() * 15;
		}
		
		int hitMod = GetHitAim( aim );
		if( WeaponSkill == SK_UNARMED )
			hitMod /= 2;
		Hit -= hitMod;
		
		Hit += Attacker.MyBonus[ WEAPON_BONUS_TOHIT ];
		// Штраф за расстояние для очередей
		HitMaxBorder = 95;
		HitMinBorder = 5;
		HitPenalty = 0;
		
		if( Weapon.Weapon_DeadZone != 0 )
		{
			HitModule = DeadZone_PenaltySecondTargets;
			
			if( distantion > Weapon.Weapon_DeadZone && distantion < GetWeaponMaxDistance() - Weapon.Weapon_DeadZone )
				HitModule = DeadZone_PenaltyEffectTargets;
			else HitMaxBorder *= DeadZone_MaxHitModule;
			Hit *= HitModule;
		}
		
		if( _WeaponAttackType( Weapon, WeaponUse ) != WTA_LINE_FLAME && WeaponSkill != SK_UNARMED )
		#ifdef __CLIENT
			HitPenalty += GetSmokePenalty( null, hexX, hexY );
		
		#endif
		
		#ifndef __CLIENT
			HitPenalty += GetSmokePenalty( Map, Attacker, null, hexX, hexY );
		#endif
		HitResult = HitClamp( Hit );
		return HitResult;
	}
	
	int GetHitMaxBorder( )
	{
		return HitMaxBorder - HitPenalty;
	}
	
	int GetHitMinBorder( )
	{
		return HitMinBorder;
	}
	
	int HitClamp( int hit )
	{
		return CLAMP( hit, GetHitMinBorder( ), GetHitMaxBorder( ) );
	}
}

class ToHitProccess : MixinToHitProccess
{
	int Hit;
	int HitResult;
	int WeaponSkill;
	int HitPenalty;
	int HitMaxBorder;
	int HitMinBorder;
	
	float HitModule;
	
	CritterMutual@ Attacker;
	ItemMutual@ RealWeapon;
	ProtoItem@ Ammo;
	ProtoItem@ Weapon;
	uint8 WeaponUse;
	
	int AttackerSkill;
	
	void MutualConstruct( CritterMutual& attacker, ItemMutual@ realWeapon, ProtoItem@ weapon, ProtoItem@ ammo, uint8 use )
	{
		@Attacker = attacker;
		@RealWeapon = realWeapon;
		@Ammo = ammo;
		@Weapon = weapon;
		WeaponUse = use;
		WeaponSkill = _WeaponSkill( Weapon, WeaponUse );
		AttackerSkill = Attacker.Skill[ WeaponSkill ];
	}
    
	bool IsWeaponPerk( int number )
	{
		return _WeaponeIsPerk( Weapon, Ammo, number );
	}
	
	int GetWeaponMaxDistance()
	{
		if( WeaponSkill == SK_THROWING )
			return MIN( _WeaponMaxDist( Weapon, WeaponUse ), 3 * MIN( 10, ( Attacker.Stat[ ST_STRENGTH ] + 2 * Attacker.Perk[ PE_HEAVE_HO ] ) ) );
		return _WeaponMaxDist( Weapon, WeaponUse );
	}
	
#ifdef __CLIENT
	ToHitProccess( CritterMutual& attacker, ItemMutual@ realWeapon, ProtoItem@ weapon, ProtoItem@ ammo, uint8 use )
	{
		MutualConstruct( attacker, realWeapon, weapon, ammo, use );
	}
#endif
	
#ifndef __CLIENT
	Map@ Map;

	ToHitProccess( Map& map, CritterMutual& attacker, ItemMutual@ realWeapon, ProtoItem@ weapon, ProtoItem@ ammo, uint8 use )
	{
		MutualConstruct( attacker, realWeapon, weapon, ammo, use );
		@Map = map;
	}
#endif
}

#ifdef __CLIENT
int ToHitMutual( CritterMutual& critter, CritterMutual@ target, ItemCl@ realWeapon, ProtoItem@ weapon, ProtoItem@ ammo, uint8 weaponMode, uint16 hexX, uint16 hexY )
{
    return ToHitProccess( critter, realWeapon, weapon, ammo, _WeaponModeUse( weaponMode ) ).ToHit( target, _WeaponModeAim( weaponMode ), hexX, hexY );
}
#endif
#ifndef __CLIENT
int ToHitMutual( Map& map, CritterMutual& critter, CritterMutual@ target, Item@ realWeapon, ProtoItem@ weapon, ProtoItem@ ammo, uint8 weaponMode, uint16 hexX, uint16 hexY )
{
    return ToHitProccess( map, critter, realWeapon, weapon, ammo, _WeaponModeUse( weaponMode ) ).ToHit( target, _WeaponModeAim( weaponMode ), hexX, hexY );
}
#endif

// / Client
#ifdef __CLIENT

# include "sprite.fos"
# include "_client_defines.fos"
# include "client_gui_h.fos"
# include "_colors.fos"
# include "client_timeout_h.fos"

import bool StartStalking( CritterCl@ critter, uint16 hexY, uint16 hexX ) from "client_main";
import void __SetAttacked( int Id, int param1, int param2, string@ param3, int[] @ param4 ) from "client_main";
import uint GetSmokePenalty( CritterCl@ target, uint16 HexX, uint16 HexY ) from "Mk2";
import int  GUI_GetActiveScreen() from "client_gui";
import void DrawBorder( CritterCl& critter, uint distance, uint color ) from "client_main";

int[][]@ ZoneAttack = null;

void DropZoneAttack()
{
	@ZoneAttack = array<array<int>>();
}

// Опции 
// AttackHex::Option::Combat::ColorMainSlot
// AttackHex::Option::Combat::ColorSecondSlot
// AttackHex::Option::Combat::ColorBonusSlot
// AttackHex::Option::Combat::OnlySprite
namespace AttackHex
{ 
	namespace Option
	{
		namespace Combat
		{
			uint	ColorMainWeapon = COLOR_SAND;
			uint	ColorSecondWeapon = COLOR_SAND;
			uint	ColorBonusWeapon = COLOR_BLUE;
			uint	ColorHexBlocked = COLOR_RED;
			
			uint	ColorBurstZone = COLOR_CHANGE_ALPHA( COLOR_SAND, 60 );
			uint	ColorBurstEffectZone = COLOR_CHANGE_ALPHA( COLOR_RED, 60 );
			::Sprite HexSprite;
			::Sprite SpriteBurstTarget;
			
			bool OnlySprite = false;
			bool BurstDebug = true;
		}
	}
}

bool IsHexsDraw = false;

void InitHexCombat()
{
	AttackHex::Option::Combat::HexSprite.Load( "geometry/fallout_hex1.png", PT_ART );
	AttackHex::Option::Combat::SpriteBurstTarget.Load( "geometry/fallout_hex1.png", PT_ART );
}

void render_hit_hex( uint layer )
{
	if( layer != 2 )
		return;
    CritterCl@ chosen = GetChosen();
    if( chosen is null ) return;
	
    ItemCl@ realWeapon = __GrenadeMode ? _CritGetItemBonus( chosen ) : _CritGetItemHand( chosen );
    if( realWeapon is null ) return;
	
    uint8 mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( __GrenadeMode ? SLOT_BONUS : SLOT_HAND1, mode );
    if( weapon is null ) return;
	uint8 use = _WeaponModeUse( mode );
    ProtoItem@ ammo = ( realWeapon !is null ) ? GetProtoItem( realWeapon.AmmoPid ) : null;

    if( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_HEX_ATTACKING ) || _WeaponAttackType( weapon, use ) == WTA_BURST_REGION )
    {
		//DrawText( "Тест", __MouseX - 6, __MouseY - 6, 100, 100, COLOR_RED,  FONT_FALLOUT, FT_ALIGN | FT_UPPER | FT_BORDERED );
        uint16  hx = 0,
                   hy = 0;
        CritterCl@ monitorCr = GetMonitorCritter( __MouseX, __MouseY );
		bool isCritter = false;
        if( monitorCr !is null && !CtrlPressed )
        {
            hx = monitorCr.HexX;
            hy = monitorCr.HexY;
			isCritter = true;
        }
        else
            GetMonitorHex( __MouseX, __MouseY, hx, hy );
			
        if( hx != 0 && hy != 0 )
        {
            uint16 len = GetDistantion( chosen.HexX, chosen.HexY, hx, hy );
            int    WMaxDist = _WeaponMaxDist( weapon, use );
            uint   dist = ( _WeaponSkill( weapon, use ) == SK_THROWING ) ? ( MIN( WMaxDist, 3 * MIN( int(10), ( chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) ) ) ) : WMaxDist; // Дистанция стрельбы оружия.
			
            if( ( chosen.Stat[ ST_VISIBLE_DIST ] < len || dist < len ) || len == 0 || dist == 0 )
				return;
					
			if( !weapon.Weapon_ZoneAttackIgnoreNotRaked )
			{
				uint16 XP = hx;
				uint16 YP = hy;
				if( !IsHexRaked( XP, YP ) && !isCritter )
					return;

				GetHexCoord( chosen.HexX, chosen.HexY, XP, YP, 0, len );
				GetDistantion( chosen.HexX, chosen.HexY, XP, YP );
				if(( XP != hx || YP != hy ) && !isCritter )
					return;
			}

			DrawToHit( weapon, mode, @monitorCr, hx, hy );

			if( ZoneAttack !is null )
			{
				if( IsHexsDraw )
				{
					int x2 = 0;
					int y2 = 0;

					int w = AttackHex::Option::Combat::HexSprite.Width / __SpritesZoom;
					int h = AttackHex::Option::Combat::HexSprite.Height / __SpritesZoom;
						
					for( uint i = 0, iEnd = ZoneAttack.length(); i < iEnd; i++ )
					{
						if( ZoneAttack[ i ].length() == 3 && GetHexPos( ZoneAttack[ i ][ 0 ], ZoneAttack[ i ][ 1 ], x2, y2 ) )
							DrawSprite( AttackHex::Option::Combat::HexSprite.Id, 0, x2 - ( w * 0.5 ), y2 - ( h * 0.5 ), w, h, true, true, ZoneAttack[ i ][ 2 ] );
					}
				}
				else
				{
					for( uint i = 0, iEnd = ZoneAttack.length(); i < iEnd; i++ )
					{
						if( ZoneAttack[ i ].length() > 0 )
							DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, ZoneAttack[ i ] );
					}
				}
			}
        }
    }
}

void DrawToHit( ProtoItem& weapon, uint8 mode, CritterCl@ monitorCr, uint16 hx, uint16 hy )
{
	int text = to_hit_hex( weapon, mode, @monitorCr, hx, hy );
    DrawText( text + "%", __MouseX + 6, __MouseY + 6, 100, 100, COLOR_RED,  FONT_FALLOUT, FT_ALIGN | FT_UPPER | FT_BORDERED );
}

int to_hit_hex( ProtoItem& weapon, uint8 weaponMode, CritterCl@ target, uint16 hexX, uint16 hexY )
{
    CritterCl@ chosen = GetChosen();
    if( chosen is null ) return 0;
    ItemCl@ realWeapon = __GrenadeMode ? _CritGetItemBonus( chosen ) : _CritGetItemHand( chosen );
    if( realWeapon is null )
        return 0;
    ProtoItem@ ammo = realWeapon !is null ? GetProtoItem( realWeapon.AmmoPid ) : null;

    if( realWeapon !is null && _WeaponRound( weapon, _WeaponModeUse( weaponMode ) ) > 0 )
    {
        if( realWeapon.AmmoCount == 0 )
            return 0;
        @ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    if( target !is null )
    {
        hexX = target.HexX;
        hexY = target.HexY;
    }
	
    return ToHitMutual( chosen, target, realWeapon, weapon, ammo, weaponMode, hexX, hexY );
}

bool hex_attack( CritterCl@ target, uint16 hexX, uint16 hexY )
{
    CritterCl@ chosen = GetChosen();
    if( chosen is null )
        return false;
		
    uint8 mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( __GrenadeMode ? SLOT_BONUS : SLOT_HAND1, mode );
    if( weapon !is null )
    {
		uint8 use = _WeaponModeUse( mode );
        ItemCl@ realWeapon = __GrenadeMode ? _CritGetItemBonus( chosen ) : _CritGetItemHand( chosen );
        ProtoItem@ ammo = realWeapon !is null ? GetProtoItem( realWeapon.AmmoPid ) : null;
        if( realWeapon !is null && _WeaponRound( weapon, use ) > 0 && realWeapon.AmmoCount == 0 )
            return false;

        if( _WeaponeIsPerk( weapon, ammo, WEAPON_PERK_HEX_ATTACKING ) || _WeaponAttackType( weapon, use ) == WTA_BURST_REGION )
        {
            uint16 hx = 0, hy = 0;
            if( CtrlPressed )
                @target = null;
            if( target !is null && target.Id != chosen.Id )
            {
                hx = target.HexX;
                hy = target.HexY;
					
                __SetAttacked( target.Id, weapon.ProtoId, 0, null, null );
            }
            else if( hexX > 0 && hexY > 0 )
            {
				hx = hexX;
				hy = hexY;
			}
			else if( !GetMonitorHex( __MouseX, __MouseY, hx, hy ) )
				return false;
			
			if( target !is null || ( ( hx > 0 && hy > 0 ) && ( IsHexRaked( hx, hy ) || weapon.Weapon_ZoneAttackIgnoreNotRaked ) ) )
			{
				if( StartStalking( target, hx, hy ) )
					return true;

				uint[]  actions = { CHOSEN_NONE, 0, 0, 0, 0, 0, 0 };
				SetChosenActions( actions );
				RunServerScriptUnsafe( "combat@unsafe_Attack", hx, hy,  __GrenadeMode ? SLOT_BONUS : SLOT_HAND1,  null, null );
				return true;
			}
        }
    }
    return false;
}

void mouse_move_attack_hex( int x, int y, CritterCl@ target )
{
    DropZoneAttack();
    IsHexsDraw = false;
    if( GUI_GetActiveScreen() != CLIENT_MAIN_SCREEN_GAME )
        return;
    uint8      mode = 0;
    CritterCl@ chosen = GetChosen();
    if( chosen is null )
        return;

    ProtoItem@ protoweapon = chosen.GetSlotProto( __GrenadeMode ? SLOT_BONUS : SLOT_HAND1, mode );
    if( protoweapon is null )
        return;

	ItemCl@ realWeapon = chosen.GetItem( 0, __GrenadeMode ? SLOT_BONUS : SLOT_HAND1 );
    if( realWeapon is null )
        return;
    uint16 weapPid = realWeapon.GetProtoId();
	
	int use = _WeaponModeUse( realWeapon.Mode );
	
    ProtoItem@ ammo = ( realWeapon !is null ) ? GetProtoItem( realWeapon.AmmoPid ) : null;
    {
        if( realWeapon !is null && _WeaponRound( protoweapon, use ) > 0 )
        {
            if( realWeapon.AmmoCount == 0 )
                return;
        }
    }

    if( _WeaponeIsPerk( protoweapon, ammo, WEAPON_PERK_HEX_ATTACKING ) || _WeaponAttackType( protoweapon, use ) == WTA_BURST_REGION )
    {
        if( GetCurrentCursor() == CURSOR_USE_WEAPON )
        {
            //CritterCl@ target = GetMonitorCritterExt(__MouseX, __MouseY);
            //if( @target == null || target.Id == chosen.Id || CtrlPressed )
            {
                switch( _WeaponAttackType( protoweapon, use ) )
                {
                case WTA_LINE_IGNORED_RAKED:
                {
                    uint16 hx = 0;
                    uint16 hy = 0;
					if( target !is null )
					{
						hx = target.HexX;
						hy = target.HexY;
					}
                    else GetMonitorHex( x, y, hx, hy );
                    IsHexsDraw = true;

                    CTraceLineIgnoredRaked Trace( chosen.HexX, chosen.HexY, hx, hy );
                    LineTracerHex( chosen.HexX, chosen.HexY, hx, hy, _WeaponMaxDist( protoweapon, use ), Trace );
					@ZoneAttack = @Trace.ZoneData;

                } break;

                case WTA_LINE_FLAME:
                {
                    uint16 tx = 0;
                    uint16 ty = 0;
					if( target !is null )
					{
						tx = target.HexX;
						ty = target.HexY;
					}
                    else GetMonitorHex( x, y, tx, ty );
                    IsHexsDraw = true;

                    uint16 dx = tx,
                           dy = ty,
                           hx = chosen.HexX,
                           hy = chosen.HexY,
                           wx = 0,
                           wy = 0;

                    uint dist = _WeaponMaxDist( protoweapon, use );

                    uint radius = 1;
                    uint dir = 0;
                    GetHexCoord( hx, hy, dx, dy, 0, dist );

                    bool[] isFlameDirect = { true, true, true };

                    for( uint n = 0; n < dist; n++ )
                    {
                        dir = GetDirection( hx, hy, dx, dy );
                        MoveHexByDir( hx, hy, dir, 1 );
                        wx = hx;
                        wy = hy;

                        if( !IsHexRaked( wx, wy ) )
                            break;

                        uint d = 0;

                        for( uint r = 0; r < radius; r++ )
                        {
                            if( chosen.HexX == wx && chosen.HexY == wy )
                                continue;

                            if( IsHexRaked( wx, wy ) )
                            {
                                if( isFlameDirect[ d ] )
                                {
                                    int[] zoneAttack = { wx, wy, AttackHex::Option::Combat::ColorMainWeapon };
                                    ZoneAttack.insertLast( zoneAttack );
                                }
                            }
                            else
                                isFlameDirect[ d ] = false;

                            wx = hx;
                            wy = hy;
                            d = ( r % 2 == 0 ) ? d = 1 : d = 2;
                            MoveHexByDir( wx, wy, ( r % 2 == 0 ) ? ( dir + 1 ) % 6 : ( dir - 1 ) % 6, r / 2 + 1 );
                        }

                        if( radius - 1 < protoweapon.HexWeapon_Radius )
                            radius++;
                    }
                } break;
				case WTA_BURST_REGION:
				{
					if( _WeaponRound( protoweapon, use ) > 1 && _WeaponNoBrust( protoweapon, use ) != 1 )// burst
					{
						uint16 hx = 0;
						uint16 hy = 0;
						if( target !is null )
						{
							hx = target.HexX;
							hy = target.HexY;
						}
						else GetMonitorHex( x, y, hx, hy );
						
						uint16 preBlockHx = 0, preBlockHy = 0, chosX = chosen.HexX, chosY = chosen.HexY, blockHx = 0, blockHy = 0;
						
						int angle_effect = _WeaponAngleEffective( protoweapon, use );
						int angle_second = _WeaponAngleSecond( protoweapon, use );
						if( angle_effect > angle_second )
							angle_second = angle_effect;
						
						uint weaponMaxDist = _WeaponMaxDist( protoweapon, use );
						
						CTraceBurst Trace( chosX, chosY, weaponMaxDist );
						for( int angle = 0 - angle_second, angleend = angle_second + 1; angle < angleend; angle++ )
						{
							Trace.Drop();
							GetCrittersPath( chosX, chosY, hx, hy, float( angle ), weaponMaxDist, FIND_LIFE_AND_KO, null, preBlockHx, preBlockHy, blockHx, blockHy );
							int color = AttackHex::Option::Combat::ColorBurstZone;
							if( angle >= 0 - angle_effect && angle <= angle_effect )
								color = AttackHex::Option::Combat::ColorBurstEffectZone;
							Trace.SetColor( color );
							Trace.SetDeadZone( protoweapon.Weapon_DeadZone );
							LineTracerHex( chosX, chosY, preBlockHx, preBlockHy, weaponMaxDist, Trace );
						}
						
						IsHexsDraw = true;
						@ZoneAttack = Trace.ZoneData;
						break;
					}
				}
                case WTA_RADIUS_HEX:
                default:
                {
					uint16 hx = 0;
                    uint16 hy = 0;
                    int    radius = protoweapon.HexWeapon_Radius;
                    if( radius == 0 )
                        radius = ( weapPid == PID_GRANADE_REVOLV_I || weapPid == PID_GRANADE_REVOLV_II || weapPid == PID_GRANADE_PISTOL || weapPid == PID_REVOLV_GRENADE ) ? 1 : 2;
                    int x1 = 0;
                    int y1 = 0;
					
                    uint8 hexCount = weapPid == PID_JACKAL ? 3 : 1;
					IsHexsDraw = AttackHex::Option::Combat::OnlySprite;
                    for( uint c = 0; c < hexCount; c++ )
                    {
                        int[] zoneAttack = {};
						if( target !is null )
						{
							hx = target.HexX;
							hy = target.HexY;
						}
						else GetMonitorHex( x, y, hx, hy );
                        //GetMonitorHex( x, y, hx, hy );
                        uint8 dir = GetDirection( chosen.HexX, chosen.HexY, hx, hy );
                        if( c == 1 )
                            MoveHexByDir( hx, hy, ( dir + 2 ) % 6, 2 );
                        else if( c == 2 )
                            MoveHexByDir( hx, hy, ( dir + 4 ) % 6, 2 );
                        GetHexPos( hx, hy, x1, y1 );

                        int    x1 = 0;
                        int    y1 = 0;

                        int    yMax = hy + radius;
                        int    yMin = hy - radius;

                        int    xMax = hx + radius;
                        int    xMin = hx - radius;

                        uint16 lastHx = hx - radius;
                        uint16 lastHy = yMin;

                        int    MapWidth = GetMapWidth();
                        int    MapHeight = GetMapHeight();

                        if( MapWidth <  xMax )
                            xMax = MapWidth;
                        if( xMin < 0 )
                            xMin = 0;
                        if( MapHeight <  yMax )
                            yMax = MapHeight;
                        if( yMin < 0 )
                            yMin = 0;

                        if( !chosen.IsDead() && IsHexRaked( hx, hy ) )
                        {
                            for( int hexX = xMin, xEnd = xMax; hexX <= xEnd; hexX++ )
                            {
                                uint16 ihx = hexX;
                                uint16 ihy = yMin;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }

                            for( int hexY = yMin, yEnd = yMax; hexY <= yEnd; hexY++ )
                            {

                                uint16 ihx = xMax;
                                uint16 ihy = hexY;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }

                            for( int hexX = xMax, xEnd = xMin; hexX >= xEnd; hexX-- )
                            {

                                uint16 ihx = hexX;
                                uint16 ihy = yMax;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }

                            for( int hexY = yMax, yEnd = yMin; hexY >= yEnd; hexY-- )
                            {

                                uint16 ihx = xMin;
                                uint16 ihy = hexY;

                                GetHexCoord( hx, hy, ihx, ihy, 0, radius );
                                if( GetHexPos( ihx, ihy, x1, y1 ) )
                                {
									if( AttackHex::Option::Combat::OnlySprite )
									{
										int[] zoneAttack = { ihx, ihy, AttackHex::Option::Combat::ColorMainWeapon };
										ZoneAttack.insertLast( zoneAttack );
									}
									else
									{
										zoneAttack.insertLast( x1 );
										zoneAttack.insertLast( y1 );
										zoneAttack.insertLast( AttackHex::Option::Combat::ColorMainWeapon );
									}
                                }
                            }
                        }
						
						if( !AttackHex::Option::Combat::OnlySprite )
							ZoneAttack.insertLast( zoneAttack );
                    }
                }
                break;
                }
            }
        }
    }
}

class CTraceLineIgnoredRaked : ITraceContext
{
    uint8  dir = 0;

    uint16 startHexX = 0;
    uint16 startHexY = 0;
    uint16 currentHexX = 0;
    uint16 currentHexY = 0;
    uint16 targHexX = 0;
    uint16 targHexY = 0;
    uint16 memHexX = 0;
    uint16 memHexY = 0;

	int[][]@ ZoneData;

    CTraceLineIgnoredRaked( uint16 StartHexX, uint16 StartHexY, uint16 hx, uint16 hy )
    {
        currentHexX = StartHexX;
        currentHexY = StartHexY;
        targHexX = hx;
        targHexY = hy;
        startHexY = StartHexY;
        startHexX = StartHexX;
		@ZoneData = array<array<int>>();
    }

    bool ExecMutual( uint16 hx, uint16 hy )
    {
        dir = GetDirection( currentHexX, currentHexY, targHexX, targHexY );

        currentHexX = hx;
        currentHexY = hy;
		
        if( !( currentHexX == startHexX && currentHexY == startHexY ) )
            for( int i = -1; i < 2; i++ )
            {
                memHexX = currentHexX;
                memHexY = currentHexY;

                if( i != 0 )
                {
                    MoveHexByDir( memHexX, memHexY, ( dir + i ) % ( __MapHexagonal ? 6 : 8 ), 1 );
                }

                if( !( memHexX == startHexX && memHexY == startHexY ) )
                {
                    int[] zoneAttack = { memHexX, memHexY, ( IsHexRaked( memHexX, memHexY ) ? AttackHex::Option::Combat::ColorMainWeapon : AttackHex::Option::Combat::ColorHexBlocked ) };
                    ZoneData.insertLast( zoneAttack );
                }
            }

        return false;
    }
}

#endif // __CLIENT

class CTraceBurst : ITraceContext
{
    uint16 startHexX = 0;
    uint16 startHexY = 0;	
	
	uint WeaponDistance = 0;
	
	CritterMutual@[] critters;
	uint DeadZone = 0;

#ifdef __CLIENT
    int    Color = 0;

	int[][]@ ZoneData;
	
	void SetColor( int color )
	{
		Color = color;
	}
	
	void MutualConstruct()
	{
		@ZoneData = int[][]();
	}
#endif
#ifndef __CLIENT
	void MutualConstruct()
	{
	
	}
#endif

    CTraceBurst( uint16 StartHexX, uint16 StartHexY, uint weapondist )
	{
        startHexY = StartHexY;
        startHexX = StartHexX;
		MutualConstruct();
		WeaponDistance = weapondist;
    }
	
	void SetDeadZone( uint8 zone )
	{
		DeadZone = zone;
	}
	
	void Drop()
	{
	
	}

    bool ExecMutual( uint16 hx, uint16 hy )
    {
		uint distance = GetDistantion( startHexX, startHexY, hx, hy );
        if( !( hx == startHexX && hy == startHexY ) )
		{
#ifndef __CLIENT
			if( !map.IsHexRaked( hx, hy ) )
				return true;
			map.GetCrittersHex( hx, hy, 0, FIND_LIFE_AND_KO, critters );
#endif
#ifdef __CLIENT
			if( !IsHexRaked( hx, hy ) )
				return true;

			int color = AttackHex::Option::Combat::ColorBurstZone;
			if( distance < WeaponDistance - DeadZone && distance > DeadZone )
				color = Color;
			int[] arr = { hx, hy, color };
			ZoneData.insertLast( arr );
#endif
		}
		
        return false;
    }
}

bool TargetHex( uint index, uint[]& indx )
{
	if( indx.find( index ) == -1 )
	{
		indx.insertLast(index);
		return false;
	}
    return true;
}


uint GetAimApCost( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __ApCostAimTorso;
    case HIT_LOCATION_EYES:
        return __ApCostAimEyes;
    case HIT_LOCATION_HEAD:
        return __ApCostAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __ApCostAimArms;
    case HIT_LOCATION_GROIN:
        return __ApCostAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __ApCostAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetBonusCriticalChanceForHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes - 25;
    case HIT_LOCATION_HEAD:
        return __HitAimHead - 20;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms - 10;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin - 10;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}
