// Скрипт взлома компьютеров
// Генерится последовательность из 4 неповторяющихся цифр, игроку дается от 4 до 6 попыток угадать последовательность
#include "_macros.fos"
#include "serializator.fos"

#define VAR_SCEN_MAPID     (LVAR_comp_riddle_map_id) // Номер переменной с ид карты, на которой стоит сценери
#define VAR_SCEN_PROTO     (LVAR_comp_riddle_proto)  // Номер переменной кодом протоипа сценери
#define VAR_SCEN_HEX_X     (LVAR_comp_riddle_hex_x)  // Номер переменной с координатой по оси икс объекта сценери
#define VAR_SCEN_HEX_Y     (LVAR_comp_riddle_hex_y)  // Номер переменной с координатой по оси игрек объекта сценери
#define STR_INFO           (400)                     // Для взлома компьютера нужно правильно подобрать последовательность из 4 неповторяющихся цифр.\nСимвол "*" означает, что цифра присутствует в коде, но неверно указано ее положение.\nСимвол "-" означает, что цифра не используется в коде.\nДо блокировки осталось@lex num@ попыток.
#define STR_BLOCKED        (401)                     // Активирована защита от взлома. Система заблокирована
#define STR_SOLVED         (402)                     // Вам удалось обойти систему защиты!
#define STR_HEADER         (403)                     // Система авторизации. Введите код доступа.
#define STR_ANSWER         (404)                     // Ответ системы: @lex code@.
#define STR_CAMERA         (405)                     // Вы подключились к спутнику связи Poseidon NET.
#define _GetNumbers        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
#define _GetXP             # (player) (player.Skill[ SK_SCIENCE ] * player.Stat[ ST_LEVEL ] / 5)
#define MAX_CODE_LENGTH    (4)
#define MAX_SOLVE_TRIES    (Random(4, 6))
#define TIME_RESET         (60 * 60 * 24) // 24 часа. После этого компьютер можно снова попробовать взломать - генерится новый код или удаляется запись из AnyData, если карта не существует.
#define _AnyDataKey        # (mapId, sceneryPid, sceneryX, sceneryY)("CompRiddle_" + mapId + sceneryPid + sceneryX + sceneryY)

ComputerRiddleInfo@ GetRiddleInfo(Critter& player)
{
    GameVar @mapId=GetLocalVar(VAR_SCEN_MAPID, player.Id);
    GameVar @hexX =GetLocalVar(VAR_SCEN_HEX_X, player.Id);
    GameVar @hexY =GetLocalVar(VAR_SCEN_HEX_Y, player.Id);
    GameVar @proto=GetLocalVar(VAR_SCEN_PROTO, player.Id);
    if(!valid(mapId) ||
        !valid(proto) ||
        !valid(hexY) ||
        !valid(hexY) ||
        mapId==0 ||
        !valid(player.GetMap()) ||
        mapId !=player.GetMap().Id ||
        proto==0 ||
        hexY==0 ||
        hexY==0 ||
        GetDistantion(player.HexX, player.HexY, hexX.GetValue(), hexY.GetValue()) > 3)
        return null;
    return GetRiddleInfo(mapId.GetValue(), proto.GetValue(), hexX.GetValue(), hexY.GetValue());
}
ComputerRiddleInfo@ GetRiddleInfo(int mapId, int16 sceneryPid, int16 sceneryX, int16 sceneryY)
{
    string key=_AnyDataKey(mapId, sceneryPid, sceneryX, sceneryY);
    if(IsAnyData(key))
    {
        return ComputerRiddleInfo(key);
    }
    return null;

}
class ComputerRiddleInfo
{
    ComputerRiddleInfo(string key)
    {
        this.Load(key);
    }

    ComputerRiddleInfo(Map & map, Scenery & computor)
    {
        string key=_AnyDataKey(map.Id, computor.ProtoId, computor.HexX, computor.HexY);
        if(IsAnyData(key))
        {
            this.Load(key);
        }
        else
        {
            this.MapId=map.Id;
            this.ComputorPid=computor.ProtoId;
            this.HexX=computor.HexX;
            this.HexY=computor.HexY;
            GenerateCode();
            this.Save(key);
            uint[] values={ this.MapId, this.ComputorPid, this.HexX, this.HexY };
            CreateTimeEvent(__FullSecond + TIME_RESET, "e_ResetRiddle", values, true);
        }
    }

    uint   MapId;
    uint16 ComputorPid;
    uint16 HexX;
    uint16 HexY;
    uint[] Code;
    uint8  TriesLeft;

    string SCode()
    {
        string code="";
        for(uint i=0, l=this.Code.length(); i<l; i++)
            code +=this.Code[ i ];
        return code;
    }

    // Сериализация
    void Save(string key)
    {
        Serializator save;
        save.Set(this.MapId);
        save.Set(this.ComputorPid);
        save.Set(this.HexX);
        save.Set(this.HexY);
        save.Set(this.Code);
        save.Set(this.TriesLeft);
        save.Save(key);
    }

    bool Load(string key)
    {
        Serializator load;
        if(!IsAnyData(key) || !load.Load(key))
            return false;
        load.Get(this.MapId);
        load.Get(this.ComputorPid);
        load.Get(this.HexX);
        load.Get(this.HexY);
        load.Get(this.Code);
        load.Get(this.TriesLeft);
        return true;
    }

    void Erase()
    {
        string key=_AnyDataKey(this.MapId, this.ComputorPid, this.HexX, this.HexY);
        if(IsAnyData(key))
            EraseAnyData(key);
    }

    void GenerateCode()     // Генерирует новый код и сбрасывает число оставшихся попыток
    {
        uint[] numbers=_GetNumbers;
        uint index=0;
        this.Code.resize(0);
        while(this.Code.length()<MAX_CODE_LENGTH)
        {
            index=Random(0, numbers.length() - 1);
            this.Code.insertLast(numbers[ index ]);
            numbers.removeAt(index);
        }
        this.TriesLeft=MAX_SOLVE_TRIES;
    }

    // Попытка угадать пароль
    // Возвращает true - если пароль угадан, false - если нет
    // Правильно угаданный символ отображается как есть
    // Неправильно угаданный - отображается минус
    // Позиция не угадана, угадана цифра - отображается звезда
    bool TrySolveRiddle(Critter& player, string codePlayer, string& codeAnswer)
    {
        if(TriesLeft<1)
        {
            player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_BLOCKED);
            return false;
        }
        string charPlayer="";
        string charReal="";
        string codeReal=this.SCode();
        bool   charFound=false;
        codeAnswer="";

        for(uint i=0, l=codePlayer.length(); i<MAX_CODE_LENGTH && i<l; i++)
        {
            charFound=false;
            charPlayer=codePlayer[ i ];
            for(uint j=0, len=codeReal.length(); j<MAX_CODE_LENGTH && j<len && !charFound; j++)
            {
                charReal=codeReal[ j ];
                if(charReal==charPlayer)
                {
                    charFound=true;
                    if(i==j)
                        codeAnswer +=this.Code[ j ];
                    else
                        codeAnswer +="*";
                }
            }
            if(!charFound)
                codeAnswer +="-";
        }
        this.TriesLeft--;
        this.Save(_AnyDataKey(this.MapId, this.ComputorPid, this.HexX, this.HexY));
        if(codeReal==codeAnswer)
        {
            this.TriesLeft=0;
            this.Save(_AnyDataKey(this.MapId, this.ComputorPid, this.HexX, this.HexY));
            return true;
        }
        return false;
    }
}

uint e_ResetRiddle(uint[] @ values)
{
    ComputerRiddleInfo@ riddle=GetRiddleInfo(values[ 0 ], values[ 1 ], values[ 2 ], values[ 3 ]);
    if(valid(riddle))
    {
        if(valid(GetMap(values[ 0 ])))
        {
            riddle.GenerateCode();
            riddle.Save(_AnyDataKey(values[ 0 ], values[ 1 ], values[ 2 ], values[ 3 ]));
            return TIME_RESET;
        }
        else
        {
            riddle.Erase();
        }
    }
    return 0;
}

bool s_Use(Critter& player, Scenery& scenery, int skill, Item@ item)
{
    if(skill==SK_SCIENCE && !valid(item))
    {
        player.Wait(1000);
        ComputerRiddleInfo@ info=ComputerRiddleInfo(player.GetMap(), scenery);
        GameVar             @mapId=GetLocalVar(VAR_SCEN_MAPID, player.Id);
        GameVar             @hexX =GetLocalVar(VAR_SCEN_HEX_X, player.Id);
        GameVar             @hexY =GetLocalVar(VAR_SCEN_HEX_Y, player.Id);
        GameVar             @proto=GetLocalVar(VAR_SCEN_PROTO, player.Id);
        if(!valid(info) || !valid(mapId) || !valid(hexX) || !valid(hexY))
            return false;
        if(info.TriesLeft<1)
        {
            player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_BLOCKED);
            return true;
        }
        else
        {
            player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_INFO, "$num" + info.TriesLeft);
        }
        mapId=player.GetMap().Id;
        hexX=scenery.HexX;
        hexY=scenery.HexY;
        proto=scenery.ProtoId;
        player.ShowScreen(SCREEN_SAY, 0, "answer_TrySolve");
        player.SayMsg(SAY_SAY_TITLE, TEXTMSG_TEXT, STR_HEADER);
        player.Say(SAY_SAY_TEXT, "????");
        return true;
    }
    return false;
}

void answer_TrySolve(Critter& player, uint answerI, string& answerS)
{
    ComputerRiddleInfo@ info=GetRiddleInfo(player);
    if(valid(info))
    {
        string code="";
        bool   solved=info.TrySolveRiddle(player, answerS, code);
        player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_ANSWER, "$pcode" + answerS + "$code" + code);
        if(solved)
        {
            player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_SOLVED);
            player.StatBase[ ST_EXPERIENCE ] +=_GetXP(player);
            player.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_CAMERA);
            CreateTimeEvent(__FullSecond + REAL_SECOND(1) / 2, "e_ShowCamera", player.Id, false);
        }
    }
}

uint e_ShowCamera(uint[] @ values)
{
    Critter@ cr=GetCritter(values[ 0 ]);
    if(valid(cr))
    {
        Location@[] locations;
        if(GetLocations(cr.WorldX, cr.WorldY, 300, locations) > 0)
        {
            Location@ loc=locations[ Random(0, locations.length() - 1) ];
            if(valid(loc))
            {
                Map@ map=loc.GetMapByIndex(0);
                if(valid(map))
                {
                    uint16 hx=0, hy=0;
                    if(map.GetEntireCoords(0, 0, hx, hy))
                    {
                        cr.ViewMap(map, 50, hx, hy, 5);
                    }
                }
            }
        }

    }
    return 0;
}
