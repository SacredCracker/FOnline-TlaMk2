// Интерфейс нового фиксбоя.
// Совместными усилиями: Ra, TabaK, Sidle Jinks
// Если вы не работали над сервером TLA mk2, но используете этот код - вы пидор

#include "_macros.fos"
#include "_msgstr.fos"
#include "decraft.fos"

#ifdef __SERVER 
#define ItemMutual Item
#define CritterMutual Critter
#endif
#ifndef __SERVER 
#define ItemMutual ItemCl
#define CritterMutual CritterCl
#endif

#include "_upgrade_item_defines.fos"

#define CRAFT_HANDL                  # (handl)                ( CRAFT_OFFSET + handl ) // Отступ, разделяющий указатели на крафт, от указателей на предмет в таблице
#define CRAFT_OFFSET                 ( 6000 )

#define DEFAULT_RADIUS               ( 4 )                                             // Радиус поиска станка в гексах, по умолчанию.

#define SCENERY_NONE                 ( 0 )
#define SCENERY_HUB_WORKBENCH        ( 15567 )                                         // Код прототипа сценери для крафта плазменных гранат (Хабологи)
#define SCENERY_SHOE_WORKBENCH       ( 15568 )                                         // Код прототипа сценери для крафта Ши
#define SCENERY_AMMO_PRESS           ( 15569 )                                         // Пресс для производства аммуниции (2 вида, различаются изображением терминала)
#define SCENERY_LATHE                ( 15570 )                                         // Токарный станок (второй вариант - станок на не-ржавом столе)
#define SCENERY_WORKBENCH            ( 15571 )                                         // Верстак по-умолчанию.
#define SCENERY_STOVE                ( 14936 )                                         // Печь для плавки хитина
#define SCENERY_AMMO_PRESS_MID       ( 15572 )                                         // Пресс для производства аммуниции среднего уровня
#define SCENERY_AMMO_PRESS_HIGH      ( 15573 )                                         // Пресс для производства аммуниции высокого уровня
#define SCENERY_MULTICRAFT           ( 15574 )                                         // Установка для производства ядерных батареек, взрывчатки, топ ингредиентов...
#define SCENERY_PRODUCTION_PLANT1    ( 15575 )                                         // Установка для производства вещей высокого уровня
#define SCENERY_PRODUCTION_PLANT2    ( 15576 )                                         // Установка для производства вещей высокого уровня
#define SCENERY_SAMOGON              ( 15577 )                                         // Самогонный аппарат для гиппо
#define SCENERY_SAMOGON_ALL          ( 14740 )                                         // Самогонный аппарат для наркоты в целом
#define SCENERY_FIRE                 ( 14375 )                                         // Костёр
#define SCENERY_PWRARMOR             ( 14663 )                                         // Детали силовой брони для крафта ПА/ЗПА.

// / Server
#ifndef __CLIENT

#include "blueprint.fos"

#define FIX_SUCCESS                 ( FIXBOY_DEFAULT ^ FIXBOY_CHECK_TIMEOUT ^ FIXBOY_SET_TIMEOUT )
#define FIX_FAIL                    ( FIX_SUCCESS ^ FIXBOY_ALLOW_CRAFT )

import void DeteriorateItem( Critter& cr, Item& item, int deteriorateCount ) from "Mk2";
import void InitRandomisationItem( Item& item, bool isCrafted, Critter& cr, string sufix ) from "Mk2";
import void ChangePlayerScore( Critter& player, uint scoreIndex, int value ) from "Mk2";
// import	void items_crafted(Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter) from "main";

const uint16[] HellAllMapsPid = { MAP_hell_main, MAP_hell_level1, MAP_hell_level2, MAP_hell_level3, MAP_hell_level4, MAP_hell_corridor, MAP_hell_mines, MAP_hell_forest, MAP_hell_pipboys, MAP_hell_burrow };

bool IsHellMap( uint16 mapPid )
{
    for( uint i = 0; i < HellAllMapsPid.length(); i++ )
    {
        if( HellAllMapsPid[ i ] == mapPid )
            return true;
    }
    return false;
}

// Возвращает количество предметов, под ногами и в инвентаре криттера
uint16 getItemCount( uint16 pid, Critter@ player )
{
    Item@[] items;
    Item@[] thisItems;
    uint16 count = 0;

    player.GetItems( -1, items );

    Map@ map = player.GetMap();
    if( valid( map ) )
        map.GetItems( player.HexX, player.HexY, items );

    for( uint16 i = 0, iMax = items.length(); i < iMax; i++ )
        if( items[ i ].GetProtoId() == pid )
            thisItems.insertLast( items[ i ] );

    if( thisItems.length() == 0 )
        return 0;

    // if(thisItems[0].IsStackable())
    {
        for( uint d = 0, dMax = thisItems.length(); d < dMax; d++ )
        {
            if( validEngineObject( thisItems[ d ] ) )
                count += thisItems[ d ].GetCount();
        }
        return count;
    }

    // return thisItems.length();
}

// Удаляет необходимое количество предметов в инвентаре и под ногами криттера
bool delItemCount( const ProtoItem@ proto, uint16 delCount, Critter@ player )
{
    Item@[] items;
    Item@[] deleteItems;
    uint16 count = 0;

    player.GetItems( -1, items );

    Map@ map = player.GetMap();
    if( valid( map ) )
        map.GetItems( player.HexX, player.HexY, items );

    for( uint16 i = 0, iMax = items.length(); i < iMax; i++ )
        if( items[ i ].GetProtoId() == proto.ProtoId )
        {
            if( validEngineObject( items[ i ] ) )
                deleteItems.insertLast( items[ i ] );
        }

    for( uint d = 0, dMax = deleteItems.length(); d < dMax; d++ )
    {
        if( count >= delCount )
            break;

        if( !validEngineObject( deleteItems[ d ] ) )
            return false;

        if( deleteItems[ d ].GetCount() + count > delCount )
        {
            deleteItems[ d ].SetCount( deleteItems[ d ].GetCount() - ( delCount - count ) );
            break;
        }
        count += deleteItems[ d ].GetCount();
        DeleteItem( deleteItems[ d ] );
        @deleteItems[ d ] = null;
    }
    return true;
}

// Крафт на стороне сервера
void unsafe_ci( Critter& player, int Pos, int craftCount, int, string@, int[] @ )
{
	craftInfo@ info = CraftList[ Pos ];
	if( info is null )
		return;
		
    const ProtoItem@ proto = GetProtoItem( info.ResultItem );

    if( proto is null )
        return;
    // Мертвым крафтить нельзя
    if( player.IsDead() )
    {
        player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        return;
    }

    Map@ currentMap = player.GetMap();
    if( validEngineObject( currentMap ) && IsHellMap( currentMap.GetProtoId() ) && info.ResultItem == PID_RAGS )
    {
        player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_CRAFT );
        return;
    }

    if( validEngineObject( currentMap ) && currentMap.GetLocation().GetProtoId() == LOCATION_NewbieLocation )
    {
        if( proto.Type == ITEM_TYPE_WEAPON && ( proto.Weapon_Skill_0 == SK_SMALL_GUNS || proto.Weapon_Skill_0 == SK_BIG_GUNS ||  proto.Weapon_Skill_0 == SK_ENERGY_WEAPONS || proto.ProtoId == PID_MOLOTOV_COCKTAIL || proto.ProtoId == PID_BACKPACK || proto.ProtoId == PID_BAG ) )
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_CRAFT );
            return;
        }
    }

    // Проверка на реальное наличие станка в радиусе
	
    if( info.Workbench != 0 )
        if( !CheckWorkbenchNearPlayer( player, info.Workbench, DEFAULT_RADIUS ) )
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_WORKBENCH );
            return;
        }

    // Проверка по навыкам
    for( uint16 i = 0; i < info.Skills[ 0 ].length(); i++ )
    {
        for( uint j = 0, jMax = info.Skills[ 0 ][ i ].length(); j < jMax; j++ )
            if( player.Param[ info.Skills[ 0 ][ i ][ j ] ] < int( info.Skills[ 1 ][ i ][ j ] ) )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_FIX_PARAMS );
                return;
            }
    }
	
    // Отбой по задержке в 2 секунды, от предыдущего крафта (наука или ремонт)
    if( __Second - uint( player.Stat[ ST_LAST_CRAFT_TIME ] ) <= 2 )
    {
        player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_FIX_TIMEOUT );
        return;
    }

    // Проверка на наличие компонентов
    if( info.Components.length() > 1 )
        for( uint i = 0; i < info.Components[ 0 ].length(); i++ )
            for( uint j = 0, jMax = info.Components[ 0 ][ i ].length(); j < jMax; j++ )
            {
                uint16 pid = info.Components[ 0 ][ i ][ j ];
                if( pid > CRAFT_OFFSET )
                {
                    pid -= CRAFT_OFFSET;
                    pid = CraftList[ pid ].ResultItem;
                }

                if( getItemCount( pid, player ) < uint( info.Components[ 1 ][ i ][ j ] * craftCount * 100 / ( player.Industrial[ IN_MATERIAL_SAVINGS ] * 4 + 100 ) ) )
                {
                    player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_ITEM );
                    return;
                }
            }

    // Проверка на наличие инструментов
    bool toolsValid = false;
    if( info.Tools.length() > 0 && info.Tools[ 0 ][ 0 ] != 0 )
        for( uint16 i = 0; i < info.Tools.length(); i++ )
        {
            toolsValid = false;

            for( uint j = 0; j < info.Tools[ i ].length(); j++ )
            {
                if( getItemCount( info.Tools[ i ][ j ], player ) > 0 )
                {
                    toolsValid = true;
                    break;
                }
            }

            if( !toolsValid )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_TOOLS );
                return;
            }
        }

    // Проверка на наличие знания рецепта
    if( info.VarNum != 0 )
    {
        GameVar@ var = GetLocalVar( info.VarNum, player.Id );
        if( valid( var ) )
        {
            if( var.GetValue() == 0 || var.GetValue() < craftCount )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_BLUEPRINT );
                return;
            }
            else if( var.GetValue() != 100 )
            {
                // Снятие пункта с рецепта, если он не бесконечный
                var = var.GetValue() - craftCount;
            }
        }
        else
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_BLUEPRINT );
            return;
        }
    }

    // Удаление компонентов
    for( uint i = 0, iMax = info.Components[ 0 ].length(); i < iMax; i++ )
        for( uint j = 0, jMax = info.Components[ 0 ][ i ].length(); j < jMax; j++ )
        {
            uint16 pid = info.Components[ 0 ][ i ][ j ];
            if( pid > CRAFT_OFFSET )
            {
                pid -= CRAFT_OFFSET;
                pid = CraftList[ pid ].ResultItem;
            }
            if( !delItemCount( GetProtoItem( pid ), uint( info.Components[ 1 ][ i ][ j ] * craftCount * 100 / ( player.Industrial[ IN_MATERIAL_SAVINGS ] * 4 + 100 ) ), player ) )
                return;
        }
	
	uint craft_count = craftCount * info.Count;
    // Игрок получает предметы
    for( uint i = 0; i < craft_count; i++ )
    {
        Item@ resultItem = player.AddItem( info.ResultItem, 1 );
        if( resultItem.GetType() == ITEM_TYPE_WEAPON && resultItem.Proto.Weapon_MaxAmmoCount > 0 )
            resultItem.AmmoCount = 0;

		resultItem.Update();
		InitRandomisationItem( resultItem, true, player, "" );
	}

    // Плюс к статистике
    ChangePlayerScore( player, SCORE_CRAFTER, craftCount );
    switch( proto.CraftInfo )
    {
    case IN_LEATHER_ARMOR:
        player.IndustrialBase[ IN_LEATHER_ARMOR_SCORE ] += craftCount;
        break;
    case IN_METALL_ARMOR:
        player.IndustrialBase[ IN_METALL_ARMOR_SCORE ] += craftCount;
        break;
    case IN_COMBAT_ARMOR:
        player.IndustrialBase[ IN_COMBAT_ARMOR_SCORE ] += 2 * craftCount;
        break;
    case IN_POWER_ARMOR:
        player.IndustrialBase[ IN_POWER_ARMOR_SCORE ] += 3 * craftCount;
        break;
    case IN_UNARMED_WEAPON:
        player.IndustrialBase[ IN_UNARMED_WEAPON_SCORE ] += craftCount;
        break;
    case IN_SMALL_WEAPON:
        player.IndustrialBase[ IN_SMALL_WEAPON_SCORE ] += craftCount;
        break;
    case IN_BIG_WEAPON:
        player.IndustrialBase[ IN_BIG_WEAPON_SCORE ] += craftCount;
        break;
    case IN_ENERGY_WEAPON:
        player.IndustrialBase[ IN_ENERGY_WEAPON_SCORE ] += craftCount;
        break;
    default:
        break;
    }

    // Сообщение о удачном крафте
    player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_FIX_SUCCESS );

    // Опыт
    player.StatBase[ ST_EXPERIENCE ] += ( ( info.Exp * craftCount ) * ( 100 + player.Industrial[ IN_ADV_CRAFT_EXP ] * 5 ) ) / 100;

    // Начисление таймаутов
    player.TimeoutBase[ TO_SK_REPAIR ] = player.Timeout[ TO_SK_REPAIR ] + __FullSecond + REAL_SECOND( info.Timeout * craftCount * 100 / ( player.Industrial[ IN_FAST_PRODUCTION ] * 5 + 100 ) );
    player.TimeoutBase[ TO_SK_SCIENCE ] = player.Timeout[ TO_SK_SCIENCE ] + __FullSecond + REAL_SECOND( info.Timeout * craftCount * 100 / ( player.Industrial[ IN_FAST_PRODUCTION ] * 5 + 100 ) );
    player.StatBase[ ST_LAST_CRAFT_TIME ] = __Second;
    // Всякая хуета
    if( info.ResultItem == PID_JUICE )
    {
        player.AddItem( PID_INTESTINES_DRY, craftCount );
    }
    else if( info.ResultItem == PID_STIMPAK )
    {
        player.AddItem( PID_RAGS, 3 * craftCount );
    }
    else if( info.ResultItem == PID_BOOZE )
    {
        player.AddItem( PID_BOTTLE_EMPTY, 3 * craftCount );
    }
}

// Дебаг. получение нужного чертежа в свой инвентарь
void addBp( Critter& cr, int pid, int count, int var )
{
    addBlueprint( cr, pid, count );
}

void /* unsafe_ */ addFix( Critter& player, int pos, int, int, string@, int[] @ )
{
    // AddComponents( player, pos, 1 );
}

void AddComponents( Critter& cr, int num, int count )
{
	if( CraftList[ num ].VarNum != 0 )
        addBlueprint( cr,  CraftList[ num ].ResultItem, count );

    for( uint i = 0; i < CraftList[ num ].Tools.length(); i++ )
        for( uint j = 0; j < CraftList[ num ].Tools[ i ].length(); j++ )
            cr.AddItem( CraftList[ num ].Tools[ i ][ j ], 1 );

    for( uint i = 0; i < CraftList[ num ].Components[ 0 ].length(); i++ )
        for( int j = 0, jMax = CraftList[ num ].Components[ 0 ][ i ].length(); j < jMax; j++ )
        {
            uint16 pid = CraftList[ num ].Components[ 0 ][ i ][ j ];
            if( pid > CRAFT_OFFSET )
            {
                pid -= CRAFT_OFFSET;
                cr.AddItem( CraftList[ pid ].ResultItem, CraftList[ num ].Components[ 1 ][ i ][ j ] * count );
            }
            else cr.AddItem( pid, CraftList[ num ].Components[ 1 ][ i ][ j ] * count );
        }
}

// Получение всех компонентов и навыков для крафта
// ~run fix_boy addCi 12 2 0
void addCi( Critter& cr, int num, int count, int )
{
   AddComponents( cr, num, count );

    for( uint i = 0; i < CraftList[ num ].Skills[ 0 ].length(); i++ )
        for( int j = 0, jMax = CraftList[ num ].Skills[ 0 ][ i ].length(); j < jMax; j++ )
            if( cr.ParamBase[ CraftList[ num ].Skills[ 0 ][ i ][ j ] ] < int( CraftList[ num ].Skills[ 1 ][ i ][ j ] ) ) 
				cr.ParamBase[ CraftList[ num ].Skills[ 0 ][ i ][ j ] ] = CraftList[ num ].Skills[ 1 ][ i ][ j ];
}

// Проверка, что рядом с игроком находится станок для производства того или иного итема
// pidWorkbench - код прототипа элемента Scenery, который играет роль станка
// radius - максимальное расстояние до станка, в котором должен находиться игрок
bool CheckWorkbenchNearPlayer( Critter& player, int pidWorkbench, int radius )
{
    Map @ map = player.GetMap();
    if( !valid( map ) )
        return false;
    Scenery@[] wb;
    if( map.GetSceneries( player.HexX, player.HexY, radius, pidWorkbench, wb ) < 1 )
        return false;
    return true;
    /*for(uint i=0, iMax=wb.length(); i<iMax; i++)
       {
            uint16 Hx=wb[i].HexX, Hy=wb[i].HexY;
            Log("x="+Hx+" y="+Hy);
            map.GetHexCoordWall(player.HexX, player.HexY, Hx, Hy, 0, radius);
            if(Hx==wb[i].HexX && Hy==wb[i].HexY)
                    return true;
                    Log("x="+Hx+" y="+Hy);
       }
       return false;*/
}

// uint16[] workbenchsItem=	 {PID_WORKBENCH_INV, PID_MANUFACT_LATHE_INV, PID_MANUFACT_AMMO1_INV, PID_MANUFACT_AMMO2_INV, PID_MANUFACT_AMMO3_INV, PID_MULTICRAFT_INV, PID_PROD_PLANT1_INV,           PID_PROD_PLANT2_INV,	  PID_PWRARMOR_PARTS, PID_FIREPIT_INV, PID_WORKBENCH_INV_SHOE, PID_WORKBENCH_INV_HUB, PID_SAMOGON_INV, PID_SAMOGON_ALL_INV};
// uint16[] workbenchsScenery={SCENERY_WORKBENCH, SCENERY_LATHE,			 SCENERY_AMMO_PRESS,	 SCENERY_AMMO_PRESS_MID, SCENERY_AMMO_PRESS_HIGH,SCENERY_MULTICRAFT, SCENERY_PRODUCTION_PLANT1, SCENERY_PRODUCTION_PLANT2,SCENERY_PWRARMOR,	  SCENERY_STOVE,   SCENERY_SHOE_WORKBENCH, SCENERY_HUB_WORKBENCH, PID_SAMOGON, PID_SAMOGON_ALL};
bool s_FixBoy( Critter& player, Scenery& scenery, int skill, Item@ item )
{
    if( skill == -1 && not valid( item ) )
    {
        player.RunClientScript( "fix_boy@ShowFixBoyScreen", scenery.ProtoId, 0, 0, null, null );
        return true;
    }
    return false;
}

// Показать чертеж и станок в фиксбоксе клиента
void unsafe_setBp( Critter& player, int varNum, int, int, string@, int[] @ )
{
    int blueprintResult = 0;

    if( varNum > 0 )
    {
        GameVar@ var = GetLocalVar( varNum, player.Id );
        if( valid( var ) )
            blueprintResult = var.GetValue();
    }

    player.RunClientScript( "fix_boy@_setBp", blueprintResult, 0, 0, null, null );
}

#endif // !__CLIENT

#include "_craftInfo.fos"
craftInfo@[] CraftList;

#ifdef __CLIENT
import void LoadCraftList( craftInfo@[]& out CraftList ) from "gen_craft_table";

void CraftInit()
{
    uint tick = GetTick();
    LoadCraftList( CraftList );
    ClearLog( "FixBoy Loading complited ( " + ( GetTick() - tick ) + "ms )." );
}
#endif
#ifdef __SERVER
CCraftInit cci;

class CCraftInit
{
    CCraftInit()
    {
        // Log("Start");
        # include "craft_table.fos"
        uint tick = GetTick();
        file f;
        if( f.open( "scripts\\gen_craft_table.fos", "w" ) != -1 )
        {
            f.writeString( "#include \"_craftInfo.fos\"\n" );
            f.writeString( "void LoadCraftList( craftInfo@[]&out CraftList )\n{\n\t" );
            f.writeString( "CraftList.resize( " + TABLE_SIZE + " );\n\t" );
            f.writeString( "craftInfo@ ci = null;\n\t" );

            for( uint i = 0; i < TABLE_SIZE; i++ )
            {
                craftInfo@ ci = CraftList[ i ];
                if( valid( ci ) )
                {
                    ci.SaveGeneric( i, f );
                }
            }
            f.writeString( "\n}" );
            f.close();

            // Log("Okay");
        }
        ClearLog( "Generation client craft list: " + ( GetTick() - tick ) + "ms." );
    }
}
#endif
/*
   void _SetupCraft(uint16 resultItem, uint16 count, uint16 varNum, uint16 workbench,  uint16[][] tools, uint16[][][] components, uint16[][][] skills, uint16 exp, uint16 timeout, uint16 minLvl=1)
   {
        craftInfo ci;
        ci.Set(resultItem,
        count,
        varNum,
        workbench, tools, components, skills, exp, timeout, minLvl);

        CraftList.insertLast(@ci);
   }*/

// / Client
#ifdef __CLIENT

# include "_client_defines.fos"
# include "client_gui_h.fos"
# include "_colors.fos"
# include "_msgstr.fos"

// Именованые константы подокон (окно в игре одно, но оно переинициализируется при переключении)
# define SC_FIX_LIST_FIX             ( 0 )                              // Список крафта. Это начальное окно с списком предметов, которые можно скрафтить
# define SC_FIX_ITEM_FIX             ( 1 )                              // Крафта предмета. То, в котором выбраный предмет непосредственно крафтится
# define SC_FIX_DECRAFT              ( 2 )                              // Декрафта
# define SC_FIX_REPAIR               ( 3 )                              // Ремонт
# define SC_FIX_LIST_UPGRADE         ( 4 )                              // Апгрейд список предметов для выбора
# define SC_FIX_ITEM_UPGRADE         ( 5 )                              // Апгрейд итема
# define SC_FIX_STAT                 ( 6 )                              // Статистика

# define CLASSICAL_VISIBILITY        ( 85 )                                       // Процент одного из навыков, при котором рецепт становится видим в классическом отображении

// Импорт функций
import bool GetIfaceColor( string& key, uint& color ) from "client_main";                    // Возвращает значения цветности RGB каналов, в виде массива с трех элементов.
import string  item_description( ItemCl& item, int lookType ) from "client_main"; // Возвращает значения цветности RGB каналов, в виде массива с трех элементов.
import void    ClearLexemsItem( int itId ) from "client_main";

craftInfo@[] visibleClientCraftList;
int  curListId = -1; // TabaK. Хранит Id итема для декрафта, для которого последним была вызвана отрисовка компонента. Некрасиво, но пусть.
uint CurUpdateItemId = 0;

// Указатели на общие элементы окна крафта
IGUIElementOpt@ han_fixbox;                             // Листбокса
IGUIElementOpt@ han_scrollbar;                          // Скроллбара
IGUIElementOpt@ han_scrollup;                           // Кнопки листания списка вверх..
IGUIElementOpt@ han_scrolldown;                         // ..и вниз

IGUIElementOpt@ han_FixEmbl;

// Указатели на фильтры по типам предметов
IGUIElementOpt@ han_filtrWeapon;            // Оружия
IGUIElementOpt@ han_filtrArmor;             // Брони
IGUIElementOpt@ han_filtrAmmo;              // Патронов
IGUIElementOpt@ han_filtrMisc;              // Разного
IGUIElementOpt@ han_filtrCustom;            // Избраного

// Указатели на элементы окна декрафта
IGUIElementOpt@ han_DecraftItem;            // Изображения разбираемого предмета
IGUIElementOpt@ han_FixComponentsDecraft;   // Изображения компонентов разбираемого предмета

// Крафт
IGUIElementOpt@ han_FixRun;
IGUIElementOpt@ han_DesText;
IGUIElementOpt@ han_CraftItem;
IGUIElementOpt@ han_FixComponentsTitle;
IGUIElementOpt@ han_FixComponentsCraft;
IGUIElementOpt@ han_FixTools;
IGUIElementOpt@ han_FixSkills;
IGUIElementOpt@ han_Blueprint;
IGUIElementOpt@ han_CountUp;
IGUIElementOpt@ han_CountDown;
IGUIElementOpt@ han_Count;
IGUIElementOpt@ han_CountText;
IGUIElementOpt@ han_Workbench;
IGUIElementOpt@ han_FixSaveRecipe;

// Указатели на элементы опций подокна крафта
IGUIElementOpt@ han_FixClassicVisible;                  // Классическое отображение видимости предметов
IGUIElementOpt@ han_FixComponentsOfMouseMove;           // Переход по компонентам, посредством движения миши

// Кнопки перехода между страницами крафта
IGUIElementOpt@ han_GetForward;
IGUIElementOpt@ han_GetBack;

// Булевые переменные, которые означают включен ли тот или иной фильтр по типам предметов
// *по нормальному, то такой подход стоит заменить нормальным элементом "чекбокс", но за неимением такового - это его симуляция.
bool fWeapon = true;                                                      // Оружия
bool fArmor = true;                                                       // Брони
bool fAmmo = true;                                                        // Патронов
bool fMisc = true;                                                        // Разного
bool fCustom = true;                                                      // Избраного

// элементы опций подокна крафта
bool   isFixComponentsOfMouseMove = true;
bool   isFixClassicVisible = true;

uint8  screenStat = 0;                                                  // Номер текущего подокна (смотри выше именованные константы подокон)
uint16 curCraftPos = 0;
uint8  craftCount = 1;
uint16[] workbenchsId;

// Списки перехода вперёд и назад по страницам крафта
uint16[] toBackList;
uint16[] toForwardList;

int[] saveList;

uint[] CritterInvenItemsId;                             // Массив айди предметов, которые есть у игрока в инвентаре и их нужно отобразить на текущий момент
uint16[] componentsPos;                                 // Цвет текста, если действие невозможно или маловозможно

// Параметры отображения интерфейса, которые должны загружаться с default.ini
int    fontNumber = FONT_FALLOUT;                       // Номер шрифта интерфейса
string filtrDown;                                       // Название файла с изображением нажатой кнопки "фильтр вниз"
string filtrUp;                                         // Название файла с изображением нажатой кнопки "фильтр вверх"
uint FixTextColor;                                   // Цвет текста по умолчанию
uint FixTextActiveColor;                             // Цвет активного текста
uint FixTextDownColor;                               // Цвет текста при нажатии
uint FixTextFixNotValid;                             // Цвет текста, если действие невозможно или маловозможно

void ShowFixBoy()
{
    CritterCl@ chos = GetChosen();
    if( !valid( chos ) )
        return;
    int[] wbsId;
    if( checkWorkbenchInRadius( SCENERY_WORKBENCH, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_WORKBENCH );
    if( checkWorkbenchInRadius( SCENERY_AMMO_PRESS, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_AMMO_PRESS );
    if( checkWorkbenchInRadius( SCENERY_LATHE, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_LATHE );
    if( checkWorkbenchInRadius( SCENERY_STOVE, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_STOVE );
    if( checkWorkbenchInRadius( SCENERY_AMMO_PRESS_MID, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_AMMO_PRESS_MID );
    if( checkWorkbenchInRadius( SCENERY_AMMO_PRESS_HIGH, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_AMMO_PRESS_HIGH );
    if( checkWorkbenchInRadius( SCENERY_MULTICRAFT, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_MULTICRAFT );
    if( checkWorkbenchInRadius( SCENERY_PRODUCTION_PLANT1, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_PRODUCTION_PLANT1 );
    if( checkWorkbenchInRadius( SCENERY_PRODUCTION_PLANT2, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_PRODUCTION_PLANT2 );
    if( checkWorkbenchInRadius( SCENERY_SAMOGON, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_SAMOGON );
    if( checkWorkbenchInRadius( SCENERY_SAMOGON_ALL, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_SAMOGON_ALL );
    if( checkWorkbenchInRadius( SCENERY_FIRE, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_FIRE );
    if( checkWorkbenchInRadius( SCENERY_PWRARMOR, chos.HexX, chos.HexY, DEFAULT_RADIUS ) )
        wbsId.insertLast( SCENERY_PWRARMOR );

    workbenchsId.resize( 0 );

    // if(wbsId.length()==0)
    //	return;

    for( uint16 i = 0, iMax = wbsId.length(); i < iMax; i++ )
        workbenchsId.insertLast( wbsId[ i ] );

    ShowFixBoyScreen( 0, 0, 0, null, wbsId );
}

// EXPORT
// Запуск окна крафта с клиента
void ShowFixBoyScreen( int wbId, int, int, string@, int[] @ wbsId )
{
    if( wbId != 0 )
    {
        workbenchsId.insertLast( wbId );
        // return;
    }

    SafeStrToInt( GetIfaceIniStr( "FixFont" ), fontNumber );
    ShowScreen( CLIENT_SCREEN_NEW_FIX_BOY, 0, 0, 0 );
}

// =====================
// ВСПОМАГАТЕЛЬНЫЕ ФУНКЦИИ
// =====================

void setPic( uint16 pid, uint16 width, uint16 hiegth, IGUIElementOpt@ han )
{
    const ProtoItem@ proto = GetProtoItem( pid );
    if( !valid( proto ) )
        return;
    han.Picture( proto.PicInv, 0 );
    han.PictureSize( width, hiegth );
}

void setPic( uint hash, uint16 width, uint16 hiegth, IGUIElementOpt@ han )
{
    han.Picture( hash, 0 );
    han.PictureSize( width, hiegth );
}

uint getPicHash( uint16 pid )
{
    const ProtoItem@ proto = GetProtoItem( pid );
    if( !valid( proto ) )
        return 0;
    return proto.PicInv;
}


// Заполнение листбокса переданым текстом, где:
// listText - строка, которую нужно поместить в фиксбой
void FillListbox( string listText, uint[] textMultiColor )
{
    // Заполняем листбокс переданой строкой
    han_fixbox.Text( listText, fontNumber, FixTextColor, textMultiColor, FixTextActiveColor, FT_NOBREAK );

    // Работа с скроллбарами
    // han_fixbox.SetScroll(false, 0);                                          // Устанавливаем нулевое смещение
    bool hideScroll = ( han_fixbox.GetTextScroll() < 1 );     // Проверяем, вмещается ли список в листбокс, или требуется скроллбар
    han_scrollbar.ToHide( hideScroll );                       // Устанавливаем видимость сроллбара, если нужно
    han_scrollup.ToHide( hideScroll );                        // Аналогично для кнопки вверх..
    han_scrolldown.ToHide( hideScroll );                      // .. и вниз
    han_scrollbar.SBSetRange( han_fixbox.GetTextScroll() );   // Устанавливаем диапазон значений для скроллбара
    // han_scrollbar.SBSetValue(han_fixbox.GetTextOffset()); // Устанавливаем положение ползунка скроллбара в соответствии со смещением списка.
    han_scrollbar.SBSetValue( han_fixbox.GetTextOffset() );   // TabaK. Нафига? В ноль его, в ноль.
}

// Функции заполнения листбокса для крафта
void FillCraftListbox()
{
    visibleClientCraftList.resize( 0 );

    string str = "";
    uint[] textMultiColor;

    for( uint16 i = 0, iMax = CraftList.length(); i < iMax; i++ )
    {
        const ProtoItem@ proto = GetProtoItem( CraftList[ i ].ResultItem );
        if( !valid( proto ) )
            continue;
        CraftList[ i ].Pos = i;
        if( !checkWorkbench( CraftList[ i ] ) || !checkSkills( CraftList[ i ] ) || !checkMaterials( CraftList[ i ] ) || !checkTools( CraftList[ i ] ) )
            CraftList[ i ].Color = FixTextFixNotValid;
        else
            CraftList[ i ].Color = FixTextColor;

        /*if(CraftList[i].Pos==104)
           {
                if(!checkWorkbench(CraftList[i]))
                        Message("checkWorkbench");
                if(!checkSkills(CraftList[i]))
                        Message("checkSkills");
                if(!checkMaterials(CraftList[i]))
                        Message("checkMaterials");
                if(!checkTools(CraftList[i]))
                        Message("checkTools");
           }*/

        if( !isFixClassicVisible || checkClassicVisibleSkills( CraftList[ i ] ) )
        {
            if( !fWeapon && proto.Type == ITEM_TYPE_WEAPON )
                continue;
            if( !fArmor && proto.Type == ITEM_TYPE_ARMOR )
                continue;
            if( !fAmmo && proto.Type == ITEM_TYPE_AMMO )
                continue;
            if( !fMisc && proto.Type != ITEM_TYPE_AMMO &&  proto.Type != ITEM_TYPE_ARMOR && proto.Type != ITEM_TYPE_WEAPON )
                continue;

            visibleClientCraftList.insertLast( CraftList[ i ] );
        }
    }

    for( uint16 i = 0, iMax = visibleClientCraftList.length(); i < iMax; i++ )
    {
        const ProtoItem@ proto = GetProtoItem( visibleClientCraftList[ i ].ResultItem );
        if( !valid( proto ) )
            continue;
        bool isCustom = false;

        if( !fCustom )
        {
            for( uint16 j = 0, jMax = saveList.length(); j < jMax; j++ )
                if( uint( saveList[ j ] ) == visibleClientCraftList[ i ].Pos )
                {
                    isCustom = true;
                    break;
                }
            if( !isCustom )
                continue;
        }

        str += GetMsgStr( TEXTMSG_ITEM, visibleClientCraftList[ i ].ResultItem * 100 );
        if( visibleClientCraftList[ i ].Count > 1 )
            str += " " + ( visibleClientCraftList[ i ].Count ) + GetMsgStr( TEXTMSG_GAME, 205 ) + "\n";
        else
            str += "\n";
        textMultiColor.insertLast( visibleClientCraftList[ i ].Color );
    }

    FillListbox( str, textMultiColor );
    // FillFiltrCraftListbox();
}
/*
   void FillFiltrCraftListbox()
   {
        string str = "";
        uint[] textMultiColor;
        //craftInfo@[] visibleClientCraftList;

        for(uint16 i=0, iMax = visibleClientCraftList.length(); i<iMax; i++)
        {
                ProtoItem@ proto = GetProtoItem(visibleClientCraftList[i].ResultItem);
                if(!valid(proto)) continue;
                bool isCustom = false;

                if(!fCustom)
                {
                        for(uint16 j=0, jMax=saveList.length(); j<jMax; j++)
                                if(saveList[j]==visibleClientCraftList[i].Pos)
                                {
                                        isCustom=true;
                                        break;
                                }
                        if(!isCustom)	continue;
                }

                if(fWeapon && proto.Type==ITEM_TYPE_WEAPON)
                {
                        str+=GetMsgStr(TEXTMSG_ITEM, visibleClientCraftList[i].ResultItem*100);
                        if(visibleClientCraftList[i].Count>1) str+= " " + (visibleClientCraftList[i].Count) + " шт.\n";
                        else str+="\n";
                        textMultiColor.insertLast(visibleClientCraftList[i].Color);
                        continue;
                }

                if(fArmor && proto.Type==ITEM_TYPE_ARMOR)
                {
                        str+=GetMsgStr(TEXTMSG_ITEM, visibleClientCraftList[i].ResultItem*100);
                        if(visibleClientCraftList[i].Count>1) str+= " " + (visibleClientCraftList[i].Count) + " шт.\n";
                        else str+="\n";
                        textMultiColor.insertLast(visibleClientCraftList[i].Color);
                        continue;
                }

                if(fAmmo && proto.Type==ITEM_TYPE_AMMO)
                {
                        str+=GetMsgStr(TEXTMSG_ITEM, visibleClientCraftList[i].ResultItem*100);
                        if(visibleClientCraftList[i].Count>1) str+= " " + (visibleClientCraftList[i].Count) + " шт.\n";
                        else str+="\n";
                        textMultiColor.insertLast(visibleClientCraftList[i].Color);
                        continue;
                }

                if(fMisc && proto.Type!=ITEM_TYPE_AMMO &&  proto.Type!=ITEM_TYPE_ARMOR && proto.Type!=ITEM_TYPE_WEAPON)
                {
                        str+=GetMsgStr(TEXTMSG_ITEM, visibleClientCraftList[i].ResultItem*100);
                        if(visibleClientCraftList[i].Count>1) str+= " " + (visibleClientCraftList[i].Count) + " шт.\n";
                        else str+="\n";
                        textMultiColor.insertLast(visibleClientCraftList[i].Color);
                }
        }

        FillListbox(str, textMultiColor);
   }*/

// Функция заполнения листбокса для декрафта
void FillDeCraftListbox( uint exceptId = 0 ) // TabaK. Временный костыль для удаления предмета из списка при декрафте(синхронизация тормозит)
{
    uint[] textMultiColor;
    CritterCl@ chosen = GetChosen();
    if( !valid( chosen ) )
        return;
    ItemCl@[] items;
    string listText = "";

    // Получаем предметы, которые лежат у чузена в инвентаре, учитывая нажатые фильтры
    if( fWeapon )
        chosen.GetItemsByType( ITEM_TYPE_WEAPON, items );
    if( fArmor )
        chosen.GetItemsByType( ITEM_TYPE_ARMOR, items );
    if( fAmmo )
        chosen.GetItemsByType( ITEM_TYPE_AMMO, items );
    if( fMisc )
        chosen.GetItemsByType( ITEM_TYPE_MISC, items );

    uint16 itemsLength = items.length();
    // CritterInvenItemsId.resize(itemsLength);		// Задаем размер массиву айди предметов игрока
    CritterInvenItemsId.resize( 0 );   // TabaK. Сбросил до нуля. Не все содержимое инвентаря попадает в список - сбиваются индексы.
    // В цикле записываем айди и названия нужных предметов
    for( uint16 i = 0; i < itemsLength; i++ )
    {
        if( not isItPossibleToDecraft( items[ i ] ) || items[ i ].Id == exceptId || items[ i ].CritSlot != SLOT_INV )
            continue;

        // CritterInvenItemsId[i]=items[i].Id;	// Записываем айди всех предметов
        CritterInvenItemsId.insertLast( items[ i ].Id );
        listText += FormatTags( GetMsgStr( TEXTMSG_ITEM, items[ i ].GetProtoId() * 100 + items[ i ].Info ), items[ i ].Lexems ) + "\n"; // Синхронно с айди, записываем их названия
    }
    FillListbox( listText, textMultiColor );                                                                                            // Заполняем листбокс полученным текстом
    if( valid( han_DecraftItem ) && valid( han_FixComponentsDecraft ) )
    {
        uint[] hashs;
        string[] texts;
        han_DecraftItem.Picture( 0, 0 );
        han_FixComponentsDecraft.Text( "", FONT_FALLOUT, FixTextColor, FixTextColor, FT_CENTERX | FT_ALIGN );
        han_FixComponentsDecraft.MultiPicture( hashs, 0, 40, 40, 25, 15, 3, 0 );
        han_FixComponentsDecraft.MultiText( texts, fontNumber, 40, 65, 55, 3, 5, FixTextColor, FT_NOBREAK );
    }
}

ItemCl@ GetItemByPos( uint pos )
{
    CritterCl@ chosen = GetChosen();
    if( !valid( chosen ) ) return null;
	
    ItemCl@[] items;
    // Получаем предметы, которые лежат у чузена в инвентаре, учитывая нажатые фильтры
    if( fWeapon )	chosen.GetItemsByType( ITEM_TYPE_WEAPON, items );
    if( fArmor ) 	chosen.GetItemsByType( ITEM_TYPE_ARMOR, items );
    if( fAmmo ) 	chosen.GetItemsByType( ITEM_TYPE_AMMO, items );
    if( fMisc ) 	chosen.GetItemsByType( ITEM_TYPE_MISC, items );

    for( uint16 i = 0, iEnd = items.length(); i < iEnd; i++ )
        if( ( ( FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_0 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_0_BUSSY ) ) || ( FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_1 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_1_BUSSY ) ) || ( FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_2 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_2_BUSSY ) ) ) && items[ i ].CritSlot == SLOT_INV )
            if( pos-- == 0 ) return items[ i ];
	
    return null;
}

void FillUpdateListbox( uint curUpdateItemId = 0 )
{
    uint[] textMultiColor;
    CritterCl@ chosen = GetChosen();
    if( @chosen is null ) return;
	
    ItemCl@[] items;
    string listText = "";

    // Получаем предметы, которые лежат у чузена в инвентаре, учитывая нажатые фильтры
    if( fWeapon )	chosen.GetItemsByType( ITEM_TYPE_WEAPON, items );
    if( fArmor )	chosen.GetItemsByType( ITEM_TYPE_ARMOR, items );
    if( fAmmo )	chosen.GetItemsByType( ITEM_TYPE_AMMO, items );
    if( fMisc )	chosen.GetItemsByType( ITEM_TYPE_MISC, items );

    CritterInvenItemsId.resize( 0 );   // TabaK. Сбросил до нуля. Не все содержимое инвентаря попадает в список - сбиваются индексы.
    ItemCl@ curItem = null;
    for( uint16 i = 0, iEnd = items.length(); i < iEnd; i++ )
        if( curUpdateItemId == 0 )
        {
            if( @items[ i ] !is null && ( ( FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_0 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_0_BUSSY ) ) || ( FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_1 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_1_BUSSY ) ) || ( FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_2 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_2_BUSSY ) ) ) && items[ i ].CritSlot == SLOT_INV )
            {
                CritterInvenItemsId.insertLast( items[ i ].Id );
                listText += FormatTags( GetMsgStr( TEXTMSG_ITEM, items[ i ].GetProtoId() * 100 + items[ i ].Info ), items[ i ].Lexems ) + "\n";  // Синхронно с айди, записываем их названия
            }
        }
        else if( @curItem !is null )
        {
			if( curItem.Id != items[ i ].Id )
				if( !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_0 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_1 ) && !FLAG( items[ i ].CraftFlags, CF_UPGRADE_SLOT_2 ) && items[ i ].CritSlot == SLOT_INV )
            {
                UpgradeItem::UpgradeDescriptor@ itemDescriptor = cast< UpgradeItem::UpgradeDescriptor@ >( @curItem.ScriptDescriptor ),
											updateDescriptor = cast< UpgradeItem::UpgradeDescriptor@ >( @items[ i ].ScriptDescriptor );
				if( @itemDescriptor is null || @updateDescriptor is null )
				{
					Log( "Error upgrade. Descriptor no valide");
					continue;
				}

                if( itemDescriptor.IsUpgrade( curItem, items[ i ] ) || updateDescriptor.IsUpgrade( curItem, items[ i ] ) )
                {
                    CritterInvenItemsId.insertLast( items[ i ].Id );
                    listText += FormatTags( GetMsgStr( TEXTMSG_ITEM, items[ i ].GetProtoId() * 100 + items[ i ].Info ), items[ i ].Lexems ) + "\n";      // Синхронно с айди, записываем их названия
                }
            }			
        }
        else if( @items[ i ] !is null && items[ i ].Id == curUpdateItemId )
        {
            @curItem = items[ i ];
            i = 0;
        }

    FillListbox( listText, textMultiColor );    // Заполняем листбокс полученным текстом
    CurUpdateItemId = curUpdateItemId;
}

// Отрисовать иконку предмета через конский зад(нормальный способ не работал в следствие бага СДК, но я уже забыл в чем он состоял)
// Отрисовать предметы и их количества
uint16 GetIndexByPidCl( uint16 pid )
{
    for( uint16 i = 0, iMax = CraftList.length(); i < iMax; i++ )       // находим в таблице по пиду.
        if( pid == CraftList[ i ].ResultItem )
            return i;

    return uint16( -1 );        // Нет в таблице
}

// До лучших времен. // TabaK. Время лучших времен блеать!
void decraftComponentPic( uint id )
{
    // if(curListId==id) return;
    curListId = id;
    ItemCl@[] items;
    uint16     pid;
    CritterCl@ chosen = GetChosen();
    if( !valid( chosen ) )
        return;
    chosen.GetItemsByType( ITEM_TYPE_ARMOR, items );
    chosen.GetItemsByType( ITEM_TYPE_WEAPON, items );
    chosen.GetItemsByType( ITEM_TYPE_AMMO, items );

    ItemCl@ item;
    // Отрисовка данного предмета
    for( uint16 i = 0; i < items.length(); i++ )
        if( items[ i ].Id == id )
        {
            pid = items[ i ].GetProtoId();
            @item = items[ i ];
            han_DecraftItem.Picture( items[ i ].Proto.PicInv, 0 );
            break;
        }

    uint[] hashs;
    string[] texts;

    uint16 index = GetIndexByPidCl( pid );

    if( index > CraftList.length() )
        return;
    craftInfo ci = CraftList[ index ];


    int              maxRepairCount = ( item.Proto.MaxRepairCount > 0 ) ? ( ( item.Proto.MaxRepairCount + 10 ) * 10 ) : DEFAULT_MAX_REPAIR_COUNT;
    uint16           percentForDeterioration = ( item.Deterioration / 100 + item.RadioChannel ) * 100 / maxRepairCount;
    percentForDeterioration = CLAMP( percentForDeterioration, 0, 85 );
    uint16           percentComponent = ( chosen.Skill[ SK_SCIENCE ] > 125 ? 125 : chosen.Skill[ SK_SCIENCE ] ) / 3 + chosen.Industrial[ IN_REPROCESS_MASTER ] * 2;
    uint8            mode = 0;
    const ProtoItem@ protoTools = chosen.GetSlotProto( SLOT_HAND1, mode );
    if( valid( protoTools ) )
    {
        if( protoTools.ProtoId == PID_MULTI_TOOL )
            percentComponent += 10;
        else if( protoTools.ProtoId == PID_SUPER_TOOL_KIT )
            percentComponent += 20;
    }
    if( checkWorkbenchInRadius( 15571, chosen.HexX, chosen.HexY, DEFAULT_RADIUS ) )
        percentComponent += 15;

    percentComponent -= ( percentComponent * percentForDeterioration ) / 100;


    // GetDecraftComponents(ci, hashs, texts, percentComponent);

    decraftComponent[] comps;
    GetDecraftComponents( ci, comps, percentComponent );

    uint count = comps.length();

    hashs.resize( count );
    texts.resize( count );

    for( uint n = 0; n < count; n++ )
    {
        hashs[ n ] = getPicHash( comps[ n ].Pid );
        texts[ n ] = comps[ n ].Count > 0 ? ( "" + comps[ n ].Count ) : ( "0-1 (" ) + percentComponent + "%)";
    }

    han_FixComponentsDecraft.Text( GetMsgStr( TEXTMSG_GAME, 232 ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_CENTERX | FT_ALIGN );
    han_FixComponentsDecraft.MultiPicture( hashs, 0, 40, 40, 25, 15, 3, 0 );
    han_FixComponentsDecraft.MultiText( texts, fontNumber, 40, 65, 55, 3, 5, FixTextColor, FT_NOBREAK );
}

class decraftComponent // TabaK. Запилил структуру для временного хранения данных о компонентах, чтоб избежать дублей.
{
    decraftComponent( uint16 pid, uint16 count )
    {
        Count = count;
        Pid = pid;
    }
    uint16 Pid;
    uint16 Count;
}

void GetDecraftComponents( craftInfo ci, decraftComponent[]& comps, uint16 percent )
{
    for( uint16 i = 0, iMax = ci.Components[ 0 ].length; i < iMax; i++ )
        for( int j = 0, jMax = ci.Components[ 0 ][ i ].length(); j < jMax; j++ )
        {
            uint16 cPid = 0;
            uint16 cCount = 0;
            if( ci.Components[ 0 ][ i ][ j ] > CRAFT_OFFSET )
            {
                cPid = CraftList[ ci.Components[ 0 ][ i ][ j ] - CRAFT_OFFSET ].ResultItem;
            }
            else
                cPid = ci.Components[ 0 ][ i ][ j ];


            uint8 info = GetProtoItem( cPid ).CraftInfo;

            if( info == IN_DECRAFT_NO_POSYBLE )
                continue;

            bool stop = false;
            if( info != IN_SEC_DECRAFT_NO_POSYBLE )
            {
                for( uint16 k = 0, kMax = CraftList.length(); k < kMax; k++ )
                {
                    if( cPid == CraftList[ k ].ResultItem )
                    {
                        GetDecraftComponents( CraftList[ k ], comps, percent );                     // TabaK. Если компонент декрафтится - уходим в рекурсию.
                        stop = true;
                    }
                }
            }
            if( stop )
                continue;
            cCount = ci.Components[ 1 ][ i ][ j ];

            cCount = cCount * percent / 100;

            for( uint n = 0, nMax = comps.length(); n < nMax; n++ )
            {
                if( comps[ n ].Pid == cPid )
                {
                    comps[ n ].Count += cCount;
                    stop = true;
                }
            }
            if( !stop )
                comps.insertLast( decraftComponent( cPid, cCount ) );
        }
}

// Заполнение окна крафта предмета
void FillItemFixScreen( craftInfo ci )
{
    bool isSave = false;
    // Message("pid_2="+ci.ResultItem);
    for( uint16 i = 0, iMax = saveList.length(); i < iMax; i++ )
        if( ci.Pos == uint( saveList[ i ] ) )
        {
            isSave = true;
            han_FixSaveRecipe.Text( "Remove from favourites.", fontNumber, FixTextFixNotValid, FixTextDownColor, FT_CENTERX | FT_ALIGN );
            break;
        }
    if( !isSave )
        han_FixSaveRecipe.Text( GetMsgStr( TEXTMSG_GAME, 227 ), fontNumber, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN );

    setPic( ci.ResultItem, 70, 70, han_CraftItem );

    han_CraftItem.Text( GetMsgStr( TEXTMSG_ITEM, ci.ResultItem * 100 ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_CENTERX | FT_ALIGN );
    han_DesText.Text( GetMsgStr( TEXTMSG_TEXT, 120000 + ci.Pos ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_ALIGN );

    if( checkMaterials( ci ) )
        han_FixComponentsTitle.Text( GetMsgStr( TEXTMSG_GAME, 202 ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_ALIGN );
    else
        han_FixComponentsTitle.Text( GetMsgStr( TEXTMSG_GAME, 202 ), FONT_FALLOUT, FixTextFixNotValid, FixTextColor, FT_ALIGN );

    setCraftComponents();
    setTools( ci );

    string listText = "";
    uint[] textMultiColor;

    textMultiColor.resize( 0 );
    if( checkSkills( ci ) )
        textMultiColor.insertLast( FixTextColor );
    else
        textMultiColor.insertLast( FixTextFixNotValid );

    listText = GetMsgStr( TEXTMSG_GAME, 200 ) + "\n";
    CritterCl@ cr = GetChosen();
    if( !valid( cr ) )
        return;
    for( uint16 i = 0, iMax = ci.Skills[ 0 ].length(); i < iMax; i++ )
    {
        for( int j = 0, jMax = ci.Skills[ 0 ][ i ].length(); j < jMax; j++ )
        {
            if( ci.Skills[ 0 ][ i ].length() > 0 && j != jMax - 1 )
                listText += GetMsgStr( TEXTMSG_GAME, 229 );
            listText += GetMsgStr( TEXTMSG_GAME, ci.Skills[ 0 ][ i ][ j ] * 10 + 100001 ) + " " + ci.Skills[ 1 ][ i ][ j ] + "% (" + GetMsgStr( TEXTMSG_GAME, 206 ) + cr.Param[ ci.Skills[ 0 ][ i ][ j ] ] + "%)" + "\n";

            if( !checkSkill( ci.Skills[ 0 ][ i ][ j ], ci.Skills[ 1 ][ i ][ j ] ) )
                textMultiColor.insertLast( FixTextFixNotValid );
            else
                textMultiColor.insertLast( FixTextColor );
        }
    }

    int skillY = NoTools( ci ) ? han_FixComponentsCraft.GetPosY() + ci.Components[ 0 ].length() * 12 : han_FixTools.GetPosY() + ci.Tools.length() * 12;
    han_FixSkills.Position( han_FixSkills.GetPosX(), skillY + ( han_FixTools.GetPosY() < 280 ? 35 : 15 ) );
    han_FixSkills.ListBoxFocused( false );
    han_FixSkills.Text( listText, FONT_FALLOUT, FixTextColor, textMultiColor, FixTextColor, FT_NOBREAK );

    setBlueprint( ci );
    setWorkbench( ci );
}

void FillItemInfoScreen( uint16 infoPid )
{
    setPic( infoPid, 75, 58, han_CraftItem );
    han_CraftItem.Text( GetMsgStr( TEXTMSG_ITEM, infoPid * 100 ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_CENTERX | FT_ALIGN );
    string des = GetMsgStr( TEXTMSG_TEXT, infoPid + 110000 );
    if( GetMsgStr( TEXTMSG_TEXT, infoPid + 110000 ) == "error" )
        des = GetMsgStr( TEXTMSG_GAME, 231 );
    han_DesText.Text( GetMsgStr( TEXTMSG_ITEM, ( infoPid * 100 ) + 1 ) + "\n----------------------------\n" + des, FONT_FALLOUT, FixTextColor, FixTextColor, FT_ALIGN );
}

void ClearItemInfoScreen()
{
    craftInfo ci = CraftList[ curCraftPos ];
    setPic( ci.ResultItem, 70, 70, han_CraftItem );
    han_CraftItem.Text( GetMsgStr( TEXTMSG_ITEM, ci.ResultItem * 100 ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_CENTERX | FT_ALIGN );
    han_DesText.Text( GetMsgStr( TEXTMSG_TEXT, ci.Pos + 120000 ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_ALIGN );
}

// Проверка способности игрока декрафтить предмет
bool isItPossibleToDecraft( ItemCl@ item )
{
    uint16 index = GetIndexByPidCl( item.GetProtoId() );
    if( index > CraftList.length() )
        return false;

    if( item.Proto.CraftInfo == IN_SEC_DECRAFT_NO_POSYBLE || item.Proto.CraftInfo == IN_DECRAFT_NO_POSYBLE )
        return false;

    return true;
}

// Проверка чертежа и станка
void setBlueprint( craftInfo ci )
{
    if( ci.VarNum == 0 )
    {
        han_Blueprint.ToHide( true );
        return;
    }

    han_Blueprint.ToHide( false );
    han_Blueprint.Position( han_FixSkills.GetPosX() + 40, han_FixSkills.GetPosY() + ci.Skills[ 0 ].length() * 15 + ( han_FixSkills.GetPosY() < 350 ? 40 : 25 ), 280, 150 );
    RunServerScriptUnsafe( "fix_boy@unsafe_setBp", ci.VarNum, 0, 0, "", null );
    return;
}

// Установка чертежа
void _setBp( int countBp, int, int, string@, int[] @ )
{
    if( countBp > 0 )
    {
        if( countBp == 100 )
            han_Blueprint.Text( GetMsgStr( TEXTMSG_GAME, 219 ) + "\n" + GetMsgStr( TEXTMSG_GAME, 220 ), FONT_FALLOUT, FixTextColor, FixTextColor, FT_NOBREAK );
        else
            han_Blueprint.Text( GetMsgStr( TEXTMSG_GAME, 219 ) + "\n" + GetMsgStr( TEXTMSG_GAME, 221 ) + countBp, FONT_FALLOUT, FixTextColor, FixTextColor, FT_NOBREAK );
        han_Blueprint.Picture( "Blueprint2.png", int(PT_ART_INVEN) );
    }
    else
    {
        han_Blueprint.Text( GetMsgStr( TEXTMSG_GAME, 214 ), FONT_FALLOUT, FixTextFixNotValid, FixTextColor, FT_NOBREAK );
        han_Blueprint.Picture( "Blueprint1.png", int(PT_ART_INVEN) );
    }
}

void setWorkbench( craftInfo ci )
{
    if( ci.Workbench == 0 )
    {
        han_Workbench.ToHide( true );
        return;
    }

    if( ci.VarNum != 0 )
        han_Workbench.Position( han_Blueprint.GetPosX() + 250, han_Blueprint.GetPosY() - 20, 150, 150 );
    else
        han_Workbench.Position( han_FixSkills.GetPosX() + 40, han_FixSkills.GetPosY() + ci.Skills[ 0 ].length() * 15 + ( han_FixSkills.GetPosY() < 350 ? 40 : 25 ) + 35 );

    han_Workbench.ToHide( false );

    const ProtoItem@ proto = GetProtoItem( ci.Workbench );
    if( valid( proto ) )
        setPic( proto.PicMap, 80, 80, han_Workbench );

    han_Workbench.Text( GetMsgStr( TEXTMSG_GAME, 222 ) + "\n" + GetMsgStr( TEXTMSG_ITEM, ci.Workbench * 100 ), FONT_FALLOUT, FixTextFixNotValid, FixTextColor, FT_ALIGN );

    if( checkWorkbench( ci ) )
    {
        han_Workbench.Font( FONT_FALLOUT, FixTextColor );
        return;
    }

    han_Workbench.Font( FONT_FALLOUT, FixTextFixNotValid );
}

bool NoTools( craftInfo ci )
{
    if( ci.Tools.length() < 1 || ci.Tools[ 0 ].length() < 1 || ci.Tools[ 0 ][ 0 ] == 0 )
        return true;
    return false;
}

void setTools( craftInfo ci )
{
    uint[] textMultiColor;
    if( NoTools( ci ) )
    {
        han_FixTools.Text( "", FONT_FALLOUT, FixTextColor, textMultiColor, FixTextColor, FT_NOBREAK );
        return;
    }

    string listText = GetMsgStr( TEXTMSG_GAME, 201 ) + "\n";
    uint[] hashs;
    textMultiColor.insertLast( FixTextColor );
    for( uint i = 0, iMax = ci.Tools.length(); i < iMax; i++ )
    {
        bool toolsValid = false;
        for( uint j = 0, jMax = ci.Tools[ i ].length(); j < jMax; j++ )
        {
            listText += GetMsgStr( TEXTMSG_ITEM, ci.Tools[ i ][ j ] * 100 );
            if( ci.Tools[ i ].length() > 1 && j != jMax - 1 )
                listText += GetMsgStr( TEXTMSG_GAME, 229 );

            if( !toolsValid && checkItem( ci.Tools[ i ][ j ], 1 ) )
                toolsValid = true;

            hashs.insertLast( getPicHash( ci.Tools[ i ][ j ] ) );
        }

        if( toolsValid )
            textMultiColor.insertLast( FixTextColor );
        else
        {
            textMultiColor[ 0 ] = FixTextFixNotValid;
            textMultiColor.insertLast( FixTextFixNotValid );
        }

        listText += "\n";
    }

    han_FixTools.Position( han_FixTools.GetPosX(), han_FixComponentsCraft.GetPosY() + ci.Components[ 0 ].length() * 12 + ( ci.Tools.length() < 4 ? 25 : 5 ) );
    han_FixTools.MultiPicture( hashs, 0, 40, 40, 2, 0, 12, 0 );
    han_FixTools.MultiPictureFrame( 230, ( han_FixTools.GetPosY() < 250 ? -3 : 15 ) );
    han_FixTools.Text( listText, FONT_FALLOUT, FixTextColor, textMultiColor, FixTextColor, FT_NOBREAK );
}

void setCraftComponents()
{
    craftInfo ci = CraftList[ curCraftPos ];

    uint[] hashs;
    uint16 hieght = 45;
    if( ci.Components[ 1 ].length() < 5 )
        hieght = 55;

    string listText = "";
    uint[] textMultiColor;
    componentsPos.resize( 0 );

    CritterCl@ cr = GetChosen();
    if( !valid( cr ) )
        return;
    for( uint16 i = 0; i < ci.Components[ 0 ].length(); i++ )
    {
        for( int j = 0, jMax = ci.Components[ 0 ][ i ].length(); j < jMax; j++ )
        {
            uint16 pid = 0;
            if( ci.Components[ 0 ][ i ][ j ] > CRAFT_OFFSET )
            {
                pid = CraftList[ ci.Components[ 0 ][ i ][ j ] - CRAFT_OFFSET ].ResultItem;
                // Message("ci.Components[0][i][j]="+ci.Components[0][i][j]);
            }
            else
                pid = ci.Components[ 0 ][ i ][ j ];
            /*
               if(ci.Components[1].length()!=ci.Components[0].length())
                    Message("ci="+ci.ResultItem);
               if(ci.Components[1][i].length()!=ci.Components[0][i].length())
                    Message("11111");*/


            if( checkItem( pid, ci.Components[ 1 ][ i ][ j ] * craftCount * 100 / ( cr.Param[ IN_MATERIAL_SAVINGS ] * 4 + 100 ) ) )
                textMultiColor.insertLast( FixTextColor );
            else
                textMultiColor.insertLast( FixTextFixNotValid );

            componentsPos.insertLast( ci.Components[ 0 ][ i ][ j ] );
            hashs.insertLast( getPicHash( pid ) );
            if( ci.Components[ 0 ][ i ].length() > 0 && j != 0 )
                listText += "Or ";
            listText += GetMsgStr( TEXTMSG_ITEM, pid * 100 ) + " " + ( ci.Components[ 1 ][ i ][ j ] * craftCount * 100 / ( cr.Param[ IN_MATERIAL_SAVINGS ] * 4 + 100 ) ) + GetMsgStr( TEXTMSG_GAME, 205 ) + "\n";
        }
    }

    han_FixComponentsCraft.Text( listText, FONT_FALLOUT, FixTextColor, textMultiColor, FixTextColor, FT_NOBREAK );
    han_FixComponentsCraft.MultiPicture( hashs, 0, hieght, hieght, 2, 0, 5, 0 );
    han_FixComponentsCraft.MultiPictureFrame( 230, -10 );
    han_Count.Text( "" + craftCount, FONT_THIN, FixTextColor, FixTextDownColor, FT_CENTERX );
}

bool checkWorkbench( craftInfo ci )
{
    if( ci.Workbench == 0 )
        return true;

    for( uint16 i = 0, iMax = workbenchsId.length(); i < iMax; i++ )
        if( ci.Workbench == workbenchsId[ i ] )
            return true;
    return false;
}

bool checkTools( craftInfo ci )
{
    if( ci.Tools[ 0 ][ 0 ] == 0 )
        return true;

    for( uint i = 0, iMax = ci.Tools.length(); i < iMax; i++ )
    {
        bool toolsValid = false;
        for( uint j = 0, jMax = ci.Tools[ i ].length(); j < jMax; j++ )
            if( !toolsValid && checkItem( ci.Tools[ i ][ j ], 1 ) )
                toolsValid = true;

        if( !toolsValid )
            return false;
    }

    return true;
}

bool checkSkill( uint16 skill, uint16 needValue )
{
    CritterCl@ cr = GetChosen();
    if( !valid( cr ) )
        return false;

    if( uint16( cr.Skill[ skill ] ) < needValue )
        return false;

    return true;
}

// Проверка на возможность скрафтить вещь по скиллам
bool checkSkills( craftInfo ci )
{
    for( uint16 i = 0; i < ci.Skills[ 0 ].length(); i++ )
    {
        bool isSkillOk = false;
        for( int j = 0, jMax = ci.Skills[ 0 ][ i ].length(); j < jMax; j++ )
        {
            if( checkSkill( ci.Skills[ 0 ][ i ][ j ], ci.Skills[ 1 ][ i ][ j ] ) )
                isSkillOk = true;
        }
        if( !isSkillOk )
            return false;
    }

    return true;
}

bool checkClassicVisibleSkill( uint16 skill, uint16 needValue )
{
    CritterCl@ cr = GetChosen();
    if( !valid( cr ) )
        return false;

    if( uint16( cr.Param[ skill ] * 100 / CLASSICAL_VISIBILITY ) < needValue )
        return false;

    return true;
}

bool checkClassicVisibleSkills( craftInfo ci )
{
    for( uint16 i = 0; i < ci.Skills[ 0 ].length(); i++ )
    {
        bool isSkillOk = false;
        for( int j = 0, jMax = ci.Skills[ 0 ][ i ].length(); j < jMax; j++ )
        {
            if( checkClassicVisibleSkill( ci.Skills[ 0 ][ i ][ j ], ci.Skills[ 1 ][ i ][ j ] ) )
                isSkillOk = true;
        }
        if( !isSkillOk )
            return false;
    }
    return true;
}

// Проверка наличия определённого предмета
bool checkItem( uint16 pid, uint16 needCount )
{
    CritterCl@ cr = GetChosen();

    if( !valid( cr ) )
        return false;

    if( cr.CountItem( pid ) + GetItemsHex( pid, cr.HexX, cr.HexY ) < needCount )
        return false;

    return true;
}

// Проверка на возможность скрафтить вещь по имеющимся предметам
bool checkMaterials( craftInfo& in ci )
{
    CritterCl@ cr = GetChosen();

    if( !valid( cr ) )
        return false;

    const uint ci_components_length = ci.Components.length();

    for( uint16 i = 0, iMax = ci.Components[ 0 ].length(); i < iMax; i++ )
    {
        bool componentsValid = false;
        for( uint16 j = 0, jMax = ci.Components[ 0 ][ i ].length(); j < jMax; j++ )
        {
            uint16 pid = 0;
            if( ci.Components[ 0 ][ i ][ j ] > CRAFT_OFFSET )
                pid = CraftList[ ci.Components[ 0 ][ i ][ j ] - CRAFT_OFFSET ].ResultItem;
            else
                pid = ci.Components[ 0 ][ i ][ j ];

            if( ci_components_length > 1 && checkItem( pid, ci.Components[ 1 ][ i ][ j ] ) )
            {
                componentsValid = true;
                break;
            }
        }
        if( !componentsValid )
            return false;
    }
    return true;
}


// =====================
// СОХРАНЕНИЕ ИНФОРМАЦИИ О СОСТОЯНИИ ИНТЕРФЕЙСА В ФАЙЛ
// =====================

// Чтение информации о состоянии интерфейса
void ReadFixBoyScreenInfo()
{
    file f;
    if( f.open( "data/fix.ini", "r" ) < 0 )
        if( f.open( "data/fix.ini", "r" ) < 0 )
            if( f.open( "data/fix.ini", "r" ) < 0 )
                if( f.open( "data/fix.ini", "r" ) < 0 )
                {
                    f.close();
                    return;
                }

    fWeapon = f.readUint16() > 0;
    fArmor = f.readUint16() > 0;
    fAmmo = f.readUint16() > 0;
    fMisc = f.readUint16() > 0;
    fCustom = f.readUint16() > 0;
    isFixComponentsOfMouseMove = f.readUint16() > 0;
    isFixClassicVisible = f.readUint16() > 0;

    f.readUint16();

    while( !f.isEndOfFile() )
        saveList.insertLast( f.readUint16() );

    f.close();
}

// Запись информации о состоянии интерфейса
void WriteFixBoyScreenInfo()
{
    file f;
    f.open( "data/fix.ini", "w" );

    f.writeUint16( fWeapon ? 1 : 0 );
    f.writeUint16( fArmor ? 1 : 0 );
    f.writeUint16( fAmmo ? 1 : 0 );
    f.writeUint16( fMisc ? 1 : 0 );
    f.writeUint16( fCustom ? 1 : 0 );
    f.writeUint16( isFixComponentsOfMouseMove ? 1 : 0 );
    f.writeUint16( isFixClassicVisible ? 1 : 0 );

    for( uint16 i = 0, iMax = saveList.length(); i < iMax; i++ )
        if( saveList[ i ] > 0 )
            f.writeUint16( saveList[ i ] );

    f.close();
}

// =====================
// ПЕРЕИНИЦИАЛИЗАЦИЯ ОКОН
// =====================

// Инициализация окна списка крафта
void InitFixListFix()
{
    han_FixRun.ToHide( true );
    han_FixEmbl.ToHide( false );
    han_GetBack.ToHide( false );
    han_fixbox.ToHide( false );
    han_fixbox.ClickSound( "MONITOR.ACM" );
    han_FixComponentsDecraft.ToHide( true );
    han_DecraftItem.ToHide( true );
    han_CraftItem.ToHide( true );
    han_Blueprint.ToHide( true );
    han_FixComponentsTitle.ToHide( true );
    han_FixComponentsCraft.ToHide( true );
    han_FixTools.ToHide( true );
    han_FixSkills.ToHide( true );
    han_DesText.ToHide( true );
    han_FixClassicVisible.ToHide( false );
    han_FixComponentsOfMouseMove.ToHide( false );
    toBackList.resize( 0 );
    toForwardList.resize( 0 );
    han_GetForward.ToHide( true );
    han_GetBack.ToHide( true );
    han_FixSaveRecipe.ToHide( true );

    han_CountDown.ToHide( true );
    han_CountUp.ToHide( true );
    han_Count.ToHide( true );
    han_CountText.ToHide( true );
    han_Workbench.ToHide( true );

    // FillFiltrCraftListbox();
    FillCraftListbox();

    screenStat = SC_FIX_LIST_FIX;
}

// Инициализация окна крафта предмета
void InitFixItemFix( craftInfo ci, uint16 infoPid )
{
    han_scrollbar.ToHide( true );
    han_scrollup.ToHide( true );
    han_scrolldown.ToHide( true );


    han_FixRun.ToHide( false );
    han_FixEmbl.ToHide( true );
    han_FixComponentsDecraft.ToHide( true );
    han_DecraftItem.ToHide( true );
    han_fixbox.ToHide( true );
    han_CraftItem.ToHide( false );
    han_DesText.ToHide( false );
    han_FixClassicVisible.ToHide( true );
    han_FixComponentsOfMouseMove.ToHide( true );
    han_FixComponentsTitle.ToHide( false );
    han_FixComponentsCraft.IsListBox( true, FixTextActiveColor, FixTextDownColor );
    han_FixTools.IsListBox( true, FixTextActiveColor, FixTextDownColor );
    han_FixSkills.ToHide( false );
    han_FixSaveRecipe.ToHide( false );

    han_CountDown.ToHide( false );
    han_CountUp.ToHide( false );
    han_Count.ToHide( false );
    han_CountText.ToHide( false );

    screenStat = SC_FIX_ITEM_FIX;

    if( infoPid == 0 )
    {
        han_FixComponentsCraft.ToHide( false );
        han_FixTools.ToHide( false );
        han_FixSkills.ToHide( false );
        FillItemFixScreen( ci );
        return;
    }

    FillItemInfoScreen( infoPid );
}

// Инициализация окна декрафта
void InitFixDecraft()
{
    han_FixRun.ToHide( true );
    han_FixEmbl.ToHide( false );
    han_fixbox.ToHide( false );
    han_FixComponentsDecraft.ToHide( false );
    han_DecraftItem.ToHide( false );
    han_CraftItem.ToHide( true );
    han_Blueprint.ToHide( true );
    han_FixComponentsTitle.ToHide( true );
    han_FixComponentsCraft.ToHide( true );
    han_FixTools.ToHide( true );
    han_FixSkills.ToHide( true );
    han_DesText.ToHide( true );
    han_FixClassicVisible.ToHide( true );
    han_FixComponentsOfMouseMove.ToHide( true );
    toBackList.resize( 0 );
    toForwardList.resize( 0 );
    han_GetForward.ToHide( true );
    han_GetBack.ToHide( true );
    han_FixSaveRecipe.ToHide( true );

    han_CountDown.ToHide( true );
    han_CountUp.ToHide( true );
    han_Count.ToHide( true );
    han_CountText.ToHide( true );
    han_Workbench.ToHide( true );

    FillDeCraftListbox();

    screenStat = SC_FIX_DECRAFT;
}

// Инициализация окна ремонта
void InitFixRepair()
{
    han_FixRun.ToHide( true );
    han_FixEmbl.ToHide( false );
    han_FixComponentsDecraft.ToHide( true );
    han_DecraftItem.ToHide( true );
    han_CraftItem.ToHide( true );
    han_Blueprint.ToHide( true );
    han_FixComponentsTitle.ToHide( true );
    han_FixComponentsCraft.ToHide( true );
    han_FixTools.ToHide( true );
    han_FixSkills.ToHide( true );
    han_DesText.ToHide( true );
    han_FixClassicVisible.ToHide( true );
    han_FixComponentsOfMouseMove.ToHide( true );
    toBackList.resize( 0 );
    toForwardList.resize( 0 );
    han_GetForward.ToHide( true );
    han_GetBack.ToHide( true );
    han_FixSaveRecipe.ToHide( true );

    han_CountDown.ToHide( true );
    han_CountUp.ToHide( true );
    han_Count.ToHide( true );
    han_CountText.ToHide( true );
    han_Workbench.ToHide( true );

    screenStat = SC_FIX_REPAIR;
}

// Инициализация окна апгрейда
void InitFixListUpgrade()
{
    han_FixRun.ToHide( true );
    han_FixEmbl.ToHide( false );
    han_FixComponentsDecraft.ToHide( true );
    han_DecraftItem.ToHide( true );
    han_CraftItem.ToHide( true );
    han_Blueprint.ToHide( true );
    han_FixComponentsTitle.ToHide( true );
    han_FixComponentsCraft.ToHide( true );
    han_FixTools.ToHide( true );
    han_DesText.ToHide( true );
    han_FixClassicVisible.ToHide( true );
    han_FixComponentsOfMouseMove.ToHide( true );
    toBackList.resize( 0 );
    toForwardList.resize( 0 );
    han_GetForward.ToHide( true );
    han_GetBack.ToHide( true );
    han_FixSkills.ToHide( true );
    han_FixSaveRecipe.ToHide( true );

    han_CountDown.ToHide( true );
    han_CountUp.ToHide( true );
    han_Count.ToHide( true );
    han_CountText.ToHide( true );
    han_Workbench.ToHide( true );

    screenStat = SC_FIX_LIST_UPGRADE;

    FillUpdateListbox();
}

// Инициализация окна статистики
void InitFixStat()
{
    han_FixRun.ToHide( true );
    han_FixEmbl.ToHide( false );
    han_FixComponentsDecraft.ToHide( true );
    han_DecraftItem.ToHide( true );
    han_CraftItem.ToHide( true );
    han_Blueprint.ToHide( true );
    han_FixComponentsTitle.ToHide( true );
    han_FixComponentsCraft.ToHide( true );
    han_FixTools.ToHide( true );
    han_FixSkills.ToHide( true );
    han_DesText.ToHide( true );
    han_FixClassicVisible.ToHide( true );
    han_FixComponentsOfMouseMove.ToHide( true );
    toBackList.resize( 0 );
    toForwardList.resize( 0 );
    han_GetForward.ToHide( true );
    han_GetBack.ToHide( true );
    han_FixSaveRecipe.ToHide( true );

    han_CountDown.ToHide( true );
    han_CountUp.ToHide( true );
    han_Count.ToHide( true );
    han_CountText.ToHide( true );
    han_Workbench.ToHide( true );

    screenStat = SC_FIX_STAT;
}

// =====================
// ИНИЦИАЛИЗАЦИЯ ГЛАВНОГО ОКНА
// =====================
void InitFixBoyMainScreen()                                        // Export
{
    GetIfaceColor( "FixTextColor", FixTextColor );     // Цвет текста по умолчанию
    GetIfaceColor( "FixTextActiveColor", FixTextActiveColor );   // Цвет активного текста
    GetIfaceColor( "FixTextDownColor", FixTextDownColor ); // Цвет текста при нажатии
    GetIfaceColor( "FixTextFixNotValid", FixTextFixNotValid );   // Цвет текста, если действие невозможно или маловозможно

    filtrDown = GetIfaceIniStr( "FixFiltrPicDn" );
    filtrUp = GetIfaceIniStr( "FixFiltrPic" );

    ScrollBarInstance  scrollBar();
    ScrollUpInstance   scrollUp();
    ScrollDownInstance scrollDown();
    ScreenMain         screenMain();
    ButtonFix          buttonFix();

    // Главное окно фиксбоя
    GUI_CreateScreen( CLIENT_SCREEN_NEW_FIX_BOY, GetIfaceIniStr( "FixMainPic" ) )
    .CallbackShow( screenMain )
    .CallbackHide( screenMain )
    .CloseOnMiss( true )
    .AutoCursor( true, CURSOR_DEFAULT );

    // Фильтры
    ReadFixBoyScreenInfo();

    FiltrWeapon filtrWeapon;
    FiltrArmor  filtrArmor;
    FiltrAmmo   filtrAmmo;
    FiltrMisc   filtrMisc;
    FiltrCustom filtrCustom;
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )   // Фильтр оружия
    .Position( "FixFiltrWeapon" )
    .CallbackDraw( filtrWeapon )
    .CallbackInit( filtrWeapon )
    .CallbackMouseClick( filtrWeapon );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )   // Фильтр брони
    .Position( "FixFiltrArmor" )
    .CallbackDraw( filtrArmor )
    .CallbackInit( filtrArmor )
    .CallbackMouseClick( filtrArmor );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )   // Фильтр патронов
    .Position( "FixFiltrAmmo" )
    .CallbackDraw( filtrAmmo )
    .CallbackInit( filtrAmmo )
    .CallbackMouseClick( filtrAmmo );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )   // Фильтр остального
    .Position( "FixFiltrMisc" )
    .CallbackDraw( filtrMisc )
    .CallbackInit( filtrMisc )
    .CallbackMouseClick( filtrMisc );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )   // Фильтр избраного
    .Position( "FixFiltrCustom" )
    .CallbackDraw( filtrCustom )
    .CallbackInit( filtrCustom )
    .CallbackMouseClick( filtrCustom );

    FixEmbl fixEmbl;
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, "fixEmbl.png", 0, 0 )   // Фильтр оружия
    .Position( "FixEmbl" )
    .CallbackInit( fixEmbl );

    // Листбокс
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, GetIfaceIniStr( "FixScrollBarPic" ), 430, 100 )
    .Position( "FixScrollBar" )
    .CallbackInit( scrollBar )
    .CallbackMouseMove( scrollBar )
    .CallbackMouseClick( scrollBar )
    .IsScrollBar( true )                                                                     // Указываем, что элемент - скроллбар
    .ToHide( true )                                                                          // Скрываем элемент. отобразим при необходимости
    .SBScrollPic( GetIfaceIniStr( "FixScrollBarPicDn" ) );                                   // Назначаем картинку ползунка сроллбара.

    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, GetIfaceIniStr( "FixScrUpPic" ), 0, 0 ) // кнопка "вверх"
    .Position( "FixScrUp" )
    .CallbackInit( scrollUp )
    .CallbackMouseClick( scrollUp )
    .ToHide( true )
    .DownPic( GetIfaceIniStr( "FixScrUpPicDn" ) );                                           // картинка нажатой кнопки

    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, GetIfaceIniStr( "FixScrDnPic" ), 0, 0 ) // кнопка "вниз"
    .Position( "FixScrDn" )
    .CallbackInit( scrollDown )
    .CallbackMouseClick( scrollDown )
    .ToHide( true )
    .DownPic( GetIfaceIniStr( "FixScrDnPicDn" ) );

    ListBoxInstance listBox();                                    // Создаем экземпляр класса
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 ) // Помещаем элемент на окно. параметры: индекс окна, имя картинки, х,у. Никаких точек с запятой, пока не опишем полностью элемент
    .Position( "FixWin" )
    .ToHide( true )
    .CallbackMouseMove( listBox )
    .CallbackMouseDown( listBox )
    .CallbackInit( listBox )                                        // Назначаем элементу поведение при инициализации(описаное в классе ListBox)
    .CallbackMouseClick( listBox )                                  // Ну и при клике на него.
    .ScrollableText( true )                                         // Указываем, что текст на элементе можно листать. Обязательный параметр для листбокса.
    .IsListBox( true, FixTextActiveColor, FixTextDownColor ); // Указываем, что элемент - листбокс. вторый и третий параметр - цвет текста при наедении на элемент и при нажатии на него.

    // Кнопка "Крафт"
    ButtonChangeWindow buttonFixFix( SC_FIX_LIST_FIX );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixButtonFix" )
    .ClickSound( "BUTOUT1.ACM" )
    .CallbackMouseClick( buttonFixFix )
    .Text( GetMsgStr( TEXTMSG_GAME, 225 ), FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN )
    .TextFrame( -23, -55 )
    .DownPic( GetIfaceIniStr( "FixButtonChangeScreenPicDn" ) );

    // Кнопка "Декрафт"
    ButtonChangeWindow buttonFixDecraft( SC_FIX_DECRAFT );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixButtonDecraft" )
    .ClickSound( "BUTOUT1.ACM" )
    .CallbackMouseClick( buttonFixDecraft )
    .Text( GetMsgStr( TEXTMSG_GAME, 226 ), FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN )
    .TextFrame( -27, -55 )
    .DownPic( GetIfaceIniStr( "FixButtonChangeScreenPicDn" ) );
    //
    // Кнопка "Ремонт"
    ButtonChangeWindow buttonFixRepair( SC_FIX_REPAIR );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixButtonRepair" )
    .ClickSound( "BUTOUT1.ACM" )
    .CallbackMouseClick( buttonFixRepair )
    .Text( "", FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN )
    .TextFrame( -23, -55 )
    .DownPic( GetIfaceIniStr( "FixButtonChangeScreenPicDn" ) );

    // Кнопка "Апгрейд"
    ButtonChangeWindow buttonFixUpgrade( SC_FIX_LIST_UPGRADE );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixButtonUpgrade" )
    .ClickSound( "BUTOUT1.ACM" )
    .CallbackMouseClick( buttonFixUpgrade )
    .Text( GetMsgStr( TEXTMSG_GAME, 233 ), FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN )
    .TextFrame( -32, -55 )
    .DownPic( GetIfaceIniStr( "FixButtonChangeScreenPicDn" ) );

    // Кнопка "Статистика"
    ButtonChangeWindow buttonFixStat( SC_FIX_STAT );
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixButtonStat" )
    .ClickSound( "BUTOUT1.ACM" )
    .CallbackMouseClick( buttonFixStat )
    .Text( "", FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN )
    .TextFrame( -40, -55 )
    .DownPic( GetIfaceIniStr( "FixButtonChangeScreenPicDn" ) );

    // Кнопка "Назад"
    ButtonDone buttonDone();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .ClickSound( "BUTOUT3.ACM" )
    .Position( "FixDone" )
    .CallbackMouseClick( buttonDone )
    .DownPic( GetIfaceIniStr( "FixDonePicDn" ) );

    // ДЕКРАФТ
    // Изображение компонентов декрафта
    FixComponentsDecraft fixComponentsDecraft();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixComponentsDecraft" )
    .CallbackInit( fixComponentsDecraft )
    .TextFrame( -5, -22 )
    .ToHide( true );

    // Изображение разбираемого предмета
    FixDecraftItem fixItemDecraft();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixItemDecraft" )
    .CallbackInit( fixItemDecraft )
    .ToHide( true );

    // КРАФТ
    ButtonFixRun buttonFixRun();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixFix" )
    .CallbackInit( buttonFixRun )
    .CallbackMouseClick( buttonFixRun )
    .CallbackMouseDown( buttonFixRun )
    .CallbackMouseMove( buttonFixRun )
    .DownPic( GetIfaceIniStr( "FixFixPicDn" ) )
    .ClickSound( "MONITOR.ACM" )
    .ToHide( true );

    FixComponentsTitle fixComponentsTitle();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixDes" )
    // .TextFrame(0, -10)
    .CallbackInit( fixComponentsTitle )
    .ToHide( true );

    // Отображение компонентов создаваемого предмета
    FixComponentsCraft fixComponentsCraft();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixDes" )
    .CallbackMouseClick( fixComponentsCraft )
    .CallbackMouseMove( fixComponentsCraft )
    .TextFrame( 0, 10 )
    .ClickSound( "MONITOR.ACM" )
    .CallbackInit( fixComponentsCraft )
    .ScrollableText( true )
    .IsListBox( true, FixTextActiveColor, FixTextDownColor )
    .ToHide( true );

    FixTools fixTools();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixDes" )
    .CallbackMouseClick( fixTools )
    .CallbackInit( fixTools )
    .ScrollableText( true )
    .IsListBox( true, FixTextActiveColor, FixTextDownColor )
    .ListBoxFocused( false )
    .ToHide( true );

    // Отображение скилов
    FixSkills fixSkills();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixDes" )
    .CallbackInit( fixSkills )
    .ScrollableText( true )
    .IsListBox( true, FixTextActiveColor, FixTextActiveColor )
    .ToHide( true );

    // Отображение создаваемого предмета
    FixCraftItem fixItemCraft();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixItemCraft" )
    .CallbackInit( fixItemCraft )
    .TextFrame( -18, -28 )
    .ToHide( true );

    FixBlueprint fixBlueprint();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixDes" )
    .CallbackInit( fixBlueprint )
    .PictureSize( 60, 60 )
    .TextFrame( -35, -20 )
    .ToHide( true );

    FixWorkbench fixWorkbench();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
		.CallbackInit( fixWorkbench )
		.TextFrame( 0, -40 )
		.Position( "FixDes" );

    // Описание создаваемого предмета
    FixDesText fixDesText();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixDesText" )
    .CallbackInit( fixDesText )
    .ToHide( true );

    // Элементы опций крафта
    // Классическая фильтрация видимости рецептов
    FixClassicVisible fixClassicVisible();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixClassicVisible" )
    .Text( GetMsgStr( TEXTMSG_GAME, 223 ), FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_NOBREAK )
    .CallbackInit( fixClassicVisible )
    .ClickSound( "MONITOR.ACM" )
    .CallbackMouseClick( fixClassicVisible )
    .ToHide( true );

    // Переход по компонентам, посредством движения миши
    FixComponentsOfMouseMove fixComponentsOfMouseMove();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixComponentsOfMouseMove" )
    .Text( GetMsgStr( TEXTMSG_GAME, 224 ), FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_NOBREAK )
    .CallbackInit( fixComponentsOfMouseMove )
    .ClickSound( "MONITOR.ACM" )
    .CallbackMouseClick( fixComponentsOfMouseMove )
    .ToHide( true );

    // кнопки перехода назад и вперёд по страницам крафта
    FixGetBack fixGetBack();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixGetBack" )
    .Text( "<<<", FONT_THIN, FixTextColor, FixTextDownColor, FT_NOBREAK )
    .CallbackInit( fixGetBack )
    .ClickSound( "MONITOR.ACM" )
    .CallbackMouseClick( fixGetBack )
    .ToHide( true );

    FixGetForward fixGetForward();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .Position( "FixGetForward" )
    .Text( ">>>", FONT_THIN, FixTextColor, FixTextDownColor, FT_NOBREAK )
    .CallbackInit( fixGetForward )
    .ClickSound( "MONITOR.ACM" )
    .CallbackMouseClick( fixGetForward )
    .ToHide( true );

    FixCountText fixCountText();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .CallbackInit( fixCountText )
    .Position( "FixCountUp" )
    .TextFrame( -48, -14 )
    .Text( GetMsgStr( TEXTMSG_GAME, 230 ), FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_NOBREAK );

    FixCount fixCount();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .ClickSound( "MONITOR.ACM" )
    .CallbackInit( fixCount )
    .CallbackMouseClick( fixCount )
    .CallbackMouseDown( fixCount )
    .Position( "FixCount" )
    .Text( "" + craftCount, FONT_THIN, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN );

    FixCountDown fixCountDown();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .ClickSound( "MONITOR.ACM" )
    .CallbackInit( fixCountDown )
    .CallbackMouseClick( fixCountDown )
    .CallbackMouseDown( fixCountDown )
    .Text( "<<", FONT_THIN, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN )
    .Position( "FixCountDown" );

    FixCountUp fixCountUp();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .ClickSound( "MONITOR.ACM" )
    .CallbackInit( fixCountUp )
    .CallbackMouseClick( fixCountUp )
    .CallbackMouseDown( fixCountUp )
    .Text( ">>", FONT_THIN, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN )
    .Position( "FixCountUp" );

    FixSaveRecipe fixSaveRecipe();
    GUI_AddScreenElement( CLIENT_SCREEN_NEW_FIX_BOY, null, 0, 0 )
    .ClickSound( "MONITOR.ACM" )
    .CallbackInit( fixSaveRecipe )
    .CallbackMouseClick( fixSaveRecipe )
    .Text( GetMsgStr( TEXTMSG_GAME, 227 ), FONT_FALLOUT, FixTextColor, FixTextDownColor, FT_ALIGN | FT_CENTERY )
    .Position( "FixSaveRecipe" );
}

// Главное окно
class ScreenMain : IGUI::ScreenCallbackShow, IGUI::ScreenCallbackHide
{
    void OnShow( int p0, int p1, int p2 )
    {
        CraftInit();
        FillCraftListbox();
        InitFixListFix();

    }

    void OnHide( int p0, int p1, int p2 )
    {
        WriteFixBoyScreenInfo();

        CritterInvenItemsId.resize( 0 );
        visibleClientCraftList.resize( 0 );
        CraftList.resize( 0 );
        CraftList.resize( 0 );
        // ClientCraftList.resize(0);
        componentsPos.resize( 0 );
        toBackList.resize( 0 );
        toForwardList.resize( 0 );
        workbenchsId.resize( 0 );
        // saveList.resize(0);
    }
}

// Главный листбокс
class ListBoxInstance : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackMouseMove, IGUI::ElementCallbackMouseDown // Описываем класс нашего листбокса, чтоб задать его поведение
{
    uint16 componentIndex;
    uint16 lastComponent;

    void OnInit()
    {
        @han_fixbox = GUI_GetElementOptions();
        FillDeCraftListbox();
    }

    void OnMouseMove( bool clicked )
    {
        if( han_fixbox.IsHidden() )
            return;
        lastComponent = componentIndex;
        componentIndex = uint16( han_fixbox.GetListElement() );

        // Декрафт
        if( screenStat == SC_FIX_DECRAFT )
        {
            if( componentIndex > ( CritterInvenItemsId.length() - 1 ) || CritterInvenItemsId.length() < 1 )
                return;
            decraftComponentPic( CritterInvenItemsId[ componentIndex ] );
        }
        else if( screenStat == SC_FIX_LIST_UPGRADE )
        {}
    }

    void OnMouseDown( int click )
    {
        if( click == MOUSE_CLICK_LEFT )
        {
            // Декрафт
            // if(screenStat==SC_FIX_DECRAFT)
            // {
            // if(componentIndex>(CritterInvenItemsId.length()-1) || CritterInvenItemsId.length()<1) return;
            // PlaySound("IB2LU1X1.ACM");
            // RunServerScriptUnsafe("fix_boy@unsafe_DecraftItem", CritterInvenItemsId[han_fixbox.GetListElement()], 0, 0, null, null);
            // FillDeCraftListbox();
            // return;
            // }
        }
    }

    void OnMouseClick( int click )
    {
        // Здесь мы описываем поведение скроллбара при прокручивания списка колесиком мыши
        if( click == MOUSE_CLICK_WHEEL_UP || click == MOUSE_CLICK_WHEEL_DOWN )
        {
            han_scrollbar.SBSetValue( han_fixbox.GetTextOffset() );
        }

        if( click == MOUSE_CLICK_LEFT )
        {
            // Декрафт
            if( screenStat == SC_FIX_DECRAFT )
            {
                if( componentIndex > ( CritterInvenItemsId.length() - 1 ) || CritterInvenItemsId.length() < 1 )
                    return;
                if( !valid( GetChosen() ) || GetChosen().Timeout[ TO_SK_REPAIR ] > 0 )
                {
                    Message( GetMsgStr( TEXTMSG_GAME, STR_SKILL_WEARINESS ) );
                    return;
                }
                PlaySound( "IB2LU1X1.ACM" );
                RunServerScriptUnsafe( "fix_boy@unsafe_DecraftItem", CritterInvenItemsId[ han_fixbox.GetListElement() ], 0, 0, null, null );
                FillDeCraftListbox( CritterInvenItemsId[ han_fixbox.GetListElement() ] );            // TabaK. Сразу удаляем предмет из списка. Костыль же.
                return;
            }
            else if( screenStat == SC_FIX_LIST_FIX )
            {
                // curCraftGlobalPos=ClientCraftList[han_fixbox.GetListElement()].Pos;
                curCraftPos = visibleClientCraftList[ han_fixbox.GetListElement() ].Pos;
                InitFixItemFix( visibleClientCraftList[ han_fixbox.GetListElement() ], 0 );
            }
            else if( screenStat == SC_FIX_LIST_UPGRADE )
            {
                ItemCl@ item = GetItemByPos( componentIndex );
                if( @item !is null )
                {
                    if( CurUpdateItemId == 0 )
                        FillUpdateListbox( item.Id );
                    else
                    {
                        ClearLexemsItem( CurUpdateItemId );
                        RunServerScriptUnsafe( "Mk2@unsafe_RandomParametersItems::UpdateItem", CurUpdateItemId, CritterInvenItemsId[ han_fixbox.GetListElement() ], 0, null, null );
						InitFixListUpgrade( );
                    }
                }
            }
        }
        else if( click == MOUSE_CLICK_RIGHT && screenStat == SC_FIX_LIST_UPGRADE )
        {
            if( componentIndex > ( CritterInvenItemsId.length() - 1 ) || CritterInvenItemsId.length() < 1 )
                return;

            ItemCl@ item = GetItemByPos( componentIndex );
            if( @item !is null ) item_description( item, ITEM_LOOK_FIX_BOY_UPGRADE );
        }
    }
}

// Скроллбар главного листбокса
class ScrollBarInstance : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackMouseMove // Описываем класс скроллбара
{
    void OnInit()
    {
        @han_scrollbar = GUI_GetElementOptions();       // Назначаем глобальный указатель на скроллбар, для управления им из листбокса.
    }

    void OnMouseClick( int click )
    {
        // Первый параметр указывает на то, что мы задаем точное значени, а не меняем текущее.
        han_fixbox.SetScroll( false, han_scrollbar.GetSBScrollValue() );       // Устанавливаем смещение для списка в соответствии с положением скроллбара.
    }
    void OnMouseMove( bool clicked )
    {
        if( clicked )
        {
            han_fixbox.SetScroll( false, han_scrollbar.GetSBScrollValue() );
        }
    }
}

// Кнопка прокручивания листбокса вверх
class ScrollUpInstance : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick
{
    void OnInit()
    {
        @han_scrollup = GUI_GetElementOptions();
    }
    void OnMouseClick( int click )
    {
        if( click == MOUSE_CLICK_LEFT )
        {
            han_fixbox.SetScroll( true, -3 );                       // Меняем текущее смещение текста на -1
            han_scrollbar.SBSetValue( han_fixbox.GetTextOffset() ); // Устанавливаем положение ползунка скроллбара в соответствии со смещением списка.
        }
    }
}

// Кнопка прокручивания листбокса вниз
class ScrollDownInstance : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick // Кнопка прокручивания списка вниз
{
    void OnInit()
    {
        @han_scrolldown = GUI_GetElementOptions();
    }
    void OnMouseClick( int click )
    {
        if( click == MOUSE_CLICK_LEFT )
        {
            han_fixbox.SetScroll( true, 3 );                        // Меняем текущее смещение текста на +1
            han_scrollbar.SBSetValue( han_fixbox.GetTextOffset() ); // Устанавливаем положение ползунка скроллбара в соответствии со смещением списка.
        }
    }
}

// Кнопка создания предмета
class ButtonFix : IGUI::ElementCallbackMouseClick
{
    void OnMouseClick( int click )
    {}
}

// Кнопка перехода между окнами
class ButtonChangeWindow : IGUI::ElementCallbackMouseClick
{
    uint8 screen;
    ButtonChangeWindow( uint8 nextScreen )
    {
        screen = nextScreen;
    }

    void OnMouseClick( int click )
    {
        if( screenStat == screen )
            return;                            // Если это и есть данное окно, то что-либо делать нет смысла
        if( click != MOUSE_CLICK_LEFT )
            return;
        han_fixbox.Text( "", 0, 0, 0, FT_NOBREAK );
        han_scrollbar.ToHide( true );
        han_scrollup.ToHide( true );
        han_scrolldown.ToHide( true );

        switch( screen )
        {
        case SC_FIX_LIST_FIX:
            InitFixListFix();
            break;
        case SC_FIX_DECRAFT:
            InitFixDecraft();
            break;
        case SC_FIX_REPAIR:
            InitFixRepair();
            break;
        case SC_FIX_LIST_UPGRADE:
            InitFixListUpgrade();
            break;
        case SC_FIX_STAT:
            InitFixStat();
            break;
        default:
            break;
        }
    }
}

// Кнопка закрытия окна или "назад"
class ButtonDone : IGUI::ElementCallbackMouseClick
{
    void OnMouseClick( int click )
    {
        if( screenStat == SC_FIX_LIST_FIX )
        {
            ::HideScreen( CLIENT_SCREEN_NEW_FIX_BOY, 3, 3, 3 );
            return;
        }
        InitFixListFix();
    }
}

// Изображение разбираемого предмета
class FixDecraftItem :  IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_DecraftItem = GUI_GetElementOptions();
    }
}

// Изображение компонентов крафта/декрафта
class FixComponentsDecraft :  IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_FixComponentsDecraft = GUI_GetElementOptions();
    }
}

class FixCraftItem :  IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_CraftItem = GUI_GetElementOptions();
    }
}

class FixWorkbench :  IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_Workbench = GUI_GetElementOptions();
    }
}

class FixBlueprint :  IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_Blueprint = GUI_GetElementOptions();
    }
}

class FixDesText :  IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_DesText = GUI_GetElementOptions();
    }
}

class FixSkills : IGUI::ElementCallbackInit // Описываем класс нашего листбокса, чтоб задать его поведение
{
    void OnInit()
    {
        @han_FixSkills = GUI_GetElementOptions();
    }
}

class FixTools : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick // Описываем класс нашего листбокса, чтоб задать его поведение
{
    void OnInit()
    {
        @han_FixTools = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {}
}



class FixComponentsCraft : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackMouseMove // Описываем класс нашего листбокса, чтоб задать его поведение
{
    void OnInit()
    {
        @han_FixComponentsCraft = GUI_GetElementOptions();
    }

    void OnMouseMove( bool clicked )
    {
        uint16 index = uint16( han_FixComponentsCraft.GetListElement() );
        if( index + 1 > componentsPos.length() || index < 0 )
        {
            ClearItemInfoScreen();
            return;
        }

        if( !isFixComponentsOfMouseMove )
            return;

        uint16    pos = componentsPos[ index ];

        craftInfo ci;
        if( pos < CRAFT_OFFSET )
        {
            InitFixItemFix( ci, pos );
            return;
        }

        pos -= CRAFT_OFFSET;
        // Message("pos="+pos);
        // Message("l="+ClientCraftList.length());
        InitFixItemFix( ci, CraftList[ pos ].ResultItem );
    }

    void OnMouseClick( int click )
    {
        uint16 index = uint16( han_FixComponentsCraft.GetListElement() );

        if( index + 1 > componentsPos.length() || index < 0 )
            return;

        uint16    pos = componentsPos[ index ];

        craftInfo ci;
        if( pos < CRAFT_OFFSET )
        {
            InitFixItemFix( ci, pos );
            return;
        }

        pos -= CRAFT_OFFSET;

        han_GetBack.ToHide( false );
        if( toBackList.length() < 1 || toBackList[ toBackList.length() - 1 ] != curCraftPos )
            toBackList.insertLast( curCraftPos );

        // curCraftPos=pos;
        curCraftPos = CraftList[ pos ].Pos;
        // Message(""+pos+"="+CraftList[pos].Pos);
        // Message("pid="+CraftList[pos].ResultItem);
        InitFixItemFix( CraftList[ pos ], 0 );

    }
}

class FixClassicVisible : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick
{
    void OnInit()
    {
        @han_FixClassicVisible = GUI_GetElementOptions();
        if( !isFixClassicVisible )
            han_FixClassicVisible.Font( fontNumber,  FixTextFixNotValid );
    }

    void OnMouseClick( int click )
    {
        if( isFixClassicVisible )
        {
            isFixClassicVisible = false;
            han_FixClassicVisible.Font( fontNumber,  FixTextFixNotValid );
            FillCraftListbox();
            return;
        }

        isFixClassicVisible = true;
        han_FixClassicVisible.Font( fontNumber, FixTextColor );
        FillCraftListbox();
    }
}

class FixComponentsOfMouseMove : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick
{
    void OnInit()
    {
        @han_FixComponentsOfMouseMove = GUI_GetElementOptions();
        if( !isFixComponentsOfMouseMove )
            han_FixComponentsOfMouseMove.Font( fontNumber,  FixTextFixNotValid );
    }

    void OnMouseClick( int click )
    {
        if( isFixComponentsOfMouseMove )
        {
            isFixComponentsOfMouseMove = false;
            han_FixComponentsOfMouseMove.Font( fontNumber,  FixTextFixNotValid );
            return;
        }

        isFixComponentsOfMouseMove = true;
        han_FixComponentsOfMouseMove.Font( fontNumber, FixTextColor );
    }
}

class FixGetBack : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick
{
    void OnInit()
    {
        @han_GetBack = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        han_GetForward.ToHide( false );

        if( toBackList.length() == 0 )
            return;

        han_GetForward.ToHide( false );

        uint16 index = toBackList.length() - 1;
        if( toForwardList.length() < 1 || toForwardList[ toForwardList.length() - 1 ] != curCraftPos )
            toForwardList.insertLast( curCraftPos );

        curCraftPos = toBackList[ index ];
        // curCraftGlobalPos=CraftList[toBackList[index]].Pos;
        InitFixItemFix( CraftList[ toBackList[ index ] ], 0 );
        toBackList.resize( index );

        if( toBackList.length() == 0 )
            han_GetBack.ToHide( true );
    }
}

class FixGetForward : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick
{
    void OnInit()
    {
        @han_GetForward = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( toForwardList.length() == 0 )
            return;

        han_GetBack.ToHide( false );

        uint16 index = toForwardList.length() - 1;
        if( toBackList.length() < 1 || toBackList[ toBackList.length() - 1 ] != curCraftPos )
            toBackList.insertLast( curCraftPos );

        curCraftPos = toForwardList[ index ];
        // curCraftGlobalPos=CraftList[toForwardList[index]].Pos;
        InitFixItemFix( CraftList[ toForwardList[ index ] ], 0 );
        toForwardList.resize( index );

        if( toForwardList.length() == 0 )
            han_GetForward.ToHide( true );
    }
}

// ФИЛЬТРЫ
class FiltrWeapon : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackDraw
{
    void OnInit()
    {
        @han_filtrWeapon = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( screenStat != SC_FIX_LIST_FIX && screenStat != SC_FIX_DECRAFT )
            return;

        PlaySound( "BUTIN2.ACM" );

        if( fWeapon )
            fWeapon = false;
        else
            fWeapon = true;

        if( screenStat == SC_FIX_DECRAFT )
            FillDeCraftListbox();
        else
            FillCraftListbox();
    }

    void OnDraw()
    {
        han_filtrWeapon.Picture( fWeapon ? filtrDown : filtrUp );
    }
}

class FiltrArmor : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackDraw
{
    void OnInit()
    {
        @han_filtrArmor = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( screenStat != SC_FIX_LIST_FIX && screenStat != SC_FIX_DECRAFT )
            return;

        PlaySound( "BUTIN2.ACM" );

        if( fArmor )
            fArmor = false;
        else
            fArmor = true;
        if( screenStat == SC_FIX_DECRAFT )
            FillDeCraftListbox();
        else
            FillCraftListbox();
    }

    void OnDraw()
    {
        han_filtrArmor.Picture( fArmor ? filtrDown : filtrUp );
    }
}

class FiltrAmmo : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackDraw
{
    void OnInit()
    {
        @han_filtrAmmo = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( screenStat != SC_FIX_LIST_FIX && screenStat != SC_FIX_DECRAFT )
            return;

        PlaySound( "BUTIN2.ACM" );

        if( fAmmo )
            fAmmo = false;
        else
            fAmmo = true;
        if( screenStat == SC_FIX_DECRAFT )
            FillDeCraftListbox();
        else
            FillCraftListbox();
    }

    void OnDraw()
    {
        han_filtrAmmo.Picture( fAmmo ? filtrDown : filtrUp );
    }
}

class FiltrMisc : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackDraw
{
    void OnInit()
    {
        @han_filtrMisc = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( screenStat != SC_FIX_LIST_FIX && screenStat != SC_FIX_DECRAFT )
            return;

        PlaySound( "BUTIN2.ACM" );

        if( fMisc )
            fMisc = false;
        else
            fMisc = true;
        if( screenStat == SC_FIX_DECRAFT )
            FillDeCraftListbox();
        else
            FillCraftListbox();
    }

    void OnDraw()
    {
        han_filtrMisc.Picture( fMisc ? filtrDown : filtrUp );
    }
}

class FiltrCustom : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackDraw
{
    void OnInit()
    {
        @han_filtrCustom = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( screenStat != SC_FIX_LIST_FIX && screenStat != SC_FIX_DECRAFT )
            return;

        PlaySound( "BUTIN2.ACM" );

        if( fCustom )
            fCustom = false;
        else
            fCustom = true;

        // if(fCustom && isFixClassicVisible)
        //	FillCraftListbox();

        if( screenStat == SC_FIX_DECRAFT )
            FillDeCraftListbox();
        else
            FillCraftListbox();
    }

    void OnDraw()
    {
        han_filtrCustom.Picture( fCustom ? filtrDown : filtrUp );
    }
}

class FixCountText : IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_CountText = GUI_GetElementOptions();
    }
}

class FixComponentsTitle : IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_FixComponentsTitle = GUI_GetElementOptions();
    }
}

class FixCount : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackMouseDown
{
    void OnInit()
    {
        @han_Count = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( click == MOUSE_CLICK_WHEEL_UP )
        {
            if( craftCount == 100 )
                craftCount = 1;
            else
                craftCount++;
        }
        else if( click == MOUSE_CLICK_WHEEL_DOWN )
        {
            if( craftCount == 1 )
                craftCount = 100;
            else
                craftCount--;
        }
        setCraftComponents();
    }

    void OnMouseDown( int click )
    {}
}

class FixCountDown : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackMouseDown
{
    void OnInit()
    {
        @han_CountDown = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( click == MOUSE_CLICK_WHEEL_UP )
        {
            if( craftCount == 100 )
                craftCount = 1;
            else
                craftCount++;
        }
        else
        {
            if( craftCount == 1 )
                craftCount = 100;
            else
                craftCount--;
        }

        setCraftComponents();
    }

    void OnMouseDown( int click )
    {}
}

class FixCountUp : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick, IGUI::ElementCallbackMouseDown
{
    void OnInit()
    {
        @han_CountUp = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        if( click == MOUSE_CLICK_WHEEL_DOWN )
        {
            if( craftCount == 1 )
                craftCount = 100;
            else
                craftCount--;
        }
        else
        {
            if( craftCount == 100 )
                craftCount = 1;
            else
                craftCount++;
        }
        setCraftComponents();
    }

    void OnMouseDown( int click )
    {}
}

class FixEmbl : IGUI::ElementCallbackInit
{
    void OnInit()
    {
        @han_FixEmbl = GUI_GetElementOptions();
    }
}

class FixSaveRecipe : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseClick
{
    void OnInit()
    {
        @han_FixSaveRecipe = GUI_GetElementOptions();
    }

    void OnMouseClick( int click )
    {
        bool isSave = true;
        for( uint16 i = 0, iMax = saveList.length(); i < iMax; i++ )
        {
            if( uint( saveList[ i ] ) == CraftList[ curCraftPos ].Pos )
            {
                saveList[ i ] = -1;
                han_FixSaveRecipe.Text( GetMsgStr( TEXTMSG_GAME, 227 ), fontNumber, FixTextColor, FixTextDownColor, FT_CENTERX | FT_ALIGN );
                isSave = false;
                break;
            }
        }

        if( isSave )
        {
            han_FixSaveRecipe.Text( GetMsgStr( TEXTMSG_GAME, 228 ), fontNumber, FixTextFixNotValid, FixTextDownColor, FT_CENTERX | FT_ALIGN );
            saveList.insertLast( CraftList[ curCraftPos ].Pos );
        }
    }
}

class ButtonFixRun : IGUI::ElementCallbackInit, IGUI::ElementCallbackMouseDown, IGUI::ElementCallbackMouseMove, IGUI::ElementCallbackMouseClick
{
    void OnInit()
    {
        @han_FixRun = GUI_GetElementOptions();
    }

    void OnMouseDown( int click )
    {
        if( click != MOUSE_CLICK_LEFT )
            return;
        RunServerScriptUnsafe( "fix_boy@unsafe_ci", CraftList[ curCraftPos ].Pos, craftCount, 0, "", null );
    }

    void OnMouseMove( bool clicked )
    {
        /*craftInfo ci = CraftList[curCraftPos];
           FillItemFixScreen(ci);*/
    }

    void OnMouseClick( int click )
    {
        craftInfo ci = CraftList[ curCraftPos ];
        FillItemFixScreen( ci );
    }


}
#endif // __CLIENT
