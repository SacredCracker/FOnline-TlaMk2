#include "_macros.fos"


/* ******************************************************************************************************************************************************** */
// Id караванов. Каждый караван нужно объявить здесь
/* ******************************************************************************************************************************************************** */
#define CARAVAN_WADE_REDD_VC							(1) // Реддинг-ВолтСити. Проводник: redd_wade. Отправление первого числа каждого месяца в 12 часов.
#define CARAVAN_SAVINEL_REDD_NR							(2) // Реддинг-НьюРено. Проводник: trdd_savinel. Отправление каждого 21 числа в 15 часов.
#define CARAVAN_STANWELL_REDD_NCR						(3) // Реддинг-НКР. Проводник: redd_stanwell. Отправление каждого 11 числа в 8 часов.
#define CARAVAN_HAL_NCR_REDD							(4) // НКР-Реддинг, односторонний. Проводник: ncr_hal. Отправление 15 в 14:00
#define CARAVAN_KIT_BH_GECKO                            (5) // Броукен-Хиллз - Гекко. Односторонний. Проводник: bh_kit. Отправление каждые сутки в 10:00
#define PATROL_HATE_NCR                                 (6) // Односторонний ежедневный патруль рейнджеров.
#define PATROL_SHRIM_VC                                 (7) // Односторонний ежедневный патруль гвардейцев ГУ.
#define CARAVAN_SELMA_ARR_VC                            (8) // Двусторонний, Арройо-ГУ, отправление в 14:00
#define CARAVAN_GAYZUN_ARR_SF                           (9) // Арройо-СФ, отправление в 19:00
#define CARAVAN_LAUMER_ARR_NCR                          (10) // Арройо-НКР, отправление в 
#define CARAVAN_HOSE_MOD_GECKO                          (11) // Модок-Гекко, односторонний 12:00
/* ******************************************************************************************************************************************************** */
// Коды прототипов караванщиков и сумки
/* ******************************************************************************************************************************************************** */
#define NPC_PID_Wade									(92) // прототип Вейда(Реддинг)
#define NPC_PID_Redd_Vc_male_guard						(459) // мужик в металлической броне
#define NPC_PID_Redd_Vc_female_guard					(461) // женщина в металлической броне
#define NPC_PID_Redd_Vc_black_guard						(460) // негр в металлической броне (с молотом)
#define NPC_PID_Stanwell								(44)
#define BAG_Stanwell									(24)
#define BAG_Savinelly									(20)
#define NPC_PID_Savinelly								(36)
#define NPC_PID_Hal										(166)
#define BAG_Hal											(20)
#define NPC_PID_HATE                                    (489)
/* ******************************************************************************************************************************************************** */

// типы караванов
#define CRV_TYPE_ONEWAY 								(1) // односторонний караван, всегда идет из начальной точки в конечную
#define CRV_TYPE_TWOWAY 								(2) // двухсторонний караван, если доходит до точки назначения, в следующий раз пойдет по обратному маршруту
#define CRV_TYPE_ONEWAY_TRANSITLEADER					(3) // односторонний караван, из конечной точки телепортирует начальника караванв в начальную
#define CRV_TYPE_ONEWAY_DELETELEADER					(4) // односторонний караван, через час после достижения конечной точки удаляет начальника каравана
#define CRV_TYPE_ONEWAY_DELETELEADER_BOTH				(5) // односторонний караван, через час после достижения конечной точки удаляет начальника каравана. Если никто не пришел к отправлению - удаляет тоже.


// статус каравана
#define CRV_STATUS_BEFORE_START							(0) // караван не начинался
#define CRV_STATUS_PREPARE								(1) // появился проводник, игроки могут подавать заявки на охрану каравана
#define CRV_STATUS_START_MOVE							(2) // караван вышел из пункта А
#define CRV_STATUS_ON_GLOBAL							(3) // караван перемещается по глобалу
#define CRV_STATUS_ON_ENCOUNTER							(4) // караван на случайном энкаунтере
#define CRV_STATUS_END									(5) // караван добрался до точки назначения в пункт Б

// статус квестовой переменной для игроков, сопровождающих караван
#define CARAVAN_NOQUEST									(0) // не взят
#define CARAVAN_QUEST_TAKEN								(1) // взят квест
#define CARAVAN_PLAYER_JOIN_FIRST						(2) // игрок присоединился к каравану и караван начал движение впервые
// провалы. Если будет хоть один провал, по идее игрок больше не сможет охранять этот караван
#define CARAVAN_FAILURE_PLAYER_THIEFT					(3) // игрок напал на караванщиков или пытался ограбить
#define CARAVAN_FAILURE_PLAYER_ABANDONED				(4) // игрок покинул караван
#define CARAVAN_FAILURE_PLAYER_DEAD						(5) // игрок погиб во время каравана
#define CARAVAN_FAILURE_CARAVANLEADER_DEAD				(6) // убит проводник на энкаунтере
#define CARAVAN_FAILURE_PLAYER_KILL_LEADER				(7) // игрок убил проводника на энкаунтере
//первый и последующий успех
#define CARAVAN_SUCCESS_FIRST							(8) // игрок довел караван до точки назначения впервые
#define CARAVAN_PLAYER_JOIN_NEXT						(9) // игрок присоединился к каравану и караван начал движение в последующие разы
#define CARAVAN_SUCCESS_NEXT							(10) // игрок довел караван до точки назначения в последующие разы
#define CARAVAN_QUEST_COMPLETE							(11) // игрок сдал квест


#define LEADER_SEARCH_RADIUS							(8) // радиус, в котором ищем проводника при проверках, в верной ли позиции он находится
#define CrvId											StatBase[ST_VAR0] // у всех криттеров в составе каравана прописываем номер каравана, к которому они относятся

#define MODEL_CRVNR_COWARD								(1)// модель поведения проводника: трус - пока других моделей поведения нет

#define	MIN_DIST_CABS_DIST 								(6) // минимальное расстояние между соседними повозками
#define STR_DONT_TOUCH									(3500) // строка, которую произносит проводник, если игрок пробует открыть повозки

#define TIME_TO_WAIT_AT_ENDPOINT						(60*60*2) // время в игрокых минутах, через которое будет телепортирован в начальную точку лидер, если тип каравана=CRV_TYPE_ONEWAY_TRANSITLEADER и караван дошел до пункта назначенния
#define TIME_TO_DELETE_LEADER                           (60*30) // время в игровых минутах, через которое будет удален проводник каравана в конечной точке маршрута, если тип каравана=CRV_TYPE_ONEWAY_DELETELEADER


// управление квестовой переменной
#define _SetPlayerJoinFirst #(cr,crv) {if(GetQuestState(cr,crv.CaravanId)==CARAVAN_QUEST_TAKEN) SetQuestState(cr,crv.CaravanId, CARAVAN_PLAYER_JOIN_FIRST);} // при первом присоединении должен быть взят квест
#define _SetPlayerSuccessFirst #(cr,crv) {if(GetQuestState(cr,crv.CaravanId)==CARAVAN_PLAYER_JOIN_FIRST) SetQuestState(cr,crv.CaravanId, CARAVAN_SUCCESS_FIRST);} // для первого выполнения, должно быть первое присоединение
#define _SetPlayerThieft #(cr,crv){SetQuestState(cr,crv.CaravanId, CARAVAN_FAILURE_PLAYER_THIEFT);} // при воровстве или атаке всегда ставится статус
#define _SetPlayerAbandoned #(cr,crv) {uint q=GetQuestState(cr,crv.CaravanId); if(q==CARAVAN_PLAYER_JOIN_FIRST||q==CARAVAN_PLAYER_JOIN_NEXT) SetQuestState(cr,crv.CaravanId, CARAVAN_FAILURE_PLAYER_ABANDONED);} // статус "покинул караван" только для тех кто "присоединился"
#define _SetPlayerDead #(cr,crv) {uint q=GetQuestState(cr,crv.CaravanId); if(q==CARAVAN_PLAYER_JOIN_FIRST||q==CARAVAN_PLAYER_JOIN_NEXT) SetQuestState(cr,crv.CaravanId, CARAVAN_FAILURE_PLAYER_DEAD);} // аналогично при смерти игрока
#define _SetCaravanLeaderDead #(cr,crv) {uint q=GetQuestState(cr,crv.CaravanId); if(q==CARAVAN_PLAYER_JOIN_FIRST||q==CARAVAN_PLAYER_JOIN_NEXT) SetQuestState(cr,crv.CaravanId, CARAVAN_FAILURE_CARAVANLEADER_DEAD);} // аналогично при смерти караванщика
#define _SetPlayerKillLeader#(cr,crv) {SetQuestState(cr,crv.CaravanId, CARAVAN_FAILURE_PLAYER_KILL_LEADER);}
#define _SetJoinNext#(cr,crv) {uint q=GetQuestState(cr,crv.CaravanId); if(q==CARAVAN_QUEST_COMPLETE) SetQuestState(cr,crv.CaravanId, CARAVAN_PLAYER_JOIN_NEXT);}
#define _SetSuccessNext #(cr,crv) {uint q=GetQuestState(cr,crv.CaravanId); if(q==CARAVAN_PLAYER_JOIN_NEXT) SetQuestState(cr,crv.CaravanId, CARAVAN_SUCCESS_NEXT);} // после первого или последующего успеха
#define _SetPlayerJoin #(cr, crv){uint q=GetQuestState(cr,crv.CaravanId); if(q==CARAVAN_QUEST_TAKEN){_SetPlayerJoinFirst(cr, crv);} if(q==CARAVAN_QUEST_COMPLETE){_SetJoinNext(cr, crv);}}
bool _CanPlayerJoinCaravan (Critter & cr,CaravanInfo & crv){uint q=GetQuestState(cr,crv.CaravanId); return (q==CARAVAN_QUEST_COMPLETE||q==CARAVAN_NOQUEST || q==CARAVAN_QUEST_TAKEN);} // после первого, последующего успеха или при взятом квесте
bool _GetPlayerQuestFailed (Critter & cr,CaravanInfo & crv){uint q=GetQuestState(cr,crv.CaravanId); return (q>=CARAVAN_FAILURE_PLAYER_THIEFT&&q<=CARAVAN_FAILURE_PLAYER_KILL_LEADER);} // игрок завалил ранее квест

// Debug Log
//#define DL#(s) (Log(s))
#define DL#(s)
//#define DL2 #(s) (Log("DL2" + s))
#define DL2#(s)
import void FindEncounter(Critter@[]& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer, bool empty) from "worldmap";
import void InviteToEncounter(Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir) from "worldmap";
import uint GetNearFullSecond(uint16 year, uint16 month, uint16 day, uint16 hour, uint16 minute, uint16 second) from "time";

void SetQuestState(Critter & player, uint idCaravan, int state)
{
	CaravanInfo @ ci=_GetCaravan(idCaravan);
	if (!valid(ci)) return;
	GameVar @qVar=GetLocalVar(ci.QuestVarNum, player.Id);
	if (!valid(qVar)) return;

	qVar=state;

}
uint GetQuestState(Critter & player, uint idCaravan)
{
	CaravanInfo @ ci=_GetCaravan(idCaravan);
	if (!valid(ci)) return 0;
	GameVar @qVar=GetLocalVar(ci.QuestVarNum, player.Id);
	if (!valid(qVar)) return 0;
	return qVar.GetValue();
}

// вспомогательный класс для задания позиции нпц на карте
// сохраняет координаты нпц (прототип карты, позиция по Х или Y)
// умеет себя копировать
class NpcPosition
{
	// конструктор
	NpcPosition(uint16 locPid, uint16 mapPid, uint16 hX, uint16 hY)
	{
		this.MapProtoId=mapPid;
		this.HexX=hX;
		this.HexY=hY;
		this.LocPid=locPid;
	}

	uint16 LocPid;											//
	uint16 MapProtoId; 										// код прототипа карты
	uint16 HexX;											// позиция нпц на карте по оси X
	uint16 HexY;											// позиция нпц на карте по оси У

	NpcPosition @ Copy()
	{
		return NpcPosition(this.LocPid, this.MapProtoId, this.HexX, this.HexY);
	}

	Map @ GetMap()
	{
		return GetMapByPid(this.MapProtoId, 0);
	}


}
// обмен значениями между двумя экземплярами класса
void SwitchNpcPosition(NpcPosition & posA, NpcPosition & posB)
{
	NpcPosition @ pos=posA.Copy();

	posA.LocPid=posB.LocPid;
	posA.MapProtoId=posB.MapProtoId;
	posA.HexX=posB.HexX;
	posA.HexY=posB.HexY;

	posB.LocPid=pos.LocPid;
	posB.MapProtoId=pos.MapProtoId;
	posB.HexX=pos.HexX;
	posB.HexY=pos.HexY;

}

// проводник каравана
// если он погибнет, миссия по охране караванов провалена
class CaravanLeaderInfo
{
	CaravanLeaderInfo()
	{
		this.Virtue=MODEL_CRVNR_COWARD; // других моделей поведения пока не реализовано
	}
	uint CaravanId;										// код каравана, который ведет проводник

	NpcPosition @ StartPos; 							// начальные координаты лидера
	NpcPosition @ EndPos; 								// конечные координаты лидера

	// описание НПЦ
	uint DialogId;										// диалог
	uint NpcPid;										// прототип нпц
	uint BagId;											// инвентарь
	uint TeamId;										// команда
	uint AiPack;										// пакет ии
	uint CritterId;										// код криттера, получается уже после того, как караванщик создан
	uint8 Level;										// уровень проводника
	int	Virtue;											// поведение

	bool CheckLeaderInPos(bool startPos)
	{
		NpcPosition @ pos=(startPos?this.StartPos.Copy():this.EndPos.Copy());

		Critter @ leader=this.GetLeader();
		if (!valid(leader)) return false;

		Map @map=leader.GetMap();
		if (!valid(map)) return false;

		DL("map invalid mappid"+pos.MapProtoId);
		if(map.GetProtoId()!=pos.MapProtoId) return false;
		// проверяем насколько далеко проводник от контрольных координат
		return (GetDistantion(leader.HexX, leader.HexY, pos.HexX, pos.HexY)<=LEADER_SEARCH_RADIUS);

	}

	bool TransitToPos(bool startPos)
	{

		Map @ map=(startPos?this.StartPos.GetMap():this.EndPos.GetMap());
		if (!valid(map)) 
		return false;
		Critter @ leader=this.GetLeader();
		if (!valid(leader)) return false;
		DL("Transit leader to position:"+(startPos?"1":"2"));
		return leader.TransitToMap(map.Id, (startPos?this.StartPos.HexX:this.EndPos.HexX), (startPos?this.StartPos.HexY:this.EndPos.HexY), Random(0,5));
	}

	Critter @ GetLeader()
	{
		return GetCritter(this.CritterId);
	}

	// установка лидера на указанную позицию
	bool PlaceLeaderCritterToPos(NpcPosition & pos)
	{
		Map @ map=pos.GetMap();
		if (!valid(map)) return false;
		uint16 x=pos.HexX;
		uint16 y=pos.HexY;
		if (!GetFreeHex(map, 2, x, y)) return false;
		int[] params={ST_DIALOG_ID, DialogId, ST_TEAM_ID, TeamId, ST_AI_ID, AiPack, ST_BAG_ID, BagId, ST_LEVEL, Level};
		Critter @ leader=map.AddNpc(this.NpcPid, x, y, Random(0,5), params, null, null);
		if (!valid(leader)) return false;
		leader.CrvId=this.CaravanId;
		this.CritterId=leader.Id;
		DL("leader level "+leader.Stat[ST_LEVEL]+"caravan level "+this.Level);
		return true;
	}

	// присваивание статуса проводника существующему криттеру
	void SetLeaderCritter(Critter & leader)
	{
		DL("leader critter set called/ CaravanInfo="+this.CaravanId);
		this.CritterId=leader.Id;
		leader.StatBase[ST_TEAM_ID]=this.TeamId;
		leader.StatBase[ST_BAG_ID]=this.BagId;
		leader.StatBase[ST_DIALOG_ID]=this.DialogId;
		leader.StatBase[ST_AI_ID]=this.AiPack;
		leader.StatBase[ST_LEVEL]=this.Level;

		leader.CrvId=this.CaravanId;
		this.CritterId=leader.Id;
	}
}

// вспомогательный класс, предмет для караванной повозки
class CaravanLootItem
{
	CaravanLootItem()
	{
		this.ItemPid=0;
		this.ItemMinAmount=0;
		this.ItemMaxAmount=0;
		this.ItemAppearChance=0;
		this.IsReversedRouteItem=false;
	}
	uint  ItemPid; 										// код прототипа итема
	uint16 ItemMinAmount; 								// минимальное количество итемов
	uint16 ItemMaxAmount; 								// максимальное количество итемов
	uint8 ItemAppearChance; 							// шанс появления итема, в процентах, 100%=всегда появляется
	bool  IsReversedRouteItem;                          // признак - итем появится только на обратном пути
	// текущее число итемов
	uint8 Amount()
	{
		if(this.ItemMinAmount==this.ItemMaxAmount)
		{
			return this.ItemMaxAmount;
		}

		return this.ItemMinAmount<this.ItemMaxAmount?Random(this.ItemMinAmount, this.ItemMaxAmount):Random(this.ItemMaxAmount, this.ItemMinAmount);
	}
	// признак, появилось или нет в этот раз
	bool IsAppear()
	{
		return Random(1,100)<this.ItemAppearChance;
	}
}

// караванная повозка, расписывается содержимое ящиков
class CaravanCabInfo
{
	CaravanCabInfo()
	{
		this.CabPid=Random(PID_WAGON_RED, PID_WAGON_GREY);
	}
	CaravanCabInfo(uint16 cabPid)
	{
		this.CabPid=cabPid;
	}
	CaravanLootItem[] CabItems; 						// вещи в повозке
	uint16 CabPid; 										// прототип повозки

	// добавление итема в повозку
	void AddLoot(uint itemPid, uint16 minNum, uint16 maxNum, uint8 chanceAppear, bool isReversLoot)
	{
		CaravanLootItem @ li=CaravanLootItem();
		li.ItemPid=itemPid;
		li.ItemMinAmount=minNum;
		li.ItemMaxAmount=maxNum;
		li.ItemAppearChance=chanceAppear;
		li.IsReversedRouteItem=isReversLoot;

		this.CabItems.insertLast(li);
		DL("cab items:"+this.CabItems.length());
	}
	// размещение повозки с лутом на энкаунтере
	Item@ PlaceCabOnMap(Map & map, uint x, uint y, bool isReveresed)
	{
		DL("trying place cab");
		Item @ cab=map.AddItem(x,y,this.CabPid,1);
		if (!valid(cab)) return null;
		UNSETFLAG(cab.Flags,ITEM_NO_BLOCK);
		DL("try place brahmins");
		// брамины: 1ый х=х0 у=у+1, второй ч х=х-1 у=у-3? dir=1
		if(map.IsHexPassed(x,y+1)) map.AddNpc(NPC_PID_Brahmin, x, y+1, 1, null, null, null);
		if(map.IsHexPassed(x-1,y-3)) map.AddNpc(NPC_PID_Brahmin, x-1, y-3, 1, null, null, null);
		uint num=0;
		DL("cab items:"+this.CabItems.length());
		for(uint i=0, iMax=this.CabItems.length();i<iMax;i++)
		{
			DL("try item appear");
			if(this.CabItems[i].IsReversedRouteItem==isReveresed)
			{
				num=this.CabItems[i].Amount();
				if(this.CabItems[i].IsAppear()&&num>0)
				{
					DL("Adding loot to cab");
					cab.AddItem(this.CabItems[i].ItemPid, num, 0);
				}
			}
		}
		cab.Update();
		return cab;
	}

}

// вспомогательный класс для хранения координат
class GlobalPoint
{
	uint X;
	uint Y;
	GlobalPoint(uint x, uint y)
	{
		this.X=x;
		this.Y=y;
	}
}

// маршрут следования каравана - ломаная линия
class GlobalRouteCurve
{
	GlobalRouteCurve()
	{

	}
	// добавление нового узла в маршрут
	void AddPoint(GlobalPoint @ point)
	{
		Points.insertLast(point);
	}
	// массив координат узлов ломанного маршрута
	// должен включать и начальную с конечной точкой
	GlobalPoint[] Points;
	int nextPoint;
	bool RouteEnded()
	{
		return (nextPoint==-1);
	}
	// если караван достиг узла ломаной маршрута, меняем координаты точки назначения на следующую в маршруте
	void SetRouteDir(uint x, uint y, float& toX, float& toY)
	{
		// нет ни одной точки в маршруте
		if(Points.length()==0)
		{
			nextPoint=-1;
			return;
		}
		// маршрут закончен
		if(nextPoint==-1)
		{
			return;
		}
		// достигнут один из узлов маршрута
		if(x==Points[nextPoint].X&&y==Points[nextPoint].Y)
		{
			//если это последняя точка маршрута, меня ничего не нужно
			if(nextPoint==(-1+Points.length()))
			{
				nextPoint=-1;
				return;
			}else{
				nextPoint++;
			}
		}
		toX=float(Points[nextPoint].X);
		toY=float(Points[nextPoint].Y);

	}
	// преобразование марщрута в обратный
	void ReverseRouteCurve()
	{
		GlobalPoint[] Points2 (this.Points.length());

		for(uint i=0, iMax=this.Points.length(); i<iMax;i++)
		{
			DL("try copy point");
			// TODO: проверить, что это копирование сработает
			Points2[i]=this.Points[i];
		}
		this.Points.resize(0);
		for(int j=(Points2.length()-1); j>=0;j--)
		{
		DL("try copy point - 2/j="+j+"Points2.length()-1="+(Points2.length()-1));
			this.AddPoint(Points2[j]);
			if(j==0) return;
		}
		DL("Reverse route success");
	}
}
// вспомогательный класс - описания охранников каравана
class CaravanGuardInfo
{
	CaravanGuardInfo(uint idCaravan, uint16 pid, uint dialogId, string scriptId, uint aiPack, uint bagId, uint teamId, uint level, uint reaction, uint isNervous, uint8 chanceJoin, bool isUnique)
	{
		this.CaravanId=idCaravan;
		this.Pid=pid;
		this.DialogId=dialogId;
		this.ScriptId=scriptId;
		this.AiPack=aiPack;

		this.BagId=bagId;
		this.TeamId=teamId;
		this.Level=level;
		this.ReactionNum=reaction;
		this.IsNervous=isNervous;
		this.ChanceToJoin=CLAMP(chanceJoin, 0, 100);
		this.IsUnique=isUnique;
	}

	uint 	CaravanId;									// код каравана
	uint16 	Pid; 										// код прототипа криттера
	uint 	DialogId; 									// диалог
	string 	ScriptId; 									// скрипт
	uint 	AiPack; 									// ИИ
	uint 	BagId;										// инвентарь
	uint16 	TeamId;										// команда
	uint 	Level;										// уровень
	uint 	ReactionNum; 								// реакция - условный параметр, показывающий, как быстро реагирует нпц на смену обстановки
	uint 	IsNervous; 									// признак - нервный, будет часто жаловаться
	uint8 	ChanceToJoin;								// шанс присутствия в охране, в процентах
	bool 	IsUnique;									// признак, уникальный в рамках одного похода караванов

	// пытается поставить охранника с определенной долей вероятности.
	// если не удалось, возвращает  null
	// leader - проводник каравана
	Critter @ GetCritterGuard(Map & map, Critter & leader)
	{
		if(Random(1,100)>this.ChanceToJoin) return null;

		uint16 hX=leader.HexX;
		uint16 hY=leader.HexY;
		if (!GetFreeHex(map, 4, hX, hY)) return  null;

		int[] params={ST_DIALOG_ID, DialogId, ST_TEAM_ID, TeamId, ST_AI_ID, AiPack, ST_BAG_ID, BagId, ST_LEVEL, Level, ST_VAR1, ReactionNum, ST_VAR2, IsNervous};
		Critter @ guard=map.AddNpc(this.Pid, hX, hY, Random(0,5), params, null, ScriptId);
		if (!valid(guard)) return  null;
		// если охранник помечен уникальным - отмечаем его присоединившимся и криттер больше не будет генериться данным методом
		if(this.IsUnique) this.ChanceToJoin=0;
		guard.CrvId=this.CaravanId;

		return guard;
	}
}

// вспомогательный класс для описания нпц в составе каравана, которые не отображаются в составе группы на глобале. Например, брамины при перегонке нкр-реддинг
// появляются только на энкаунтере
class CaravanNpcFollowerInfo
{
	CaravanNpcFollowerInfo()
	{
	}
	uint	CaravanId;									// код каравана
	uint16	Pid;										// код прототипа криттера
	uint    DialogId;									// диалог
	uint16 	TeamId;										// команда
	uint    BagId;										// команда

	// добавление нпц рядом с итемом
	bool _AddNpcNearItem(Map & map, Item & item, uint8 dist)
	{
		uint16 hX=item.HexX;
		uint16 hY=item.HexY;
		if (!GetFreeHex(map, dist, hX, hY)) return false;

		int[] params={ST_DIALOG_ID, DialogId};
		return valid(map.AddNpc(this.Pid, hX, hY, Random(0,5), params, null, null));
	}

	// добавление нпц рядом с криттером
	void _AddNpcNearCritter(Map & map, Critter & cr, uint8 dist)
	{
		AddNpcNearCritter(map, cr, dist);
	}

	Critter @ AddNpcNearCritter(Map & map, Critter & cr, uint8 dist)
	{
		uint16 hX=cr.HexX;
		uint16 hY=cr.HexY;
		if (!GetFreeHex(map, dist, hX, hY)) return null;

		int[] params={ST_DIALOG_ID, DialogId};
		return map.AddNpc(this.Pid, hX, hY, Random(0,5), params, null, null);
	}
}
// основное описание караванов
class CaravanInfo
{
	CaravanInfo()
	{
		this.MaxPlayers=5;
		this.MaxGroup=10;
		this.IsReversed=false;
		this.CaravanStatus=0;
	}

	uint   CaravanId;									// код каравана
	uint8  Type;										// тип каравана, односторонний или двусторонний
	uint8  CaravanStatus;								// текущее состояние каравана
	uint8  GlobalSpeedMultiplayer;						// множитель скорости движения по глобальной карте
	uint   QuestVarNum;									// номер квестовой переменной для данного каравана
	uint   MaxPlayers;									// максимальное число игроков в составе каравана. Пока поставлено 5 для всех караванов.
	uint   MaxGroup;									// максимальное число нпц/игроков в группе, включая проводника
	bool   IsReversed;									// признак - караван идет по обратному маршруту
	// описания
	CaravanLeaderInfo @  Leader;						// проводник каравана
	CaravanCabInfo @[]   Cabs;							// повозки
	GlobalRouteCurve   CaravanRoute;					// маршрут следования каравана
	CaravanGuardInfo @[] CaravanGuards; 				// массив описаний охранников
	CaravanNpcFollowerInfo@[] Followers;				// массив описаний спутников каравана (брамины, нейтральные персонажи итд)

	// игроки/нпц охранники
	uint[]               PlayersRequested;				// массив Id игроков, подавших заявку на участие
	uint[]               Caravaneers;					// массив Id игроков и нпц-караванщиков в составе каравана


	void TerminateCaravan()
	{
		this.CaravanStatus=CRV_STATUS_END;
		if(valid(this.Leader))
		{
			Critter @ leader=this.Leader.GetLeader();
			if(valid(leader))
			{
				DL("Leader deleted");
				DeleteNpc(leader);
				this.Leader.CritterId=0;
			}
		}
		for(uint i=0, iMax=this.Caravaneers.length(); i<iMax; i++)
		{
			Critter @ guard=GetCritter(this.Caravaneers[i]);
			if(valid(guard))
			{
				if(guard.IsNpc())
				{
					DeleteNpc(guard);
					continue;
				}
			}
		}
		_SetQuestState(this, CARAVAN_FAILURE_PLAYER_ABANDONED);
		this.CaravanReset();
	}

	void CaravanReset()
	{
		this.PlayersRequested.resize(0);
		// внимание! нет удаления нпц, поскольку они могут быть и на глобале и удаление сломается
		// удалением необходимо управлять в другом месте
		this.Caravaneers.resize(0);
		this.CaravanStatus=CRV_STATUS_BEFORE_START;
		this.CaravanRoute.nextPoint=0;
	}
	// удаление охранника из списка охранников каравана
	// id - Id криттера
	bool RemoveGuard(uint id)
	{
		DL("RemoveGuard start/ Player Id="+ id);
		for(uint i=0, iMax=this.Caravaneers.length(); i<iMax; i++)
		{
			if(id==this.Caravaneers[i])
			{
				this.Caravaneers.removeAt(i);
				return true;
			}
		}
		for(uint i=0, iMax=this.PlayersRequested.length(); i<iMax; i++)
		{
			if(id==this.PlayersRequested[i])
			{
				this.PlayersRequested.removeAt(i);
				return true;
			}
		}
		return false;
	}
	// проверка, игрок является охранником данного каравана?
	bool PlayerIsGuard(uint playerId)
	{
		for(uint i=0, iMax=this.Caravaneers.length(); i<iMax; i++)
		{
			if(playerId==this.Caravaneers[i])
			{
				return true;
			}
		}
		return false;
	}
	// перенос игрока в список охранников
	// id - код игрока
	// внимание! нет проверки, что криттер найден. Проверять нужно в другом месте перед вызовом метода
	void RequstedToGuard(uint id)
	{
		for(uint i=0, iMax=this.Caravaneers.length(); i<iMax;i++)
		{
			// уже есть в списках
			if(id==this.Caravaneers[i]) return;
		}
		this.Caravaneers.insertLast(id);
	}

	CaravanCabInfo @GetCab(int8 idx)
	{
		DL("Getting cab info");
		if (!valid(this.Cabs)) return null;
		if(this.Cabs.length()==0) return null;
		DL("cabs found");
		if(idx<0)
		{
			return this.Cabs[Random(0,this.Cabs.length()-1)];
		}else{
			if(this.Cabs.length()<=uint8(idx)) return this.Cabs[0];
			return this.Cabs[uint8(idx)];
		}
	}

	// добавление точки в маршрут
	void AddRoutePoint(uint x, uint y)
	{
		this.CaravanRoute.AddPoint(GlobalPoint(x,y));
		this.CaravanRoute.nextPoint=0;
	}
}

/* ******************************** вспомогательные функции ******************************** */
// ищет свободный гекс рядом с указанными координатами
// если найдет - возвращает true
// иначе - false
// карта - где ищем гекс
// радиус на котором нужно искать
// hx, hy координаты нового гекса
bool GetFreeHex(Map& map, uint radius, uint16& hx, uint16& hy)
{
	if(hx==0 || hy==0 || hx>=(map.GetWidth()-radius) || hy>=(map.GetHeight()-radius)) return false; // Check borders
	int numTry=10; // число попыток найти свободный гекс
	int xDelta=0;
	int yDelta=0;

	for(int i=0;i<numTry;i++)
	{
		xDelta=Random(0,radius*2)-radius;
		yDelta=Random(0,radius*2)-radius;
		if(map.IsHexPassed(hx+xDelta,hy+yDelta))
		{
			hx+=xDelta;
			hy+=yDelta;
			return true;
		}
	}
	return false;
}
// ищет на указанной карте криттера с нужным диалогом и прототипом
// ищет только нпц
uint GetCrittersByDialogId(Map @ map, int dialog, uint pid, Critter @[]@ critters)
{
	if (!valid(map)) return 0;
	if(dialog==0) return 0;
	Critter @[] foundCrits;
	if(map.GetCritters (pid, FIND_ALL|FIND_ONLY_NPC, foundCrits)==0) return 0;
	uint num=0;
	for(uint i=0, iMax=foundCrits.length(); i<iMax;i++)
	{
		if(foundCrits[i].StatBase[ST_DIALOG_ID]==dialog)
		{
			num++;
			critters.insertLast(@foundCrits[i]);
		}
	}
	return num;
}

