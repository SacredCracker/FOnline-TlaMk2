// Author rifleman17
// Монологи для НПЦ: несколько фраз. повторяемых через определенные промежутки времени.
// Указывается первая и последняя строка монолога, время, через которое повторится монолог и т.д.
// Строки должны быть записаны в FOTEXT.MSG
// Строки монолога должны нумероваться подряд.
// Если время следующего диалога равно нулю, все записи из AnyData будут удалены после первого использования

#include "_macros.fos"
#include "serializator.fos"

#define _AnyDataKey #(crId)     ("Monologue_"+crId)
#define CTE_RUN_MONOLOG         (60)
#define CTE_NEXT_MESSAGE        (61)

bool MonologueRunning(Critter& cr) // Export
{
	return valid(GetMonologue(cr));
}

void SetMonologue(Critter@ cr, uint firstStr, uint lastStr, uint nextMsg, uint nextDialog, uint8 sayType) // Export
{
	Monologue@ m=Monologue(firstStr, lastStr, nextMsg, nextDialog, sayType, cr.Id);
	if(valid(m))
	{
		m.ScheduleMonologue();
	}
}

Monologue@ GetMonologue(Critter@ cr)
{
	if (!valid(cr))
		return null;
	Monologue@ m=Monologue(cr.Id);
	if (!valid(m) || !m.Exist())
		return null;
	m.Load();
	return m;
}

class Monologue
{
	Monologue(uint critterId)
	{
		this.CritterId=critterId;
	}
	Monologue(uint firstStr, uint lastStr, uint nextMsg, uint nextDialog, uint8 sayType, uint critterId)
	{
		this.FirstString=firstStr;
		this.LastString=lastStr;
		this.CurrentString=0;
		this.NextMessage=nextMsg;
		this.NextDialogue=nextDialog;
		this.SayType=sayType;
		this.CritterId=critterId;
		this.Save();
	}
	
	uint FirstString;    // Номер первой строки в монологе
	uint LastString;     // Номер последней строки
	uint CurrentString;  // Текущая строка
	uint   NextMessage;    // Время следующей фразы в монологе в секундах
	uint   NextDialogue;   // Время следующего монолога
	uint8  SayType;        // Тип разговора (шепот, эмоции итд)
	uint   CritterId;      // Код криттера, читающего монолог	
	
	bool Exist()
	{
		return IsAnyData(_AnyDataKey(this.CritterId));
	}
	
	// Сериализация в AnyData
	void Save()
	{
		Serializator save;
		save.Set(this.FirstString);
		save.Set(this.LastString);
		save.Set(this.CurrentString);
		save.Set(this.NextMessage);
		save.Set(this.NextDialogue);
		save.Set(this.SayType);
		save.Set(this.CritterId);
		save.Save(_AnyDataKey(this.CritterId));
	}
	
	void Load()
	{
		Serializator load;
		if (!load.Load(_AnyDataKey(this.CritterId)))
			return;		
		load.Get(this.FirstString);
		load.Get(this.LastString);
		load.Get(this.CurrentString);
		load.Get(this.NextMessage);
		load.Get(this.NextDialogue);
		load.Get(this.SayType);
		load.Get(this.CritterId);
	}
	
	void Erase()
	{
		if(this.Exist())
		{
			EraseAnyData(_AnyDataKey(this.CritterId));
		}	
	}
	
	void ScheduleMonologue()
	{
		Critter@ cr=GetCritter(this.CritterId);
		if (!valid(cr))
			return;
		if(cr.GetTimeEvents(CTE_RUN_MONOLOG, null, null, null)==0)
		{
			cr.AddTimeEvent("cte_RunMonologue", this.NextDialogue, CTE_RUN_MONOLOG);
		}
	}
	
	void ScheduleMessage()
	{
		Critter@ cr=GetCritter(this.CritterId);
		if (!valid(cr))
			return;
		if(cr.GetTimeEvents(CTE_NEXT_MESSAGE, null, null, null)==0)
		{
			cr.AddTimeEvent("cte_NextMessage", this.NextMessage, CTE_NEXT_MESSAGE);
		}
	}
	
}
// Начало диалога
uint cte_RunMonologue(Critter& cr, int identifier, uint& rate)
{
	Monologue@ m=GetMonologue(cr);
	if(valid(m))
	{
		m.CurrentString=m.FirstString;
		m.Save();
		m.ScheduleMessage();
		return m.NextDialogue;
	}
	return 0;
}

uint cte_NextMessage(Critter& cr, int identifier, uint& rate)
{
	Monologue@ m=GetMonologue(cr);
	if(valid(m))
	{
		if(m.CurrentString > m.LastString)
		{
			if(m.NextDialogue==0) // Диалог одноразовый
				m.Erase();
			return 0;
		}
		cr.SayMsg(m.SayType, TEXTMSG_TEXT, m.CurrentString);
		m.CurrentString++;
		m.Save();		
		return m.NextMessage;
	}
	return 0;
}

// Баллада паладина БС
bool d_MonologueRunning(Critter& player, Critter@ npc)
{
	return (valid(npc) && MonologueRunning(npc));
}

bool d_NotMonologueRunning(Critter& player, Critter@ npc)
{
	return !d_MonologueRunning(player, npc);
}

void r_RunMonologue(Critter& player, Critter@ npc, int firstStr, int lastStr, int nextMsg, int nextDialog, int sayType)
{
	SetMonologue(npc, firstStr, lastStr, nextMsg*__TimeMultiplier, nextDialog, sayType); 
}